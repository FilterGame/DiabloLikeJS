<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D 暗黑破坏神 Clone (Three.js)</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; color: white; font-family: "Microsoft YaHei", sans-serif; }
        canvas { display: block; }
        #ui-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            color: white;
            font-size: 12px;
            z-index: 10; /* Ensure UI is above canvas */
        }
        .ui-element {
            pointer-events: auto;
            position: absolute;
            background-color: rgba(25, 25, 25, 0.85);
            border: 1px solid rgba(180, 150, 100, 0.7);
            border-radius: 4px;
            padding: 5px;
            box-shadow: 0 0 10px rgba(0,0,0,0.5);
        }
        #hud {
            bottom: 10px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 5px;
            width: 50%;
            min-width: 300px;
            max-width: 500px;
            padding: 8px;
        }
        #bottom-bars{
             display: flex;
             justify-content: center;
             width: 100%;
             gap: 10px;
        }
        .stat-bar-container {
             flex-grow: 1;
             display: flex;
             align-items: center;
             gap: 5px;
        }
        .stat-label{
            width: 30px;
            text-align: right;
            font-size: 11px;
            color: #ddd;
            white-space: nowrap;
        }
        .stat-bar {
            flex-grow: 1;
            height: 18px;
            background-color: rgba(50, 50, 50, 0.8);
            border-radius: 3px;
            position: relative;
            border: 1px solid #444;
            overflow: hidden;
        }
        .stat-bar-inner {
            height: 100%;
            position: absolute;
            top: 0;
            left: 0;
            border-radius: 3px;
            transition: width 0.2s ease-out;
        }
        .hp-bar { background-color: rgba(200, 40, 40, 0.9); }
        .mp-bar { background-color: rgba(80, 80, 220, 0.9); }
        .xp-bar { background-color: rgba(200, 200, 80, 0.9); height: 8px; }
        .bar-text {
            position: absolute;
            width: 100%;
            height: 100%;
            top: 0;
            left: 0;
            text-align: center;
            line-height: 18px;
            font-size: 11px;
            font-weight: bold;
            color: white;
            text-shadow: 1px 1px 1px black;
        }
        .xp-bar-text {
             line-height: 8px; font-size: 9px;
        }
        #skill-bar {
             display: flex;
             gap: 5px;
             margin-top: 8px;
        }
        #skill-bar .item-slot { /* Reuse item slot style */
             width: 40px;
             height: 40px;
             font-size: 10px;
             cursor: default; /* No clicking on skill bar itself */
             overflow: hidden; /* Hide overflowing text */
             line-height: 1; /* Adjust line height */
             padding: 2px;
             box-sizing: border-box;
             text-align: center;
        }
        #skill-bar .skill-icon {
             width: 100%; height: 100%;
             background-color: #555; /* Default skill background */
             border-radius: 3px;
             display: flex;
             flex-direction: column;
             justify-content: center;
             align-items: center;
             position: relative; /* For cooldown overlay */
        }
        #skill-bar .skill-name {
             font-size: 9px;
             white-space: nowrap;
             text-overflow: ellipsis;
             overflow: hidden;
             max-width: 90%;
             margin-bottom: 2px;
        }
        #skill-bar .skill-keybind {
             font-size: 9px; color: #ccc;
             position: absolute;
             bottom: 2px; right: 3px;
        }
         #skill-bar .skill-cooldown-overlay {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            background-color: rgba(0,0,0,0.7);
            display: flex;
            justify-content: center;
            align-items: center;
            color: #ffcc00;
            font-size: 14px;
            font-weight: bold;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.1s linear;
         }
          #skill-bar .skill-cooldown-overlay.visible {
             opacity: 1;
          }


        #system-messages {
            position: absolute;
            bottom: 120px; /* Adjusted for skill bar */
            left: 15px;
            max-width: 40%;
            display: flex;
            flex-direction: column-reverse;
            gap: 3px;
        }
        .message {
            background-color: rgba(0,0,0,0.6);
            padding: 3px 6px;
            border-radius: 3px;
            font-size: 13px;
            opacity: 1;
            transition: opacity 0.5s ease-out;
        }
        .message.fading { opacity: 0; }

        /* Panels */
        #inventory-panel, #equipment-panel, #skill-panel {
             display: none;
             flex-direction: column;
             gap: 5px;
             max-height: 80vh; /* Limit panel height */
             overflow-y: auto; /* Allow scrolling if needed */
        }
        #inventory-panel.visible, #equipment-panel.visible, #skill-panel.visible {
             display: flex;
        }
         .panel-title {
             text-align: center;
             font-size: 16px;
             font-family: 'SimSun', serif;
             color: #e0d0b0;
             margin-bottom: 5px;
         }
         .slot-grid { display: grid; gap: 6px; }
         .inventory-grid { grid-template-columns: repeat(4, 45px); }
         .equipment-grid { grid-template-columns: 45px 1fr; align-items: center; }
         .item-slot {
            width: 45px; height: 45px;
            background-color: rgba(40, 40, 40, 0.9);
            border: 1px solid #666;
            border-radius: 4px;
            position: relative;
            display: flex; justify-content: center; align-items: center;
            cursor: pointer;
         }
         .item-slot:hover { border-color: #aaa; }
         .item-icon { /* Placeholder for actual icon */
            width: 70%;
            height: 70%;
            border-radius: 3px;
            background-color: grey; /* Default */
            position:relative; /* For glow */
            box-shadow: inset 0 0 5px rgba(0,0,0,0.5);
         }
         .item-icon::before { /* Rarity Glow */
              content: '';
              position: absolute;
              top: -3px; left: -3px; right: -3px; bottom: -3px;
              border-radius: 5px;
              box-shadow: 0 0 5px 2px transparent;
              opacity: 0.7;
         }
         .icon-consumable-hp { background-color: #f55; }
         .icon-consumable-mp { background-color: #55f; }
         .icon-equipment-weapon { background: linear-gradient(45deg, #aaa, #ddd); width: 30%; height: 80%;}
         .icon-equipment-armor { background-color: #bbb; width: 80%; height: 80%;}
         .icon-equipment-helmet { background-color: #aaa; border-radius: 50% 50% 0 0; width: 70%; height: 60%; align-self: flex-start; margin-top: 15%;}
         .icon-equipment-boots { background-color: #986; width: 60%; height: 50%; align-self: flex-end; margin-bottom: 10%;}
         .icon-equipment-ring { background-color: #ccc; border-radius: 50%; width: 50%; height: 50%; border: 3px solid #999;} /* Simple Ring */
         .icon-equipment-amulet { background-color: #b99; width: 60%; height: 60%; transform: rotate(45deg);} /* Simple Amulet */
         .icon-material { background-color: #999; border-radius: 50%;}
         .icon-default { background-color: #777; }

         .item-quantity {
            position: absolute;
            bottom: 2px;
            right: 4px;
            font-size: 11px;
            font-weight: bold;
            color: white;
            text-shadow: 1px 1px 1px black;
         }
         .slot-label {
            font-size: 11px;
            color: #bbb;
            padding-left: 5px;
         }

         /* Skill Panel Specific Styles */
        #skill-panel {
             left: 50%;
             top: 50%;
             transform: translate(-50%, -50%);
             width: 600px; /* Wider panel for skills */
             max-width: 90vw;
             padding: 15px;
             background-color: rgba(30, 30, 30, 0.9);
        }
        #skill-points-display {
             text-align: center;
             margin-bottom: 15px;
             font-size: 14px;
             color: #ffcc00;
        }
        #skill-list {
             display: grid;
             grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); /* Responsive grid */
             gap: 10px;
        }
        .skill-entry {
             background-color: rgba(50, 50, 50, 0.8);
             border: 1px solid #555;
             border-radius: 4px;
             padding: 8px;
             display: flex;
             flex-direction: column;
             gap: 4px;
        }
        .skill-entry.locked { border-color: #800; background-color: rgba(80, 30, 30, 0.7);}
        .skill-entry.can-unlock { border-color: #080; background-color: rgba(30, 80, 30, 0.7);}
        .skill-header {
             display: flex; justify-content: space-between; align-items: center;
             font-weight: bold; font-size: 14px;
        }
        .skill-name { color: #eee; }
        .skill-cost { font-size: 11px; color: #8af; } /* MP Cost */
        .skill-description { font-size: 12px; color: #bbb; flex-grow: 1; }
        .skill-requirements { font-size: 11px; color: #aaa; }
        .skill-actions button {
             pointer-events: auto; /* Make buttons clickable */
             padding: 3px 8px; margin-left: 5px;
             font-size: 11px; background-color: #666; border: 1px solid #888; color: white; border-radius: 3px; cursor: pointer;
        }
        .skill-actions button:hover { background-color: #888; }
        .skill-actions button:disabled { background-color: #444; color: #888; cursor: not-allowed; }
        .skill-assign-button { background-color: #484; }
        .skill-assign-button:hover { background-color: #6a6; }
        .skill-unlocked-text { color: limegreen; font-weight: bold; font-size: 11px;}


         #tooltip {
            position: absolute;
            display: none; /* Hidden by default */
            max-width: 250px;
            background-color: rgba(15, 15, 15, 0.95);
            border: 1px solid #b4b478;
            border-radius: 4px;
            padding: 8px 12px;
            font-size: 13px;
            line-height: 1.4;
            white-space: pre-wrap; /* Respect newlines */
            z-index: 100;
            pointer-events: none; /* Tooltip doesn't block clicks */
         }

         #floating-text-container {
             position: absolute;
             top: 0; left: 0;
             width: 100%; height: 100%;
             overflow: hidden;
             pointer-events: none;
             z-index: 50;
         }
         .floating-text {
             position: absolute;
             font-size: 16px;
             font-weight: bold;
             text-shadow: 1px 1px 2px black;
             white-space: nowrap;
             transform: translateX(-50%); /* Center horizontally */
             transition: transform 1s ease-out, opacity 1s ease-out;
         }

        .health-bar-world {
            position: absolute;
            width: 40px; /* Fixed width for simplicity */
            height: 5px;
            background-color: rgba(80, 0, 0, 0.7);
            border: 1px solid black;
            border-radius: 2px;
            transform: translateX(-50%); /* Center */
            overflow: hidden;
        }
        .health-bar-world-inner {
            height: 100%;
            background-color: #ff0000;
            transition: width 0.2s linear;
        }
         .npc-health-bar-world-inner { background-color: #00cc00; } /* Green for NPCs */

        #game-over-screen {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background-color: rgba(0,0,0,0.8);
            display: none; /* Hidden by default */
            justify-content: center;
            align-items: center;
            flex-direction: column;
            text-align: center;
            z-index: 200;
            pointer-events: auto;
        }
        #game-over-screen.visible {
            display: flex;
        }
        #game-over-screen h1 {
             font-size: 72px;
             color: #c02020;
             font-family: 'Georgia', serif;
             margin-bottom: 20px;
        }
        #game-over-screen p {
             font-size: 24px;
             color: #ccc;
        }
        #loading-screen {
             position: absolute;
             top: 0; left: 0; width: 100%; height: 100%;
             background-color: #050505;
             display: flex;
             justify-content: center;
             align-items: center;
             z-index: 500;
             font-size: 24px;
        }
        #error-screen {
             position: absolute;
             top: 0; left: 0; width: 100%; height: 100%;
             background-color: #300000;
             display: none; /* Hidden by default */
             justify-content: center;
             align-items: center;
             z-index: 500;
             font-size: 24px;
             color: red;
             text-align: center;
             padding: 20px;
        }
        #error-screen.visible { display: flex; }

    </style>
</head>
<body>
    <!-- UI Overlay Container -->
    <div id="ui-overlay">
        <!-- HUD -->
        <div id="hud" class="ui-element">
            <div id="bottom-bars">
                <div class="stat-bar-container"><span class="stat-label">生命</span><div id="hp-bar" class="stat-bar"><div id="hp-bar-inner" class="stat-bar-inner hp-bar"></div><div id="hp-bar-text" class="bar-text">100/100</div></div></div>
                <div class="stat-bar-container"><div id="mp-bar" class="stat-bar"><div id="mp-bar-inner" class="stat-bar-inner mp-bar"></div><div id="mp-bar-text" class="bar-text">50/50</div></div><span class="stat-label" style="text-align:left;">魔力</span></div>
            </div>
            <div class="stat-bar-container" style="width:100%;"><div id="xp-bar" class="stat-bar xp-bar"><div id="xp-bar-inner" class="stat-bar-inner xp-bar"></div><div id="xp-bar-text" class="bar-text xp-bar-text">等级 1 (0/100)</div></div></div>
            <div id="skill-bar">
                 <div class="item-slot" id="skill-slot-0"><div class="skill-icon"><span class="skill-name"></span><span class="skill-keybind">[1]</span><div class="skill-cooldown-overlay"></div></div></div>
                 <div class="item-slot" id="skill-slot-1"><div class="skill-icon"><span class="skill-name"></span><span class="skill-keybind">[2]</span><div class="skill-cooldown-overlay"></div></div></div>
                 <div class="item-slot" id="skill-slot-2"><div class="skill-icon"><span class="skill-name"></span><span class="skill-keybind">[3]</span><div class="skill-cooldown-overlay"></div></div></div>
                 <div class="item-slot" id="skill-slot-3"><div class="skill-icon"><span class="skill-name"></span><span class="skill-keybind">[4]</span><div class="skill-cooldown-overlay"></div></div></div>
                 {/* Add more slots if needed */}
            </div>
        </div>
        <!-- System Messages -->
        <div id="system-messages"></div>
        <!-- Inventory -->
        <div id="inventory-panel" class="ui-element">
            <div class="panel-title">背包</div><div id="inventory-grid" class="slot-grid inventory-grid"></div>
        </div>
        <!-- Equipment -->
        <div id="equipment-panel" class="ui-element">
            <div class="panel-title">装备</div><div id="equipment-grid" class="slot-grid equipment-grid"></div>
        </div>
        <!-- Skill Panel -->
        <div id="skill-panel" class="ui-element">
             <div class="panel-title">技能树</div>
             <div id="skill-points-display">可用技能点: 0</div>
             <div id="skill-list">
                  <!-- Skills loaded dynamically -->
             </div>
        </div>
        <!-- Tooltip -->
        <div id="tooltip"></div>
        <!-- Floating Text/Health Bars -->
        <div id="floating-text-container"></div>
    </div>
     <!-- Loading/Error/Game Over Screens -->
     <div id="loading-screen">加载中...</div>
     <div id="error-screen">发生错误！请检查控制台。</div>
     <div id="game-over-screen"><h1>你已死亡</h1><p>按 [R] 重新开始</p></div>

    <!-- Three.js Library -->
    <script type="importmap">{ "imports": { "three": "https://unpkg.com/three@0.160.0/build/three.module.js", "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/" } }</script>

    <!-- Game Script -->
    <script type="module">
        import * as THREE from 'three';
        // import { OrbitControls } from 'three/addons/controls/OrbitControls.js'; // Optional

        // --- Global Variables ---
        let scene, camera, renderer, raycaster, mouseNDC;
        let player;
        const monsters = [];
        const npcs = [];
        const worldItems = [];
        const projectiles = [];
        const activeEffects = []; // For skill effects, particle systems
        const visualEffects = []; // 3D visual effects (particle systems, etc. - simplified for now)
        const floatingTexts = [];
        const worldHealthBars = [];
        let villageMap, wildernessMap, currentMap, mapMeshGroup;
        let uiManager;
        let gameState = 'loading';
        let lastMonsterSpawnTime = 0;
        let gameTime = 0;
        const keysPressed = {};
        let groundPlane;
        const intersectableUnits = [];
        const mapObstacleMeshes = [];
        let audioContext, masterGain; // Changed audio variables
        const soundOscillators = {};
        const soundGains = {};
        let masterVolume = 0.2;
        let audioInitialized = false;
        const clock = new THREE.Clock(); // Moved clock init here


        // --- Constants & Game Data ---
        const TILE_SIZE = 5;
        const HALF_TILE_SIZE = TILE_SIZE / 2.0;

        console.log("载入: 游戏数据");
        const UIText = { hp: "生命", mp: "魔力", level: "等级", xp: "经验", attack: "攻击", defense: "防御", speed:"速度", inventory: "背包", equip: "装备", use: "使用", drop: "丢弃", pickup: "拾取", moveTo: "移动到", attackTarget: "攻击", npcGreeting: ["你好，冒险者！", "村庄很安全，外面很危险。", "需要帮忙吗？"], enemySpotted: "发现敌人!", levelUp: "升级了！", itemDropped: "掉落了", inventoryFull: "背包已满！", welcome: "欢迎来到庇护之地", leaveVillage: "离开区域", enterVillage: "进入区域", weapon: "武器", helmet: "头盔", armor: "胸甲", boots: "靴子", amulet: "护身符", ring: "戒指", ring1: "戒指 1", ring2: "戒指 2", skillPanel: "技能", availableSkillPoints: "可用技能点", unlock: "解锁", assignTo: "设置到", requiresLevel: "需要等级", skillPointCost: "技能点", cooldown: "冷却", manaCost: "法力消耗", assignSlot: "设置快捷键", removeSlot: "移除快捷键" };
        const ItemData = { /* ... (same as previous, ensure all items have icon fields) ... */
            'hp_potion_small': { name: "小型生命药水", type: 'consumable', effect: { hp: 50 }, stackable: true, maxStack: 10, icon: 'consumable-hp', description: "恢复少量生命值。", rarity: 'common'},
            'mp_potion_small': { name: "小型魔力药水", type: 'consumable', effect: { mp: 30 }, stackable: true, maxStack: 10, icon: 'consumable-mp', description: "恢复少量魔力值。", rarity: 'common'},
            'rusty_sword': { name: "生锈的剑", type: 'equipment', slot: 'weapon', stats: { attack: 3 }, icon: 'equipment-weapon', description: "一把看起来快坏掉的剑。", rarity: 'common' },
            'short_bow': { name: "短弓", type: 'equipment', slot: 'weapon', stats: { attack: 4 }, icon: 'equipment-weapon', description: "适合新手使用的弓。", rarity: 'common' },
            'sharp_dagger': { name: "锋利的匕首", type: 'equipment', slot: 'weapon', stats: { attack: 5 }, icon: 'equipment-weapon', description: "轻巧但致命。", rarity: 'uncommon'},
            'glowing_staff': { name: "发光的法杖", type: 'equipment', slot: 'weapon', stats: { attack: 4, maxMP: 20}, icon: 'equipment-weapon', description: "顶端镶嵌着微光的宝石。", rarity: 'uncommon'},
            'leather_armor': { name: "皮甲", type: 'equipment', slot: 'armor', stats: { defense: 2 }, icon: 'equipment-armor', description: "基本的皮革护甲。", rarity: 'common' },
            'iron_helmet': { name: "铁盔", type: 'equipment', slot: 'helmet', stats: { defense: 3 }, icon: 'equipment-helmet', description: "提供头部基本保护。", rarity: 'common'},
            'hardened_leather_boots': { name: "硬皮靴", type: 'equipment', slot: 'boots', stats: { defense: 1, speed: 0.5 }, icon: 'equipment-boots', description: "比普通靴子更耐用。", rarity: 'uncommon'},
            'magic_ring': { name: "魔力戒指", type: 'equipment', slot: 'ring', stats: { maxMP: 15 }, icon: 'equipment-ring', description: "一个带有微弱魔力的戒指。", rarity: 'rare'},
            'goblin_ear': { name: "哥布林耳朵", type: 'material', stackable: true, maxStack: 50, icon: 'material', description: "哥布林的耳朵，或许能卖钱。", rarity: 'common' },
        };
        const MonsterData = { 'goblin': { name: "Goblin", hp: 25, mp: 0, attack: 5, defense: 1, xp: 10, speed: 2.5, attackType: 'melee', attackRange: TILE_SIZE * 0.8, aggroRange: TILE_SIZE * 6, color: 0x009600, size: TILE_SIZE * 0.6, icon: 'goblin', lootTable: [{ itemId: 'hp_potion_small', chance: 0.3 },{ itemId: 'goblin_ear', chance: 0.7 },{ itemId: 'rusty_sword', chance: 0.05 },{ itemId: 'sharp_dagger', chance: 0.02}] }, 'skeleton': { name: "Skeleton Archer", hp: 43, mp: 0, attack: 2, defense: 3, xp: 18, speed: 3.0, attackType: 'ranged', attackRange: TILE_SIZE * 7, projectileType: 'arrow', projectileSpeed: 15, projectileDamage: 6, aggroRange: TILE_SIZE * 9, color: 0xcccccc, size: TILE_SIZE * 0.7, icon: 'skeleton', lootTable: [{ itemId: 'hp_potion_small', chance: 0.2 },{ itemId: 'mp_potion_small', chance: 0.1 },{ itemId: 'leather_armor', chance: 0.08 },{ itemId: 'short_bow', chance: 0.04 }] }, 'bat': { name: "Giant Bat", hp: 20, mp: 0, attack: 4, defense: 0, xp: 8, speed: 4.5, attackType: 'melee', attackRange: TILE_SIZE * 0.6, aggroRange: TILE_SIZE * 8, color: 0x333333, size: TILE_SIZE * 0.5, icon: 'bat', lootTable: [{ itemId: 'hp_potion_small', chance: 0.15 },] } /* ... */ };
        const NpcData = { 'villager_elder': { name: "Elder", hp: 100, attack: 5, defense: 2, color: 0x4444ff, size: TILE_SIZE * 0.7, icon: 'elder', dialogue: ["May the light guide you.", "The world beyond is perilous.", "Seek the blacksmith or merchant if you need wares."], canFight: true, aggroRange: TILE_SIZE * 4, attackRange: TILE_SIZE * 1.0 }, 'villager_guard': { name: "Guard", hp: 150, attack: 15, defense: 5, color: 0x999999, size: TILE_SIZE * 0.8, icon: 'guard', dialogue: ["Halt! This is a safe village.", "I will protect this place.", "Report any suspicious activity."], canFight: true, aggroRange: TILE_SIZE * 7, attackRange: TILE_SIZE * 1.2, pursuitRangeMultiplier: 1.5 }, 'villager_farmer': { name: "Farmer", hp: 80, attack: 3, defense: 1, color: 0x8B4513, size: TILE_SIZE * 0.7, icon: 'farmer', dialogue: ["Hope for a good harvest...", "Bah, monsters are everywhere.", "Be careful out there, young one."], canFight: false } /* ... */ };
        const PlayerDefaults = { hp: 110, mp: 50, attack: 5, defense: 1, speed: 4.0, level: 1, xp: 0, xpToNextLevel: 100, attackRange: TILE_SIZE * 1.0, pickupRadius: TILE_SIZE * 1.5, inventorySize: 20, color: 0xffd700, size: TILE_SIZE * 0.7, hpRegenRate: 0.2, mpRegenRate: 0.5 }; // Added regen rates (per second)
        const MapSettings = { wildernessWidth: 80, wildernessHeight: 80, villageWidth: 20, villageHeight: 20, wallThickness: 1, noiseScale: 0.08, obstacleDensity: 0.1, maxMonsters: 30, monsterSpawnInterval: 4000, monsterSpawnCheckRadius: TILE_SIZE * 10, maxWildernessGuards: 3, eliteChance: 0.08 }; // Added elite chance
        const RarityColors = { common: '#FFFFFF', uncommon: '#00FF00', rare: '#0070FF', legendary: '#A335EE', default: '#FFFFFF' };
        const TILE_TYPE_FLOOR = 0; const TILE_TYPE_WALL = 1; const TILE_TYPE_EXIT = 2; const TILE_TYPE_WATER = 3; const TILE_TYPE_VILLAGE_ENTRANCE = 4;

        // --- Skill Data ---
        const SkillData = {
             'fireball': { name: "火球术", description: "发射一枚爆炸性的火球。", mpCost: 8, cooldown: 1.5, type: 'ranged_projectile', effect: { damage: 15, radius: TILE_SIZE * 0.8, damageType: 'fire' }, projectileType: 'fireball', projectileSpeed: 18, unlockLevel: 1, skillPointCost: 1, icon: 'skill-fire' },
             'ice_bolt': { name: "冰箭术", description: "发射一枚冰箭，可能减速敌人。", mpCost: 6, cooldown: 1.0, type: 'ranged_projectile', effect: { damage: 10, slowChance: 0.3, slowDuration: 2.0, damageType: 'cold' }, projectileType: 'ice_bolt', projectileSpeed: 22, unlockLevel: 1, skillPointCost: 1, icon: 'skill-ice' },
             'heal_self': { name: "治疗术", description: "恢复自身少量生命值。", mpCost: 15, cooldown: 8.0, type: 'buff_self', effect: { healAmount: 40 }, unlockLevel: 2, skillPointCost: 1, icon: 'skill-heal' },
             'bash': { name: "重击", description: "对近战目标造成额外伤害。", mpCost: 5, cooldown: 2.0, type: 'target_enemy', range: PlayerDefaults.attackRange * 1.2, effect: { damageMultiplier: 1.5, damageType: 'physical' }, unlockLevel: 3, skillPointCost: 1, icon: 'skill-bash' },
             'nova': { name: "新星", description: "释放一圈能量冲击波，伤害周围敌人。", mpCost: 20, cooldown: 6.0, type: 'point_blank_aoe', effect: { damage: 12, radius: TILE_SIZE * 2.5, damageType: 'lightning' }, unlockLevel: 5, skillPointCost: 2, icon: 'skill-nova' },
             'haste': { name: "急速", description: "短时间内提升移动和攻击速度。", mpCost: 12, cooldown: 15.0, type: 'buff_self', effect: { duration: 8.0, speedBonus: 1.5, attackSpeedMultiplier: 0.7 /* lower = faster */ }, unlockLevel: 4, skillPointCost: 2, icon: 'skill-haste' },
             'shield_bash': { name: "盾击", description: "需要盾牌。猛击目标，有几率击晕。", mpCost: 10, cooldown: 5.0, type: 'target_enemy', range: PlayerDefaults.attackRange * 1.1, effect: { damage: 8, stunChance: 0.25, stunDuration: 1.5, damageType: 'physical' }, requires: 'shield', unlockLevel: 6, skillPointCost: 2, icon: 'skill-shield' }, // Placeholder requires shield
             'meteor': { name: "陨石术", description: "召唤陨石轰击目标区域。", mpCost: 30, cooldown: 10.0, type: 'area_target', // Need ground target logic
                 effect: { damage: 40, radius: TILE_SIZE * 1.5, delay: 1.0, damageType: 'fire' }, unlockLevel: 8, skillPointCost: 3, icon: 'skill-meteor' },
             'summon_skeleton': { name: "召唤骷髅", description: "召唤一个骷髅战士协助战斗。", mpCost: 25, cooldown: 20.0, type: 'summon', effect: { summonId: 'skeleton_warrior', duration: 30.0 }, unlockLevel: 7, skillPointCost: 3, icon: 'skill-summon' }, // Needs summon logic
             'chain_lightning': { name: "连锁闪电", description: "释放闪电，弹跳至附近敌人。", mpCost: 18, cooldown: 4.0, type: 'chaining_projectile', // Complex
                 effect: { damage: 10, maxBounces: 3, bounceRange: TILE_SIZE * 3, damageType: 'lightning' }, projectileType: 'lightning', projectileSpeed: 25, unlockLevel: 9, skillPointCost: 3, icon: 'skill-chain' },
         };

         // --- Elite Affix Data ---
         const EliteAffixes = {
             'fast': { name: "<快速>", color: 0xffff00, statMods: { speed: 1.4 }, particleColor: 0xffff00 },
             'strong': { name: "<强壮>", color: 0xff8800, statMods: { attack: 1.5 }, particleColor: 0xff8800 },
             'tough': { name: "<强韧>", color: 0x00aaff, statMods: { maxHP: 1.8, defense: 1.3 }, particleColor: 0x00aaff },
             'vampiric': { name: "<吸血>", color: 0xff0000, onHitEffect: 'lifesteal', particleColor: 0xff0000 }, // Requires special logic
             'arcane': { name: "<秘法>", color: 0xff00ff, specialAttack: 'arcane_orb', particleColor: 0xff00ff }, // Requires special logic
             'molten': { name: "<熔火>", color: 0xff4500, trailEffect: 'fire', particleColor: 0xff4500 }, // Requires special logic
         };


        // --- Utility Functions ---
        console.log("载入: 工具函数");
        /* ... distSqXZ, randomFromArray, worldToScreen, getRarity... same ... */
        function distSqXZ(pos1, pos2) { if (!pos1 || !pos2) return Infinity; const dx = pos1.x - pos2.x; const dz = pos1.z - pos2.z; return dx * dx + dz * dz; }
        function randomFromArray(arr) { if (!arr || arr.length === 0) return null; return arr[Math.floor(Math.random() * arr.length)]; }
        function worldToScreen(vector3) { if (!camera || !renderer) return { x: -1000, y: -1000 }; const vector = vector3.clone(); vector.project(camera); const x = (vector.x * 0.5 + 0.5) * renderer.domElement.clientWidth; const y = (vector.y * -0.5 + 0.5) * renderer.domElement.clientHeight; return { x: x, y: y }; }
        function getRarityHexColor(rarity) { return RarityColors[rarity] || RarityColors.default; }
        function getRarityTHREEColor(rarity) { return new THREE.Color(getRarityHexColor(rarity)); }


        // --- Item Classes ---
        console.log("载入: 物品类");
        /* ... Item class same ... */
        /* ... DroppedItem class same ... */
        class Item { constructor(itemId, quantity = 1) { const data = ItemData[itemId]; if (!data) { console.error("无效物品ID:", itemId); this.id = 'invalid_item'; this.name = '错误物品'; this.type = 'error'; this.description = `无效ID: ${itemId}`; this.icon = 'error'; this.stackable = false; this.maxStack = 1; this.quantity = 0; this.rarity = 'common'; return; } this.id = itemId; this.name = data.name; this.type = data.type; this.description = data.description; this.icon = data.icon || 'default'; this.stackable = data.stackable || false; this.maxStack = data.maxStack || 1; this.quantity = this.stackable ? quantity : 1; this.rarity = data.rarity || 'common'; if (this.type === 'equipment') { this.slot = data.slot; this.stats = data.stats || {}; } else if (this.type === 'consumable') { this.effect = data.effect || {}; } } addQuantity(amount) { if (!this.stackable) return 0; this.quantity += amount; if (this.quantity > this.maxStack) { let overflow = this.quantity - this.maxStack; this.quantity = this.maxStack; return overflow; } return 0; } use(target) { if (this.type === 'consumable' && this.quantity > 0) { console.log(`${target.name} 使用 ${this.name}`); let effectApplied = false; for (const effectKey in this.effect) { const maxStatKey = `max${effectKey.toUpperCase()}`; if (target.stats.hasOwnProperty(effectKey) && target.currentStats.hasOwnProperty(maxStatKey)) { let effectAmount = this.effect[effectKey]; let currentVal = target.stats[effectKey]; let maxVal = target.currentStats[maxStatKey]; let newVal = Math.min(maxVal, currentVal + effectAmount); let actualEffect = newVal - currentVal; if(actualEffect > 0) { target.stats[effectKey] = newVal; if (uiManager) uiManager.addFloatingText(`+${actualEffect}`, target.pos, 'lime'); effectApplied = true; } } else { console.warn(`目标 ${target.name} 缺少属性 '${effectKey}' 或 '${maxStatKey}'`); } } if(effectApplied){ this.quantity--; playSound('useItem'); return this.quantity > 0; } } return this.quantity > 0; } }
        class DroppedItem { constructor(item, x, z) { if (!item || item.type === 'error') { console.error("尝试创建无效物品的掉落物:", item); this.invalid = true; this.item = null; this.pos = new THREE.Vector3(x, 0, z); this.mesh = null; return; } this.item = item; this.pos = new THREE.Vector3(x, HALF_TILE_SIZE * 0.5, z); this.pickupRadiusSq = (PlayerDefaults.pickupRadius ** 2) * 0.8; this.creationTime = gameTime; this.lifespan = 60; this.bobbingOffset = 0; this.bobbingSpeed = Math.random() * 0.05 + 0.05; this.rotationSpeed = Math.random() * 0.01 + 0.005; this.invalid = false; this.mesh = this.createMesh(); this.mesh.userData = { gameObject: this, type: 'DroppedItem' }; scene.add(this.mesh); intersectableUnits.push(this.mesh); } createMesh() { const geo = new THREE.BoxGeometry(TILE_SIZE * 0.2, TILE_SIZE * 0.2, TILE_SIZE * 0.2); const mat = new THREE.MeshStandardMaterial({ color: getRarityTHREEColor(this.item.rarity), emissive: getRarityTHREEColor(this.item.rarity), emissiveIntensity: this.item.rarity === 'common' ? 0 : 0.3, metalness: 0.2, roughness: 0.6 }); const mesh = new THREE.Mesh(geo, mat); mesh.position.copy(this.pos); mesh.castShadow = true; return mesh; } isExpired() { return this.invalid || (gameTime - this.creationTime > this.lifespan); } update() { if (this.invalid || !this.mesh) return; if (this.isExpired()) { this.dispose(); return; } this.bobbingOffset = Math.sin(gameTime * this.bobbingSpeed * 100) * (TILE_SIZE * 0.1); this.mesh.position.y = (HALF_TILE_SIZE * 0.5) + this.bobbingOffset; this.mesh.rotation.y += this.rotationSpeed; } dispose() { if (this.mesh) { scene.remove(this.mesh); this.mesh.geometry.dispose(); this.mesh.material.dispose(); const index = intersectableUnits.indexOf(this.mesh); if (index > -1) intersectableUnits.splice(index, 1); } this.mesh = null; this.invalid = true; } }


        // --- Projectile Class ---
        console.log("载入: 投射物类");
        class Projectile {
             constructor(startX, startY, startZ, targetX, targetY, targetZ, speed, damage, owner, type = 'arrow', effectData = {}) { // Added effectData
                 this.pos = new THREE.Vector3(startX, startY, startZ);
                 this.targetPos = new THREE.Vector3(targetX, targetY, targetZ);
                 this.vel = this.targetPos.clone().sub(this.pos);
                 // Handle potential zero vector if start/target are same
                 if (this.vel.lengthSq() < 0.001) { this.vel.set(speed, 0, 0); } // Default move right
                 else { this.vel.normalize().multiplyScalar(speed); }

                 this.damage = damage;
                 this.owner = owner;
                 this.type = type; // 'arrow', 'fireball', 'ice_bolt', 'lightning' etc.
                 this.effectData = effectData; // Store skill effect data (radius, duration, etc.)
                 this.size = TILE_SIZE * 0.3;
                 this.creationTime = gameTime;
                 this.lifespan = 5;
                 this.collided = false;
                 this.mesh = this.createMesh();
                 if(this.mesh){
                     this.mesh.userData = { gameObject: this, type: 'Projectile' };
                     scene.add(this.mesh);
                     this.mesh.lookAt(this.pos.clone().add(this.vel));
                 } else { this.collided = true; }
             }
             createMesh() {
                 let geo, mat;
                 let scale = 1.0;
                 switch(this.type) {
                      case 'arrow':
                           geo = new THREE.CylinderGeometry(TILE_SIZE*0.02, TILE_SIZE*0.02, this.size, 4);
                           mat = new THREE.MeshStandardMaterial({ color: 0x8B4513, roughness: 0.8 });
                           break;
                      case 'fireball':
                           geo = new THREE.SphereGeometry(this.size * 0.4, 10, 8);
                            mat = new THREE.MeshStandardMaterial({ color: 0xff4500, emissive: 0xdd2200, emissiveIntensity: 0.9, roughness: 0.6 });
                           break;
                      case 'ice_bolt':
                           geo = new THREE.ConeGeometry(this.size * 0.3, this.size * 1.2, 8);
                           mat = new THREE.MeshStandardMaterial({ color: 0x87cefa, emissive: 0x40a0ff, emissiveIntensity: 0.6, roughness: 0.4, transparent:true, opacity: 0.9 });
                           scale = 0.6; // Cones are tall
                           break;
                      case 'lightning': // Used for chain lightning maybe
                           geo = new THREE.SphereGeometry(this.size * 0.2, 6, 6);
                           mat = new THREE.MeshBasicMaterial({ color: 0xaaaaff, wireframe: true }); // Basic wireframe look
                           break;
                      default:
                           geo = new THREE.SphereGeometry(this.size * 0.3, 8, 8);
                           mat = new THREE.MeshStandardMaterial({ color: 0xff00ff, emissive: 0xff00ff, emissiveIntensity: 0.8, roughness: 0.5 });
                           break;
                 }
                 if(!geo || !mat) return null; // Failed geometry/material
                 const mesh = new THREE.Mesh(geo, mat);
                 mesh.scale.set(scale, scale, scale); // Apply scale if needed
                 mesh.position.copy(this.pos);
                 if(this.type === 'arrow' || this.type === 'ice_bolt') mesh.quaternion.setFromAxisAngle(new THREE.Vector3(1,0,0), Math.PI / 2); // Align pointy end
                 mesh.castShadow = false;
                 return mesh;
             }
             update(deltaTime, allUnits, map) { 
			 
			 /* ... (movement logic same) ... */
			 
			 
                 if (this.collided || (gameTime - this.creationTime > this.lifespan) || !this.mesh) {
                     if (!this.collided) this.dispose();
                     return false;
                 }
                 const moveDelta = this.vel.clone().multiplyScalar(deltaTime);
                 this.pos.add(moveDelta);
                 this.mesh.position.copy(this.pos);

                 // Map Collision
                 if (map.isObstacle(this.pos.x, this.pos.z) || map.isOutsideBounds(this.pos.x, this.pos.z)) {
                     this.handleCollision(null); return false;
                 }
                 // Unit Collision
                 const projectileRadiusSq = (this.size * 0.5)**2;
                 for (const unit of allUnits) {
                     if (!unit || unit === this.owner || !unit.mesh || unit.state === 'dead' || !unit.stats || unit.stats.hp <= 0) continue;
                     // ... (canHit logic same) ...
                     const ownerIsPlayer = this.owner instanceof Player; const ownerIsMonster = this.owner instanceof Monster; const ownerIsNpc = this.owner instanceof Npc; const unitIsPlayer = unit instanceof Player; const unitIsMonster = unit instanceof Monster; const unitIsNpc = unit instanceof Npc;
                     let canHit = false;
                     if (ownerIsPlayer && unitIsMonster) canHit = true;
                     if (ownerIsMonster && (unitIsPlayer || (unitIsNpc && unit.canFight))) canHit = true;
                     if (ownerIsNpc && unitIsMonster) canHit = true;
                     if (!canHit) continue;

                     const unitRadiusSq = (unit.size * 0.5)**2;
                     const collisionDistSq = projectileRadiusSq + unitRadiusSq;
                     if (distSqXZ(this.pos, unit.pos) < collisionDistSq) {
                         if (Math.abs(this.pos.y - unit.pos.y) < unit.size * 0.7) {
                             this.handleCollision(unit); return false;
                         }
                     }
                 }
                 return true;
            }
            handleCollision(target) {
                 this.collided = true;
                 // --- Handle Area Damage ---
                 if (this.effectData?.radius && this.effectData.radius > 0) {
                     const radiusSq = this.effectData.radius ** 2;
                     const allUnits = [player, ...monsters, ...npcs]; // Get all potential targets
                     for (const unit of allUnits) {
                         if (!unit || unit === this.owner || !unit.mesh || unit.state === 'dead') continue;
                         // Check type compatibility (player hits monster, monster hits player/npc, npc hits monster)
                         const ownerIsPlayer = this.owner instanceof Player; const ownerIsMonster = this.owner instanceof Monster; const ownerIsNpc = this.owner instanceof Npc; const unitIsPlayer = unit instanceof Player; const unitIsMonster = unit instanceof Monster; const unitIsNpc = unit instanceof Npc;
                         let canHit = false;
                         if (ownerIsPlayer && unitIsMonster) canHit = true;
                         if (ownerIsMonster && (unitIsPlayer || (unitIsNpc && unit.canFight))) canHit = true;
                         if (ownerIsNpc && unitIsMonster) canHit = true;
                         if (!canHit) continue;

                         if (distSqXZ(this.pos, unit.pos) < radiusSq) {
                             if (typeof unit.takeDamage === 'function') {
                                 unit.takeDamage(this.damage, this.owner); // Apply damage to units in radius
                             }
                             // Apply other effects from effectData (slow, etc.) here if needed
                         }
                     }
                     // Spawn visual effect for explosion
                      this.spawnImpactVisual(this.effectData.radius);
                 }
                 // --- Handle Direct Hit ---
                 else if (target && typeof target.takeDamage === 'function') {
                     target.takeDamage(this.damage, this.owner);
                     // Apply single target effects (slow, etc.)
                     if(this.effectData?.slowChance && Math.random() < this.effectData.slowChance && typeof target.applyStatus === 'function'){
                         target.applyStatus('slowed', this.effectData.slowDuration || 2.0);
                     }
                      this.spawnImpactVisual(this.size * 0.5); // Smaller visual for direct hit
                 } else {
                      // Hit environment
                      this.spawnImpactVisual(this.size * 0.3); // Small spark
                 }
                 this.dispose();
            }

             spawnImpactVisual(radius){
                 // Simple expanding sphere visual
                 const impactColor = this.type === 'fireball' ? 0xff8800 : this.type === 'ice_bolt' ? 0xaaaaff : 0xffffff;
                 const sphereGeo = new THREE.SphereGeometry(radius * 0.5, 16, 8);
                 const sphereMat = new THREE.MeshBasicMaterial({color: impactColor, transparent: true, opacity: 0.8});
                 const sphereMesh = new THREE.Mesh(sphereGeo, sphereMat);
                 sphereMesh.position.copy(this.pos);
                 scene.add(sphereMesh);

                 const duration = 300; // ms
                 const startTime = Date.now();
                 const animateImpact = () => {
                      const elapsed = Date.now() - startTime;
                      if(elapsed >= duration || !sphereMesh.parent) {
                           if(sphereMesh.parent) scene.remove(sphereMesh);
                           sphereGeo.dispose();
                           sphereMat.dispose();
                           return;
                      }
                      const progress = elapsed / duration;
                      sphereMesh.scale.setScalar(1.0 + progress * 1.5); // Expand
                      sphereMat.opacity = 0.8 * (1.0 - progress); // Fade out
                      requestAnimationFrame(animateImpact);
                 };
                 animateImpact();
             }

             dispose() {
                 if (this.mesh) {
                      scene.remove(this.mesh);
                      const index = intersectableUnits.indexOf(this.mesh);
                      if (index > -1) intersectableUnits.splice(index, 1);
                      this.mesh.geometry.dispose();
                      this.mesh.material.dispose();
                      this.mesh = null;
                 }
                  uiManager?.removeWorldHealthBar(this);
                 this.invalid = true;
             }
        }


        // --- Map Class ---
        console.log("载入: 地图类");
        /* ... GameMap class mostly same, check generateWildernessLayout for NPC spawns ... */
        class GameMap { constructor(widthTiles, heightTiles, isVillage = false) { this.width = widthTiles; this.height = heightTiles; this.isVillage = isVillage; this.grid = []; this.mapWidthUnits = this.width * TILE_SIZE; this.mapHeightUnits = this.height * TILE_SIZE; this.spawnPoints = []; this.npcSpawnPoints = []; this.exitPoint = null; this.entryPoint = null; this.materials = { [TILE_TYPE_FLOOR]: new THREE.MeshStandardMaterial({ color: this.isVillage ? 0xA08264 : 0x326432, roughness: 0.9, metalness: 0.1 }), [TILE_TYPE_WALL]: new THREE.MeshStandardMaterial({ color: this.isVillage ? 0x644628 : 0x5A5A5A, roughness: 0.8, metalness: 0.2 }), [TILE_TYPE_EXIT]: new THREE.MeshStandardMaterial({ color: 0xFFFF00, emissive: 0xAAAA00, roughness: 0.7 }), [TILE_TYPE_WATER]: new THREE.MeshStandardMaterial({ color: 0x285096, roughness: 0.3, metalness: 0.1, transparent: true, opacity: 0.7 }), [TILE_TYPE_VILLAGE_ENTRANCE]: new THREE.MeshStandardMaterial({ color: 0x00FFFF, emissive: 0x00AAAA, roughness: 0.7 }), default: new THREE.MeshStandardMaterial({ color: 0xff00ff }) }; this.tileGeometry = new THREE.BoxGeometry(TILE_SIZE, TILE_SIZE, TILE_SIZE); this.tileInstances = {}; this.maxInstances = this.width * this.height; this.noiseSeed = Math.random() * 10000; this.noiseDetail = { octaves: 5, falloff: 0.55 }; console.log(`生成地图 (${this.isVillage ? '村庄' : '野外'})...`); this.generateMapGrid(); console.log(`生成地图网格模型...`); this.createMapMesh(); console.log("地图生成完毕."); } simpleNoise(x, y) { const scale1 = 0.1; const scale2 = 0.3; const scale3 = 0.7; const amp1 = 0.5; const amp2 = 0.3; const amp3 = 0.2; const seededRandom = (seed) => { let x = Math.sin(seed) * 10000; return x - Math.floor(x); }; let n1 = seededRandom(this.noiseSeed + x * scale1 + y * scale1 * 5.1); let n2 = seededRandom(this.noiseSeed * 1.3 + x * scale2 + y * scale2 * 4.9); let n3 = seededRandom(this.noiseSeed * 0.8 + x * scale3 + y * scale3 * 5.3); return (n1 * amp1 + n2 * amp2 + n3 * amp3); } generateMapGrid() { for (let y = 0; y < this.height; y++) { this.grid[y] = new Array(this.width); } if (this.isVillage) { this.generateVillageLayout(); } else { this.generateWildernessLayout(); } if (this.exitPoint && !(this.exitPoint instanceof THREE.Vector3)) { this.exitPoint = new THREE.Vector3(this.exitPoint.x, 0, this.exitPoint.y); } if (this.entryPoint && !(this.entryPoint instanceof THREE.Vector3)) { this.entryPoint = new THREE.Vector3(this.entryPoint.x, 0, this.entryPoint.y); } this.spawnPoints = this.spawnPoints.map(p => p instanceof THREE.Vector3 ? p : new THREE.Vector3(p.x, 0, p.y)); this.npcSpawnPoints = this.npcSpawnPoints.map(p => p instanceof THREE.Vector3 ? p : new THREE.Vector3(p.x, 0, p.y)); } generateVillageLayout() { let drunkX = Math.floor(this.width / 2); let drunkY = Math.floor(this.height / 2); let steps = Math.floor(this.width * this.height * 0.6); let floorTile = TILE_TYPE_FLOOR; let wallTile = TILE_TYPE_WALL; let exitTile = TILE_TYPE_EXIT; for(let y=0; y<this.height; ++y){ for(let x=0; x<this.width; ++x){ this.grid[y][x] = wallTile; } } this.grid[drunkY][drunkX] = floorTile; let wallThickness = MapSettings.wallThickness; for (let i = 0; i < steps; i++) { let dir = Math.floor(Math.random() * 4); let nx = drunkX, ny = drunkY; switch (dir) { case 0: ny = Math.max(wallThickness, drunkY - 1); break; case 1: nx = Math.min(this.width - 1 - wallThickness, drunkX + 1); break; case 2: ny = Math.min(this.height - 1 - wallThickness, drunkY + 1); break; case 3: nx = Math.max(wallThickness, drunkX - 1); break; } if (nx >= wallThickness && nx < this.width - wallThickness && ny >= wallThickness && ny < this.height - wallThickness) { drunkX = nx; drunkY = ny; this.grid[drunkY][drunkX] = floorTile; if (Math.random() < 0.4) { let dx = Math.floor(Math.random()*3) - 1; let dy = Math.floor(Math.random()*3) - 1; if(Math.abs(dx)+Math.abs(dy) === 1){ let wx = drunkX+dx; let wy = drunkY+dy; if (wx >= wallThickness && wx < this.width - wallThickness && wy >= wallThickness && wy < this.height - wallThickness) { this.grid[wy][wx] = floorTile; } } } } else { drunkX = Math.floor(Math.random() * (this.width * 0.2) + this.width * 0.4); drunkY = Math.floor(Math.random() * (this.height * 0.2) + this.height * 0.4); if(this.grid[drunkY]) this.grid[drunkY][drunkX] = floorTile; } } const exitSide = Math.floor(Math.random() * 4); let exitX = Math.floor(this.width / 2); let exitY = Math.floor(this.height / 2); const exitWidth = 2; let pathX = exitX; let pathY = exitY; if (exitSide === 0) { exitY = wallThickness - 1; while(pathY >= exitY) { if(this.grid[pathY]) this.grid[pathY][pathX] = floorTile; if(this.grid[pathY] && pathX+1 < this.width) this.grid[pathY][pathX+1] = floorTile; pathY--; } for(let i = 0; i < exitWidth; i++) if(this.grid[exitY] && pathX+i < this.width) this.grid[exitY][pathX+i] = exitTile; this.exitPoint = new THREE.Vector3((pathX + exitWidth/2 - this.width/2) * TILE_SIZE, 0, (exitY - 0.5 - this.height/2) * TILE_SIZE); this.entryPoint = new THREE.Vector3((pathX + exitWidth/2 - this.width/2) * TILE_SIZE, 0, (exitY + 1.5 - this.height/2) * TILE_SIZE); } else if (exitSide === 1) { exitX = this.width - wallThickness; while(pathX <= exitX) { if(this.grid[pathY]) this.grid[pathY][pathX] = floorTile; if(pathY+1 < this.height && this.grid[pathY+1]) this.grid[pathY+1][pathX] = floorTile; pathX++; } for(let i = 0; i < exitWidth; i++) if(pathY+i < this.height && this.grid[pathY+i]) this.grid[pathY+i][exitX] = exitTile; this.exitPoint = new THREE.Vector3((exitX + 0.5 - this.width/2) * TILE_SIZE, 0, (pathY + exitWidth/2 - this.height/2) * TILE_SIZE); this.entryPoint = new THREE.Vector3((exitX - 1.5 - this.width/2) * TILE_SIZE, 0, (pathY + exitWidth/2 - this.height/2) * TILE_SIZE); } else if (exitSide === 2) { exitY = this.height - wallThickness; while(pathY <= exitY) { if(this.grid[pathY]) this.grid[pathY][pathX] = floorTile; if(this.grid[pathY] && pathX+1 < this.width) this.grid[pathY][pathX+1] = floorTile; pathY++; } for(let i = 0; i < exitWidth; i++) if(this.grid[exitY] && pathX+i < this.width) this.grid[exitY][pathX+i] = exitTile; this.exitPoint = new THREE.Vector3((pathX + exitWidth/2 - this.width/2) * TILE_SIZE, 0, (exitY + 0.5 - this.height/2) * TILE_SIZE); this.entryPoint = new THREE.Vector3((pathX + exitWidth/2 - this.width/2) * TILE_SIZE, 0, (exitY - 1.5 - this.height/2) * TILE_SIZE); } else { exitX = wallThickness - 1; while(pathX >= exitX) { if(this.grid[pathY]) this.grid[pathY][pathX] = floorTile; if(pathY+1 < this.height && this.grid[pathY+1]) this.grid[pathY+1][pathX] = floorTile; pathX--; } for(let i = 0; i < exitWidth; i++) if(pathY+i < this.height && this.grid[pathY+i]) this.grid[pathY+i][exitX] = exitTile; this.exitPoint = new THREE.Vector3((exitX - 0.5 - this.width/2) * TILE_SIZE, 0, (pathY + exitWidth/2 - this.height/2) * TILE_SIZE); this.entryPoint = new THREE.Vector3((exitX + 1.5 - this.width/2) * TILE_SIZE, 0, (pathY + exitWidth/2 - this.height/2) * TILE_SIZE); } this.exitPoint = this.exitPoint || new THREE.Vector3(0,0,0); this.entryPoint = this.entryPoint || new THREE.Vector3(0,0, TILE_SIZE * 2); for (let i = 0; i < 7; i++) { let houseX = Math.floor(Math.random() * (this.width - 2*wallThickness - 2) + wallThickness + 1); let houseY = Math.floor(Math.random() * (this.height - 2*wallThickness - 2) + wallThickness + 1); if (this.grid[houseY]?.[houseX] === floorTile && distSqXZ(this.getTileCenter(houseX, houseY), this.entryPoint) > (TILE_SIZE * 4)**2) { this.grid[houseY][houseX] = wallTile; if(this.grid[houseY+1]?.[houseX] === floorTile && Math.random()<0.7) this.grid[houseY+1][houseX] = wallTile; if(this.grid[houseY]?.[houseX+1] === floorTile && Math.random()<0.7) this.grid[houseY][houseX+1] = wallTile; } } this.npcSpawnPoints = []; let attempts = 50; while (this.npcSpawnPoints.length < 6 && attempts > 0) { let sx = Math.floor(Math.random() * (this.width - 2*wallThickness) + wallThickness); let sy = Math.floor(Math.random() * (this.height - 2*wallThickness) + wallThickness); if (this.grid[sy]?.[sx] === floorTile && distSqXZ(this.getTileCenter(sx, sy), this.entryPoint) > (TILE_SIZE*3)**2) { this.npcSpawnPoints.push(this.getTileCenter(sx, sy)); } attempts--; } if (this.entryPoint) { this.npcSpawnPoints.push(this.entryPoint.clone().add(new THREE.Vector3(TILE_SIZE, 0, 0))); } else { this.npcSpawnPoints.push(this.getTileCenter(Math.floor(this.width/2)+1, Math.floor(this.height/2))); } } generateWildernessLayout() { const waterLevel = 0.38; const mountainLevel = 0.68; const floorTile = TILE_TYPE_FLOOR; const wallTile = TILE_TYPE_WALL; const waterTile = TILE_TYPE_WATER; const entranceTile = TILE_TYPE_VILLAGE_ENTRANCE; for (let y = 0; y < this.height; y++) { for (let x = 0; x < this.width; x++) { let n = this.simpleNoise(x * MapSettings.noiseScale, y * MapSettings.noiseScale); let n2 = this.simpleNoise(x * MapSettings.noiseScale * 2 + 100, y * MapSettings.noiseScale * 2 + 100); let finalN = (n * 0.7 + n2 * 0.3); if (finalN < waterLevel) this.grid[y][x] = waterTile; else if (finalN > mountainLevel || x < 1 || x >= this.width - 1 || y < 1 || y >= this.height - 1) this.grid[y][x] = wallTile; else this.grid[y][x] = floorTile; } } let drunkX = Math.floor(this.width / 2); let drunkY = Math.floor(this.height / 2); let steps = Math.floor(this.width * this.height * 0.4); if (this.grid[drunkY]) this.grid[drunkY][drunkX] = floorTile; for (let i = 0; i < steps; i++) { let dir = Math.floor(Math.random()*4); let nx = drunkX, ny = drunkY; switch(dir){ case 0: ny = Math.max(1, drunkY-1); break; case 1: nx = Math.min(this.width-2, drunkX+1); break; case 2: ny = Math.min(this.height-2, drunkY+1); break; case 3: nx = Math.max(1, drunkX-1); break; } drunkX=nx; drunkY=ny; if(this.grid[drunkY]?.[drunkX] !== undefined){ this.grid[drunkY][drunkX] = floorTile; if (Math.random() < 0.5) { let dx = Math.floor(Math.random()*3) - 1; let dy = Math.floor(Math.random()*3) - 1; if(Math.abs(dx)+Math.abs(dy) === 1){ let wx = drunkX+dx; let wy = drunkY+dy; if(wx > 0 && wx < this.width-1 && wy > 0 && wy < this.height-1 && this.grid[wy]?.[wx] !== waterTile) { this.grid[wy][wx] = floorTile; } } } } else { drunkX = Math.floor(Math.random() * (this.width * 0.2) + this.width * 0.4); drunkY = Math.floor(Math.random() * (this.height * 0.2) + this.height * 0.4); if(this.grid[drunkY]) this.grid[drunkY][drunkX] = floorTile; } } let entryX = Math.floor(this.width / 2); let entryY = this.height - 2; let attempts = 20; while (attempts > 0 && (this.grid[entryY]?.[entryX] !== floorTile)) { entryY--; if (entryY <= 1) { entryY = Math.floor(this.height/2); break; } attempts--; } if(this.grid[entryY]?.[entryX] !== floorTile) { entryY = Math.floor(this.height/2); entryX = Math.floor(this.width/2); if(this.grid[entryY]) this.grid[entryY][entryX] = floorTile; } if(this.grid[entryY]?.[entryX-1] !== undefined) this.grid[entryY][entryX-1] = entranceTile; this.entryPoint = this.getTileCenter(entryX, entryY); this.exitPoint = this.entryPoint; for(let dy = -1; dy <= 1; dy++){ for(let dx = -1; dx <= 1; dx++){ let checkY = entryY + dy; let checkX = entryX + dx; if(this.grid[checkY]?.[checkX] === wallTile) this.grid[checkY][checkX] = floorTile; } } this.spawnPoints = []; let monsterSpawnAttempts = MapSettings.maxMonsters * 5; const entryCheckPos = this.entryPoint; const minSpawnDistSq = (MapSettings.monsterSpawnCheckRadius ** 2) * 0.8; while (this.spawnPoints.length < MapSettings.maxMonsters * 1.5 && monsterSpawnAttempts > 0) { let sx = Math.floor(Math.random() * (this.width - 2) + 1); let sy = Math.floor(Math.random() * (this.height - 2) + 1); if (this.grid[sy]?.[sx] === floorTile) { const spawnPos = this.getTileCenter(sx, sy); if (distSqXZ(spawnPos, entryCheckPos) > minSpawnDistSq) { this.spawnPoints.push(spawnPos); } } monsterSpawnAttempts--; } this.npcSpawnPoints = []; let guardSpawnAttempts = MapSettings.maxWildernessGuards * 3; while (this.npcSpawnPoints.length < MapSettings.maxWildernessGuards && guardSpawnAttempts > 0) { let sx = Math.floor(Math.random() * (this.width - 2) + 1); let sy = Math.floor(Math.random() * (this.height - 2) + 1); if (this.grid[sy]?.[sx] === floorTile) { const spawnPos = this.getTileCenter(sx, sy); const tooCloseToOtherNPC = this.npcSpawnPoints.some(p => distSqXZ(p, spawnPos) < (TILE_SIZE * 5)**2); if (distSqXZ(spawnPos, entryCheckPos) > (TILE_SIZE * 8)**2 && !tooCloseToOtherNPC) { this.npcSpawnPoints.push(spawnPos); } } guardSpawnAttempts--; } console.log(`野外地图设置了 ${this.npcSpawnPoints.length} 个NPC出生点`); } getTileCenter(gridX, gridY) { const worldX = (gridX - this.width / 2 + 0.5) * TILE_SIZE; const worldZ = (gridY - this.height / 2 + 0.5) * TILE_SIZE; return new THREE.Vector3(worldX, 0, worldZ); } getWorldCoordFromGrid(gridX, gridY) { const worldX = (gridX - this.width / 2) * TILE_SIZE; const worldZ = (gridY - this.height / 2) * TILE_SIZE; return { x: worldX, z: worldZ }; } getGridCoordFromWorld(worldX, worldZ) { const gridX = Math.floor(worldX / TILE_SIZE + this.width / 2); const gridY = Math.floor(worldZ / TILE_SIZE + this.height / 2); return { x: gridX, y: gridY }; } getTileType(worldX, worldZ) { const { x: gridX, y: gridY } = this.getGridCoordFromWorld(worldX, worldZ); if (gridY >= 0 && gridY < this.height && gridX >= 0 && gridX < this.width) { return this.grid[gridY]?.[gridX]; } return undefined; } isObstacle(worldX, worldZ) { const type = this.getTileType(worldX, worldZ); return type === TILE_TYPE_WALL || type === TILE_TYPE_WATER; } isOutsideBounds(worldX, worldZ) { const halfWidth = this.mapWidthUnits / 2; const halfHeight = this.mapHeightUnits / 2; return worldX < -halfWidth || worldX >= halfWidth || worldZ < -halfHeight || worldZ >= halfHeight; } isOnExit(worldX, worldZ) { if (!this.exitPoint) return false; const type = this.getTileType(worldX, worldZ); if (type === TILE_TYPE_EXIT) return true; const exitRadiusSq = (TILE_SIZE * 1.0)**2; return distSqXZ(new THREE.Vector3(worldX, 0, worldZ), this.exitPoint) < exitRadiusSq; } isOnVillageEntrance(worldX, worldZ) { if (this.isVillage) return false; const type = this.getTileType(worldX, worldZ); return type === TILE_TYPE_VILLAGE_ENTRANCE; } getRandomSpawnPoint(referencePos = null, minDistanceSq = 0) { if (!this.spawnPoints || this.spawnPoints.length === 0) return null; let validPoints = this.spawnPoints; if (referencePos && minDistanceSq > 0) { validPoints = this.spawnPoints.filter(pt => pt && distSqXZ(pt, referencePos) > minDistanceSq); } if (validPoints.length === 0) validPoints = this.spawnPoints; return randomFromArray(validPoints.filter(pt => pt))?.clone(); } getRandomNpcSpawnPoint() { if (!this.npcSpawnPoints || this.npcSpawnPoints.length === 0) return this.getRandomSpawnPoint(); return randomFromArray(this.npcSpawnPoints.filter(pt => pt))?.clone(); } createMapMesh() { if (mapMeshGroup) scene.remove(mapMeshGroup); mapMeshGroup = new THREE.Group(); mapObstacleMeshes.length = 0; const dummy = new THREE.Object3D(); for (const type in this.materials) { if (this.materials.hasOwnProperty(type)) { this.tileInstances[type] = new THREE.InstancedMesh( this.tileGeometry, this.materials[type], this.maxInstances ); this.tileInstances[type].count = 0; this.tileInstances[type].castShadow = true; this.tileInstances[type].receiveShadow = true; mapMeshGroup.add(this.tileInstances[type]); } } for (let y = 0; y < this.height; y++) { for (let x = 0; x < this.width; x++) { const tileType = this.grid[y][x]; if (tileType === undefined || tileType === null) continue; const instancedMesh = this.tileInstances[tileType] || this.tileInstances.default; if (!instancedMesh) continue; const instanceIndex = instancedMesh.count; const tilePos = this.getTileCenter(x, y); let tileY = -HALF_TILE_SIZE; if(tileType === TILE_TYPE_WALL) tileY = HALF_TILE_SIZE; else if (tileType === TILE_TYPE_WATER) tileY = -HALF_TILE_SIZE * 1.2; dummy.position.set(tilePos.x, tileY, tilePos.z); dummy.updateMatrix(); instancedMesh.setMatrixAt(instanceIndex, dummy.matrix); instancedMesh.count++; if (tileType === TILE_TYPE_WALL || tileType === TILE_TYPE_WATER) { mapObstacleMeshes.push({ x: tilePos.x, z: tilePos.z, type: tileType}); } } } for (const type in this.tileInstances) { if (this.tileInstances[type]) { this.tileInstances[type].instanceMatrix.needsUpdate = true; } } scene.add(mapMeshGroup); } dispose() { if (mapMeshGroup) scene.remove(mapMeshGroup); for (const type in this.tileInstances) { if (this.tileInstances[type]) { this.tileInstances[type].dispose(); } } this.tileGeometry.dispose(); for (const type in this.materials) { if (this.materials[type]) { this.materials[type].dispose(); } } mapObstacleMeshes.length = 0; console.log("地图资源已释放."); } }


        // --- Player Class ---
        console.log("载入: 玩家类");
        class Player {
            constructor(x, z) {
                this.pos = new THREE.Vector3(x, PlayerDefaults.size * 0.5, z);
                this.targetPos = this.pos.clone();
                this.size = PlayerDefaults.size;
                this.color = new THREE.Color(PlayerDefaults.color);
                this.name = "玩家";
                this.mesh = this.createMesh();
                this.mesh.userData = { gameObject: this, type: 'Player' };
                scene.add(this.mesh);
                this.baseStats = JSON.parse(JSON.stringify({ maxHP: PlayerDefaults.hp, maxMP: PlayerDefaults.mp, attack: PlayerDefaults.attack, defense: PlayerDefaults.defense, speed: PlayerDefaults.speed, attackRange: PlayerDefaults.attackRange, pickupRadius: PlayerDefaults.pickupRadius, xpToNextLevel: PlayerDefaults.xpToNextLevel, hpRegenRate: PlayerDefaults.hpRegenRate, mpRegenRate: PlayerDefaults.mpRegenRate }));
                this.currentStats = { ...this.baseStats };
                this.stats = { hp: PlayerDefaults.hp, mp: PlayerDefaults.mp, level: PlayerDefaults.level, xp: PlayerDefaults.xp, };
                this.inventory = new Array(PlayerDefaults.inventorySize).fill(null);
                this.equipment = { weapon: null, helmet: null, armor: null, boots: null, amulet: null, ring1: null, ring2: null };
                this.targetEnemy = null;
                this.targetMovePos = null;
                this.isMoving = false;
                this.lastAttackTime = -Infinity;
                this.attackCooldown = 0.8;
                this.pickupRadiusSq = PlayerDefaults.pickupRadius ** 2;
                this.healthBarElement = null;
                this.worldPos2D = { x: -1000, y: -1000};
                // --- Skill related properties ---
                this.skillPointsAvailable = 0;
                this.skillsLearned = new Set(); // Store learned skill IDs
                this.skillSlots = [null, null, null, null]; // 4 skill slots mapped to keys 1-4
                this.skillCooldowns = {}; // { skillId: endTime }
                 this.activeBuffs = {}; // { buffId: { endTime, statMods } }

                this.updateCombinedStats();
            }
            createMesh() { const radius = this.size * 0.4; const height = this.size * 0.8; const geo = new THREE.CapsuleGeometry(radius, height, 4, 12); const mat = new THREE.MeshStandardMaterial({ color: this.color, roughness: 0.6, metalness: 0.3 }); const mesh = new THREE.Mesh(geo, mat); mesh.position.copy(this.pos); mesh.castShadow = true; mesh.receiveShadow = false; return mesh; }
            moveTo(targetVector3) { this.targetMovePos = targetVector3.clone(); this.targetMovePos.y = this.pos.y; this.targetEnemy = null; this.isMoving = true; }
            setAttackTarget(enemy) { if (enemy?.mesh && enemy.stats.hp > 0) { this.targetEnemy = enemy; this.targetMovePos = null; this.isMoving = true; playSound('targetEnemy'); } else { this.targetEnemy = null; } }
            attack(target) { if (!target || !target.stats || target.stats.hp <= 0) { this.targetEnemy = null; return; } const now = gameTime; if (now - this.lastAttackTime >= this.attackCooldown) { console.log(`${this.name} 攻击 ${target.name}`); const targetDefense = target.currentStats?.defense ?? 0; let damage = Math.max(1, this.currentStats.attack - targetDefense); damage = Math.floor(damage * (Math.random() * 0.3 + 0.85)); playSound('playerAttack'); if (typeof target.takeDamage === 'function') { target.takeDamage(damage, this); } else { console.error("目标没有takeDamage方法:", target); } this.lastAttackTime = now; this.playAttackAnimation(target); if (target.stats.hp <= 0) this.targetEnemy = null; } }
            playAttackAnimation(target){ if (target?.mesh) { const lineMat = new THREE.LineBasicMaterial({color: 0xffdd00, transparent: true, opacity: 0.8}); const points = [this.pos.clone().add(new THREE.Vector3(0,this.size*0.1,0)), target.pos.clone().add(new THREE.Vector3(0,target.size*0.1,0)) ]; const lineGeo = new THREE.BufferGeometry().setFromPoints(points); const line = new THREE.Line(lineGeo, lineMat); scene.add(line); setTimeout(() => { scene.remove(line); lineMat.dispose(); lineGeo.dispose(); }, 150); } }
            takeDamage(damage, attacker) { if (!this.stats || this.stats.hp <= 0) return; this.stats.hp -= damage; this.stats.hp = Math.max(0, this.stats.hp); // Prevent negative HP
                 if (uiManager) uiManager.addFloatingText(`-${damage}`, this.pos, 'red'); playSound('playerHit'); if (this.stats.hp <= 0) { this.die(attacker); } else { if (this.mesh) { const originalColor = this.mesh.material.color.getHex(); this.mesh.material.color.setHex(0xff0000); this.mesh.material.emissive.setHex(0xff0000); this.mesh.material.emissiveIntensity = 0.8; setTimeout(() => { if (this.mesh) { this.mesh.material.color.setHex(originalColor); this.mesh.material.emissive.setHex(0x000000); this.mesh.material.emissiveIntensity = 0; } }, 150); } } uiManager?.updateHUD(); }
            die(killer) { if (gameState === 'gameOver') return; const killerName = killer?.name ?? '未知原因'; console.log(`${this.name} 被 ${killerName} 杀死了!`); playSound('playerDeath'); gameState = 'gameOver'; uiManager?.showGameOverScreen(); if(this.mesh) { /* Maybe add death anim later */ } }
            gainXP(amount) { if (!this.stats || this.stats.hp <= 0 || amount <= 0) return; this.stats.xp += amount; if (uiManager) uiManager.addMessage(`+${amount} ${UIText.xp || 'XP'}`, 'yellow', 2000); while (this.stats.xp >= this.currentStats.xpToNextLevel) { let required = this.currentStats.xpToNextLevel; this.stats.xp -= required; this.levelUp(); } uiManager?.updateHUD(); }
            levelUp() { if (!this.stats || !this.baseStats) return; this.stats.level++; this.stats.skillPointsAvailable++; // AWARD SKILL POINT
                this.baseStats.xpToNextLevel = Math.floor(this.baseStats.xpToNextLevel * 1.6 + 50 + this.stats.level * 10); const hpGain = 10 + Math.floor(this.stats.level / 2); const mpGain = 5 + Math.floor(this.stats.level / 3); const attackGain = 1 + Math.floor(Math.random() * 2); const defenseGain = 1; this.baseStats.maxHP += hpGain; this.baseStats.maxMP += mpGain; this.baseStats.attack += attackGain; this.baseStats.defense += defenseGain; this.stats.hp = this.baseStats.maxHP; this.stats.mp = this.baseStats.maxMP; this.updateCombinedStats(); console.log(`升级! 达到等级 ${this.stats.level}! 获得1技能点 (总 ${this.skillPointsAvailable})`); if (uiManager) uiManager.addMessage(`${UIText.levelUp}! (${this.stats.level})`, 'lime', 3500); playSound('levelUp'); // ... (visual effect same) ...
                uiManager?.updateHUD(); uiManager?.updateSkillPanel(); // Update skill panel with new points
            }
            findEmptyInventorySlot() { if (!this.inventory) return -1; return this.inventory.findIndex(slot => slot === null); }
            pickupItem(droppedItem) { if (!droppedItem || !droppedItem.item || droppedItem.invalid || !this.inventory) return false; const item = droppedItem.item; let pickedUp = false; let remainingQuantity = item.quantity; if (item.stackable) { for (let i = 0; i < this.inventory.length; i++) { if (this.inventory[i] && this.inventory[i].id === item.id && this.inventory[i].quantity < this.inventory[i].maxStack) { let overflow = this.inventory[i].addQuantity(item.quantity); if (overflow === 0) { pickedUp = true; break; } else { item.quantity = overflow; } } } } if (!pickedUp) { const emptySlotIndex = this.findEmptyInventorySlot(); if (emptySlotIndex !== -1) { this.inventory[emptySlotIndex] = item; pickedUp = true; } } if (pickedUp) { const qtySuffix = item.stackable && remainingQuantity > 1 ? ` x${remainingQuantity}` : ''; if (uiManager) uiManager.addMessage(`${UIText.pickup}: ${item.name}${qtySuffix}`, getRarityHexColor(item.rarity), 2000); playSound('pickupItem'); uiManager?.updateInventory(); return true; } else { if (uiManager) uiManager.addMessage(UIText.inventoryFull, 'orange'); playSound('invalidAction'); return false; } }
            useItem(inventoryIndex) { if (!this.inventory || inventoryIndex < 0 || inventoryIndex >= this.inventory.length) return; const item = this.inventory[inventoryIndex]; if (item && item.type === 'consumable') { const itemStillExists = item.use(this); if (!itemStillExists) { this.inventory[inventoryIndex] = null; } uiManager?.updateInventory(); uiManager?.updateHUD(); } else { playSound('invalidAction'); } }
            equipItem(inventoryIndex) { if (!this.inventory || !this.equipment || inventoryIndex < 0 || inventoryIndex >= this.inventory.length) return; const item = this.inventory[inventoryIndex]; if (!item || item.type !== 'equipment') { playSound('invalidAction'); return; } let targetSlot = item.slot; if (targetSlot === 'ring') { if (!this.equipment['ring1']) targetSlot = 'ring1'; else if (!this.equipment['ring2']) targetSlot = 'ring2'; else targetSlot = 'ring1'; } if (!this.equipment.hasOwnProperty(targetSlot)) { playSound('invalidAction'); return; } let previouslyEquipped = this.equipment[targetSlot]; this.equipment[targetSlot] = item; this.inventory[inventoryIndex] = previouslyEquipped; console.log(`装备了 ${item.name} 到 ${targetSlot}`); playSound('equipItem'); this.updateCombinedStats(); uiManager?.updateInventory(); uiManager?.updateEquipment(); }
            unequipItem(slot) { if (!this.equipment || !this.equipment[slot]) return; const itemToUnequip = this.equipment[slot]; const emptySlotIndex = this.findEmptyInventorySlot(); if (emptySlotIndex !== -1) { this.inventory[emptySlotIndex] = itemToUnequip; this.equipment[slot] = null; console.log(`卸下了 ${itemToUnequip.name} 到背包 ${emptySlotIndex}`); playSound('equipItem'); this.updateCombinedStats(); uiManager?.updateInventory(); uiManager?.updateEquipment(); } else { if (uiManager) uiManager.addMessage(`${UIText.inventoryFull}, 无法卸下 ${itemToUnequip.name}`, 'orange'); playSound('invalidAction'); } }
            updateCombinedStats() { if (!this.baseStats || !this.currentStats || !this.equipment || !this.stats) return; this.currentStats = { ...this.baseStats }; for (const slot in this.equipment) { const item = this.equipment[slot]; if (item?.stats) { for (const stat in item.stats) { const value = item.stats[stat]; if (value === undefined || value === null) continue; if (this.currentStats.hasOwnProperty(stat)) { this.currentStats[stat] += value; } else { console.warn(`物品 ${item.name} 有未处理属性: ${stat}`); } } } }
                // Apply buffs
                const now = gameTime;
                for(const buffId in this.activeBuffs){
                     const buff = this.activeBuffs[buffId];
                     if(now < buff.endTime){
                          for(const stat in buff.statMods){
                               if(this.currentStats.hasOwnProperty(stat)){
                                    if(stat === 'attackCooldown'){ // Multiplicative speed changes attack cooldown
                                         this.currentStats.attackCooldown = (this.currentStats.attackCooldown || this.attackCooldown) * buff.statMods[stat];
                                    } else { // Additive for others
                                        this.currentStats[stat] += buff.statMods[stat];
                                    }
                               }
                          }
                     } else {
                          delete this.activeBuffs[buffId]; // Remove expired buff
                          console.log("Buff expired:", buffId);
                     }
                }

                this.currentStats.attackRange = this.currentStats.attackRange ?? PlayerDefaults.attackRange; this.currentStats.pickupRadius = this.currentStats.pickupRadius ?? PlayerDefaults.pickupRadius; this.pickupRadiusSq = this.currentStats.pickupRadius ** 2; this.stats.hp = Math.min(this.stats.hp ?? this.currentStats.maxHP, this.currentStats.maxHP); this.stats.mp = Math.min(this.stats.mp ?? this.currentStats.maxMP, this.currentStats.maxMP); this.currentStats.speed = Math.max(0.5, this.currentStats.speed ?? PlayerDefaults.speed); uiManager?.updateHUD(); }

             learnSkill(skillId){
                  const skill = SkillData[skillId];
                  if(!skill) return false;
                  if(this.stats.level >= skill.unlockLevel && this.skillPointsAvailable >= skill.skillPointCost && !this.skillsLearned.has(skillId)){
                       this.skillPointsAvailable -= skill.skillPointCost;
                       this.skillsLearned.add(skillId);
                       console.log(`学会技能: ${skill.name}`);
                       uiManager?.updateSkillPanel(); // Refresh UI
                       playSound('levelUp', 0.2); // Reuse level up sound for learning
                       return true;
                  }
                  playSound('invalidAction');
                  return false;
             }
             assignSkillToSlot(skillId, slotIndex){
                  if(slotIndex < 0 || slotIndex >= this.skillSlots.length) return false;
                  if(this.skillsLearned.has(skillId)){
                       // Check if skill is already assigned elsewhere, remove it
                       const currentAssignment = this.skillSlots.indexOf(skillId);
                       if(currentAssignment !== -1) this.skillSlots[currentAssignment] = null;

                       this.skillSlots[slotIndex] = skillId;
                       console.log(`技能 ${SkillData[skillId].name} 设置到快捷键 ${slotIndex + 1}`);
                       uiManager?.updateSkillBar();
                       uiManager?.updateSkillPanel(); // Refresh buttons in skill panel
                       playSound('equipItem'); // Reuse equip sound
                       return true;
                  }
                   return false;
             }
             unassignSkillFromSlot(slotIndex){
                 if(slotIndex < 0 || slotIndex >= this.skillSlots.length || this.skillSlots[slotIndex] === null) return;
                 const skillId = this.skillSlots[slotIndex];
                 this.skillSlots[slotIndex] = null;
                  console.log(`移除快捷键 ${slotIndex + 1} 的技能 ${SkillData[skillId].name}`);
                 uiManager?.updateSkillBar();
                 uiManager?.updateSkillPanel();
                  playSound('equipItem', 0.1, 0.6);
             }

             useSkill(slotIndex) {
                 if(slotIndex < 0 || slotIndex >= this.skillSlots.length) return;
                 const skillId = this.skillSlots[slotIndex];
                 if(!skillId) return; // No skill in slot

                 const skill = SkillData[skillId];
                 if(!skill) return; // Invalid skill ID

                 const now = gameTime;
                 // Check Cooldown
                 if(this.skillCooldowns[skillId] && now < this.skillCooldowns[skillId]){
                      console.log(`技能 ${skill.name} 冷却中...`);
                      playSound('invalidAction', 0.05);
                      return;
                 }
                 // Check MP Cost
                 if(this.stats.mp < skill.mpCost){
                      console.log(`法力不足，无法使用 ${skill.name}`);
                      uiManager?.addMessage("法力不足!", "lightblue");
                      playSound('invalidAction', 0.05);
                      return;
                 }

                 // --- Execute Skill ---
                 console.log(`使用技能: ${skill.name}`);
                 this.stats.mp -= skill.mpCost;
                 this.skillCooldowns[skillId] = now + skill.cooldown; // Set cooldown end time
                 uiManager?.updateHUD();
                  uiManager?.updateSkillSlotCooldown(slotIndex, skill.cooldown); // Trigger visual cooldown


                 switch(skill.type){
                      case 'ranged_projectile': {
                           // Aim at target enemy if exists, else aim forward
                            let targetPos;
                           if(this.targetEnemy?.mesh) {
                                targetPos = this.targetEnemy.pos.clone();
                           } else {
                                // Aim slightly ahead based on player look direction (mesh forward is -Z)
                               const forward = new THREE.Vector3(0,0,-1);
                               forward.applyQuaternion(this.mesh.quaternion); // Get world forward direction
                                targetPos = this.pos.clone().add(forward.multiplyScalar(TILE_SIZE * 5)); // Target point 5 tiles ahead
                           }
                           targetPos.y = this.pos.y; // Keep projectile roughly level

                           const startPos = this.pos.clone().add(new THREE.Vector3(0, this.size * 0.2, 0)); // Start slightly higher
                           projectiles.push(new Projectile(
                                startPos.x, startPos.y, startPos.z,
                                targetPos.x, targetPos.y, targetPos.z,
                                skill.projectileSpeed || 15,
                                skill.effect.damage || 0,
                                this,
                                skill.projectileType || 'default_skill',
                                skill.effect // Pass effect data for radius/secondary effects
                           ));
                           playSound('playerAttack', 0.15); // Generic attack sound for now
                           break;
                      }
                      case 'point_blank_aoe': {
                           const radius = skill.effect.radius || TILE_SIZE;
                           const radiusSq = radius * radius;
                           const damage = skill.effect.damage || 0;
                           const allUnits = [...monsters]; // Only target monsters with PBAoE for now
                            let hit = false;
                           for(const unit of allUnits){
                                if(unit?.mesh && unit.stats.hp > 0 && distSqXZ(this.pos, unit.pos) < radiusSq){
                                     if(typeof unit.takeDamage === 'function') unit.takeDamage(damage, this);
                                     hit = true;
                                }
                           }
                           // Visual Effect for AOE
                           const ringGeo = new THREE.RingGeometry(radius * 0.1, radius, 32);
                            const ringMat = new THREE.MeshBasicMaterial({ color: 0xaaaaff, side: THREE.DoubleSide, transparent: true, opacity: 0.7});
                            const ringMesh = new THREE.Mesh(ringGeo, ringMat);
                            ringMesh.position.copy(this.pos).add(new THREE.Vector3(0, 0.1, 0));
                            ringMesh.rotation.x = -Math.PI / 2;
                            scene.add(ringMesh);
                            const duration = 400; const startTime = Date.now();
                            const animateRing = () => { const elapsed = Date.now() - startTime; if(elapsed >= duration || !ringMesh.parent) { if(ringMesh.parent) scene.remove(ringMesh); ringGeo.dispose(); ringMat.dispose(); return; } const progress = elapsed / duration; const scale = 0.1 + (1.0 - 0.1) * progress; ringMesh.scale.set(scale, scale, scale); ringMat.opacity = 0.7 * (1 - progress); requestAnimationFrame(animateRing); };
                            animateRing();
                            if(hit) playSound('monsterHit'); // Play hit sound if it connected
                            else playSound('playerAttack', 0.1, 0.5); // Woosh sound if nothing hit
                           break;
                      }
                      case 'target_enemy': {
                           if(!this.targetEnemy || !this.targetEnemy.mesh || this.targetEnemy.stats.hp <= 0){
                                console.log("无效目标，无法使用技能。");
                                playSound('invalidAction');
                                // Refund cooldown and MP? Or just waste it? Let's waste it for now.
                                this.skillCooldowns[skillId] = now; // Effectively remove cooldown penalty
                                this.stats.mp += skill.mpCost; // Refund MP
                                uiManager?.updateHUD();
                                return;
                           }
                           const distSq = distSqXZ(this.pos, this.targetEnemy.pos);
                           const range = skill.range || this.currentStats.attackRange;
                           if(distSq > range * range){
                                console.log("目标太远，无法使用技能。");
                                playSound('invalidAction');
                                this.skillCooldowns[skillId] = now; // Refund cooldown
                                this.stats.mp += skill.mpCost; // Refund MP
                                uiManager?.updateHUD();
                                return;
                           }
                           // Apply effect
                           const damageMultiplier = skill.effect.damageMultiplier || 1.0;
                           const baseDamage = Math.max(1, this.currentStats.attack - (this.targetEnemy.currentStats?.defense ?? 0));
                           const finalDamage = Math.floor(baseDamage * damageMultiplier * (Math.random() * 0.2 + 0.9));

                           this.targetEnemy.takeDamage(finalDamage, this);
                            this.playAttackAnimation(this.targetEnemy); // Play basic attack anim
                            playSound('playerAttack', 0.15);

                            // Apply secondary effects like stun
                            if(skill.effect.stunChance && Math.random() < skill.effect.stunChance && typeof this.targetEnemy.applyStatus === 'function'){
                                 this.targetEnemy.applyStatus('stunned', skill.effect.stunDuration || 1.0);
                            }

                           break;
                      }
                       case 'buff_self': {
                           const duration = skill.effect.duration || 5.0;
                           const buffId = skillId; // Use skillId as buffId for simplicity
                           this.activeBuffs[buffId] = {
                                endTime: now + duration,
                                statMods: skill.effect // Assume effect object contains stat mods directly (e.g., { speedBonus: 1.5 })
                           };
                            this.updateCombinedStats(); // Re-calculate stats with buff
                            console.log(`应用Buff: ${skill.name} for ${duration}s`);
                           playSound('levelUp', 0.1); // Buff sound similar to level up?

                            // TODO: Add visual indicator for buff? Particle effect on player?
                           break;
                       }
                      // TODO: Implement other skill types (area_target, summon, chaining)
                      default:
                           console.warn(`未实现的技能类型: ${skill.type}`);
                           break;
                 }

             }


            update(deltaTime, units, map) {
                 if (this.stats.hp <= 0) return false;

                  // --- Handle Buff Expiration ---
                 const now = gameTime;
                 let statsChanged = false;
                 for(const buffId in this.activeBuffs){
                      if(now >= this.activeBuffs[buffId].endTime){
                           delete this.activeBuffs[buffId];
                           statsChanged = true;
                           console.log("Buff过期:", buffId);
                      }
                 }
                  if(statsChanged) this.updateCombinedStats(); // Recalculate stats if buffs expired


                 let moved = false;
                 let targetDestination = null;

                 // --- Determine Target Destination ---
                 if (this.targetEnemy) {
                     if (!this.targetEnemy.mesh || this.targetEnemy.stats.hp <= 0) {
                         this.targetEnemy = null; // Target died or invalid
                         this.isMoving = false;
                     } else {
                         const distSq = distSqXZ(this.pos, this.targetEnemy.pos);
                         const attackRangeSq = this.currentStats.attackRange ** 2;
                         if (distSq <= attackRangeSq) {
                             this.isMoving = false; // Stop to attack
                             this.attack(this.targetEnemy);
                         } else {
                             targetDestination = this.targetEnemy.pos; // Move towards enemy
                             this.isMoving = true;
                         }
                         // Face the target when attacking or chasing
                         this.mesh.lookAt(this.targetEnemy.pos.x, this.pos.y, this.targetEnemy.pos.z);
                     }
                 } else if (this.targetMovePos) {
                     const distSq = distSqXZ(this.pos, this.targetMovePos);
                      // Use speed * deltaTime as threshold? Or small fixed value?
                     if (distSq < (this.currentStats.speed * deltaTime * 1.5)**2 || distSq < 0.1) {
                         this.isMoving = false; // Reached destination
                         this.targetMovePos = null;
                         this.pos.x = this.targetMovePos ? this.targetMovePos.x : this.pos.x; // Snap roughly?
                         this.pos.z = this.targetMovePos ? this.targetMovePos.z : this.pos.z;
                     } else {
                         targetDestination = this.targetMovePos; // Move towards point
                         this.isMoving = true;
                         // Face movement direction
                         this.mesh.lookAt(this.targetMovePos.x, this.pos.y, this.targetMovePos.z);
                     }
                 } else {
                      this.isMoving = false; // No target
                 }


                 // --- Execute Movement ---
                 if (this.isMoving && targetDestination) {
                      const moveDir = targetDestination.clone().sub(this.pos);
                      moveDir.y = 0; // Move only on XZ plane
                      if (moveDir.lengthSq() > 0.001) { // Avoid normalizing zero vector
                          moveDir.normalize();
                          const moveAmount = this.currentStats.speed * deltaTime;
                          const moveVector = moveDir.multiplyScalar(moveAmount);
                          const nextPos = this.pos.clone().add(moveVector);

                          // Basic Collision Check (Map only for now)
                          if (!map.isObstacle(nextPos.x, nextPos.z) && !map.isOutsideBounds(nextPos.x, nextPos.z)) {
                              this.pos.copy(nextPos);
                              this.mesh.position.copy(this.pos);
                              moved = true;
                               // Play step sound periodically?
                          } else {
                              this.isMoving = false; // Hit wall
                              this.targetMovePos = null; // Stop trying to move to that point
                              // Play bump sound?
                              playSound('invalidAction', 0.05, 0.4);
                          }
                      } else {
                           this.isMoving = false; // Already at target (should have been caught above)
                      }
                 }



                 // --- Passive Updates ---
                  // HP Regen
                  this.stats.hp += this.currentStats.hpRegenRate * deltaTime;
                  this.stats.hp = Math.min(this.stats.hp, this.currentStats.maxHP);
                  // MP Regen
                 this.stats.mp += this.currentStats.mpRegenRate * deltaTime;
                 this.stats.mp = Math.min(this.stats.mp, this.currentStats.maxMP);
                  // Only update HUD frequently if actively regenerating and not full
                  if((this.stats.hp < this.currentStats.maxHP && this.currentStats.hpRegenRate > 0) || (this.stats.mp < this.currentStats.maxMP && this.currentStats.mpRegenRate > 0)){
                        // Throttle HUD updates for regen? Or update every frame? Let's try every frame for now.
                         uiManager?.updateHUD();
                  }


                 this.worldPos2D = worldToScreen(this.pos);
                 return moved;
             }
        }


        // --- Monster Class ---
        console.log("载入: 怪物类");
        class Monster {
            constructor(monsterId, x, z) {
                const data = MonsterData[monsterId];
                if (!data) { this.invalid = true; return; }
                this.id = monsterId;
                this.baseName = data.name; // Store base name
                this.size = data.size || TILE_SIZE * 0.8;
                this.pos = new THREE.Vector3(x, this.size * 0.5, z);
                this.color = new THREE.Color(data.color || 0xff0000);
                this.icon = data.icon || 'default_monster';
                this.attackType = data.attackType || 'melee';
                this.invalid = false;
                this.mesh = this.createMesh();
                 this.mesh.userData = { gameObject: this, type: 'Monster' };
                 scene.add(this.mesh);
                 intersectableUnits.push(this.mesh);

                this.baseStats = JSON.parse(JSON.stringify({ maxHP: data.hp || 10, maxMP: data.mp || 0, attack: data.attack || 1, defense: data.defense || 0, speed: data.speed || 1, attackRange: data.attackRange || TILE_SIZE * 1.5, aggroRange: data.aggroRange || TILE_SIZE * 5, projectileType: data.projectileType, projectileSpeed: data.projectileSpeed, projectileDamage: data.projectileDamage || data.attack || 1 }));
                this.currentStats = { ...this.baseStats }; // Start with base stats

                // --- Elite Handling ---
                this.isElite = false;
                this.affixes = []; // Array of affix IDs { id: 'fast', name: '<快速>' }
                this.name = this.baseName; // Initial name
                this.eliteParticleEmitter = null;

                if (Math.random() < MapSettings.eliteChance) {
                    this.makeElite();
                }
                 // --- End Elite ---

                this.stats = { hp: this.currentStats.maxHP, mp: this.currentStats.maxMP }; // Use currentStats for initial HP/MP after potential elite mods

                this.xpReward = data.xp * (this.isElite ? 3 : 1); // More XP for elites
                this.lootTable = data.lootTable || []; // TODO: Enhance loot for elites?

                this.target = null;
                this.state = 'idle';
                this.lastAttackTime = -Infinity;
                this.attackCooldown = (this.attackType === 'ranged' ? 2.5 : 1.5) + Math.random() * 0.4 - 0.2;
                 this.attackCooldown /= (this.currentStats.speed > this.baseStats.speed ? this.currentStats.speed / this.baseStats.speed : 1); // Faster elites attack faster
                this.wanderTarget = null;
                this.lastWanderTime = -Infinity;
                this.wanderCooldown = Math.random() * 5 + 4;
                this.healthBarElement = null;
                this.worldPos2D = { x: -1000, y: -1000};
                 this.activeStatuses = {}; // { statusId: endTime }
             }

             makeElite() {
                 this.isElite = true;
                 const possibleAffixes = Object.keys(EliteAffixes);
                 const numAffixes = Math.floor(Math.random() * 2) + 1; // 1-2 affixes

                 let affixNames = [];
                 for (let i = 0; i < numAffixes && possibleAffixes.length > 0; i++) {
                      const randomIndex = Math.floor(Math.random() * possibleAffixes.length);
                      const affixId = possibleAffixes.splice(randomIndex, 1)[0]; // Pick and remove
                      const affixData = EliteAffixes[affixId];
                      this.affixes.push({ id: affixId, name: affixData.name });
                      affixNames.push(affixData.name);

                      // Apply stat mods
                      if (affixData.statMods) {
                           for (const stat in affixData.statMods) {
                               if (this.currentStats.hasOwnProperty(stat)) {
                                    this.currentStats[stat] *= affixData.statMods[stat]; // Apply multiplier
                               } else if (this.baseStats.hasOwnProperty(stat)){ // Apply to base if not in current yet
                                    this.currentStats[stat] = (this.currentStats[stat] || this.baseStats[stat]) * affixData.statMods[stat];
                               }
                           }
                      }
                      // Ensure elite stats are reasonable (e.g., cap speed)
                      this.currentStats.speed = Math.min(this.currentStats.speed, this.baseStats.speed * 2.5); // Cap speed bonus

                       // Create particle effect (simple placeholder)
                       this.createEliteParticles(affixData.particleColor || 0xffffff);
                 }

                  this.name = `${this.baseName} ${affixNames.join(' ')}`; // Update name display
                  // Make mesh slightly larger and maybe tint it?
                 if(this.mesh) {
                    this.mesh.scale.multiplyScalar(1.15);
                    // Could tint material color slightly
                    // this.mesh.material.color.lerp(new THREE.Color(0xffffff), 0.1);
                 }
                 console.log(`精英怪物生成: ${this.name}`);
             }

             createEliteParticles(color = 0xffffff) {
                 if(this.eliteParticleEmitter || !this.mesh) return; // Already exists or no mesh

                 const particleCount = 30;
                 const positions = new Float32Array(particleCount * 3);
                 const geometry = new THREE.BufferGeometry();
                 geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));

                 const material = new THREE.PointsMaterial({
                      color: color,
                      size: TILE_SIZE * 0.1,
                      transparent: true,
                      opacity: 0.7,
                      sizeAttenuation: true,
                      blending: THREE.AdditiveBlending, // Brighter effect
                 });

                 this.eliteParticleEmitter = new THREE.Points(geometry, material);
                 this.mesh.add(this.eliteParticleEmitter); // Attach particles to monster mesh
             }

             updateEliteParticles(deltaTime) {
                 if (!this.isElite || !this.eliteParticleEmitter) return;

                 const positions = this.eliteParticleEmitter.geometry.attributes.position.array;
                 const radius = this.size * 0.7; // Radius around the monster

                 for (let i = 0; i < positions.length; i += 3) {
                      // Simple orbiting effect - can be much more complex
                      const angle = gameTime * (1.0 + Math.random() * 0.5) + i * 0.5; // Vary speed/offset
                      const x = Math.cos(angle) * radius * (0.8 + Math.random() * 0.4);
                      const y = (Math.random() - 0.5) * this.size * 1.5; // Random height offset
                      const z = Math.sin(angle) * radius * (0.8 + Math.random() * 0.4);
                      positions[i] = x;
                      positions[i + 1] = y;
                      positions[i + 2] = z;
                 }
                 this.eliteParticleEmitter.geometry.attributes.position.needsUpdate = true;
             }


             createMesh() {
                  // Capsule for NPCs too
                  const radius = this.size * 0.35;
                  const height = this.size * 0.9;
                  const geo = new THREE.CapsuleGeometry(radius, height, 4, 10);
                  const mat = new THREE.MeshStandardMaterial({
                       color: this.color,
                       roughness: 0.8,
                       metalness: 0.1
                  });
                  const mesh = new THREE.Mesh(geo, mat);
                  mesh.position.copy(this.pos);
                  mesh.castShadow = true;
                   mesh.receiveShadow = false;
                  return mesh;
             }
             takeDamage(damage, attacker) {
                 if (!this.stats || this.stats.hp <= 0) return;
                 this.stats.hp -= damage;
                 if (uiManager) uiManager.addFloatingText(`-${damage}`, this.pos, 'red');
                  playSound('playerHit');

                 if (this.stats.hp <= 0) {
                      this.stats.hp = 0; // Prevent negative HP display
                      this.die(attacker);
                 } else {
                      // Flash effect?
                      if (this.mesh) {
                           const originalColor = this.mesh.material.color.getHex();
                           this.mesh.material.color.setHex(0xff0000);
                           this.mesh.material.emissive.setHex(0xff0000); this.mesh.material.emissiveIntensity = 0.8;
                           setTimeout(() => {
                                if (this.mesh) { // Check if mesh still exists (player might die)
                                     this.mesh.material.color.setHex(originalColor);
                                     this.mesh.material.emissive.setHex(0x000000); this.mesh.material.emissiveIntensity = 0;
                                }
                           }, 150);
                      }
                 }
                  uiManager?.updateHUD(); // Update HUD immediately
             }
             die(killer) { 
				if (gameState === 'gameOver') return; // Already dead
                 const killerName = killer?.name ?? 'unknown causes';
                 console.log(`${this.name} slain by ${killerName}!`);
                 playSound('playerDeath');
                 gameState = 'gameOver';
                 uiManager?.showGameOverScreen();
                 // Maybe play death animation? Make mesh fall over?
                 if(this.mesh) {
                     // this.mesh.rotation.z = Math.PI / 2; // Simple fall
                     // Make slightly transparent?
                     // this.mesh.material.transparent = true;
                     // this.mesh.material.opacity = 0.6;
                 }

                if(this.eliteParticleEmitter) this.mesh?.remove(this.eliteParticleEmitter); // Remove particles on death
             }
             dropLoot() {
                 if (this.invalid) return;
                  const dropMultiplier = this.isElite ? 2 : 1; // Elites drop more loot chance
                  this.lootTable.forEach(loot => {
                      if (Math.random() < loot.chance * dropMultiplier) { // Increased chance
                           let quantity = 1;
                           // Maybe drop more quantity for elites?
                           // if(this.isElite && ItemData[loot.itemId]?.stackable) quantity = Math.floor(Math.random()*3)+1;

                          const itemInstance = new Item(loot.itemId, quantity);
                          if (itemInstance && !itemInstance.invalid) {
                              const dropOffset = new THREE.Vector3( (Math.random() - 0.5) * TILE_SIZE * 0.4, 0, (Math.random() - 0.5) * TILE_SIZE * 0.4 );
                              const dropPos = this.pos.clone().add(dropOffset);
                              worldItems.push(new DroppedItem(itemInstance, dropPos.x, dropPos.z));
                          }
                      }
                  });
                   // Elite specific drops? Higher rarity chance?
                   if(this.isElite && Math.random() < 0.2){ // 20% chance for extra rare+ drop
                        const possibleItems = Object.keys(ItemData).filter(id => ItemData[id].rarity === 'rare' || ItemData[id].rarity === 'uncommon');
                        if(possibleItems.length > 0){
                            const rareDropId = randomFromArray(possibleItems);
                            const itemInstance = new Item(rareDropId);
                             if (itemInstance && !itemInstance.invalid) {
                                 const dropOffset = new THREE.Vector3( (Math.random() - 0.5) * TILE_SIZE * 0.4, 0, (Math.random() - 0.5) * TILE_SIZE * 0.4 );
                                 const dropPos = this.pos.clone().add(dropOffset);
                                 worldItems.push(new DroppedItem(itemInstance, dropPos.x, dropPos.z));
                                  if(uiManager) uiManager.addMessage(`精英掉落: ${itemInstance.name}`, getRarityHexColor(itemInstance.rarity), 4000);
                             }
                        }
                   }

             }
             attack(target) {
                 if (!target || !target.stats || target.stats.hp <= 0) {
                     this.targetEnemy = null; return;
                 }
                 const now = gameTime;
                 if (now - this.lastAttackTime >= this.attackCooldown) {
                     console.log(`${this.name} attacks ${target.name}`);
                     const targetDefense = target.currentStats?.defense ?? 0;
                     let damage = Math.max(1, this.currentStats.attack - targetDefense);
                     damage = Math.floor(damage * (Math.random() * 0.3 + 0.85)); // 85% - 115%

                     playSound('playerAttack');
                     if (typeof target.takeDamage === 'function') {
                         target.takeDamage(damage, this);
                     } else { console.error("Target has no takeDamage method:", target); }

                     this.lastAttackTime = now;
                     this.playAttackAnimation(target); // Visual effect

                     if (target.stats.hp <= 0) this.targetEnemy = null;
                 }
             }

             playAttackAnimation(target){
                  // Simple line effect for now
                   if (target?.mesh) {
                        const lineMat = new THREE.LineBasicMaterial({color: 0xffdd00, transparent: true, opacity: 0.8});
                        const points = [this.pos.clone().add(new THREE.Vector3(0,this.size*0.1,0)), target.pos.clone().add(new THREE.Vector3(0,target.size*0.1,0)) ];
                        const lineGeo = new THREE.BufferGeometry().setFromPoints(points);
                        const line = new THREE.Line(lineGeo, lineMat);
                        scene.add(line);
                        // Remove line after short duration
                        setTimeout(() => {
                             scene.remove(line);
                             lineMat.dispose();
                             lineGeo.dispose();
                        }, 150);
                   }
             }

            applyStatus(statusId, duration) {
                 if(this.state === 'dead') return;
                 const now = gameTime;
                 this.activeStatuses[statusId] = now + duration;
                 console.log(`${this.name} 受到状态: ${statusId} for ${duration}s`);
                 // TODO: Apply visual effect for status (e.g., tint blue for slow)
            }

            update(deltaTime, player, npcs, map) {
                 if (this.state === 'dead' || this.invalid) return;

                  // --- Update Status Effects ---
                  const now = gameTime;
                  let currentSpeedMultiplier = 1.0;
                  let isStunned = false;
                  for(const statusId in this.activeStatuses){
                      if(now >= this.activeStatuses[statusId]){
                           delete this.activeStatuses[statusId]; // Remove expired
                      } else {
                           // Apply active effects
                           if(statusId === 'slowed') currentSpeedMultiplier *= 0.5;
                           if(statusId === 'stunned') isStunned = true;
                      }
                  }
                  this.currentStats.speed = this.baseStats.speed * currentSpeedMultiplier * (this.isElite && EliteAffixes['fast'] ? EliteAffixes['fast'].statMods.speed : 1.0); // Recalculate speed based on status

                  // Update elite particles
                  this.updateEliteParticles(deltaTime);

                   // Skip AI if stunned
                  if(isStunned){
                       // Maybe add stunned visual?
                       return;
                  }

                 // Target Acquisition / State Update
                 this.findTarget(player, npcs);
                 // ... (rest of update logic same as before) ...
                 let moved = false; switch (this.state) { case 'idle': if (gameTime - this.lastWanderTime > this.wanderCooldown) { this.state = 'wandering'; this.lastWanderTime = gameTime; this.wanderCooldown = Math.random() * 5 + 4; } break; case 'wandering': if (!this.wanderTarget) this.setWanderTarget(map); if (this.wanderTarget) { moved = this.moveTowards(this.wanderTarget, deltaTime, map); if (!moved || distSqXZ(this.pos, this.wanderTarget) < (this.currentStats.speed * deltaTime * 1.5)**2) { this.wanderTarget = null; this.state = 'idle'; } } else { this.state = 'idle'; } break; case 'chasing': if (this.target?.mesh) { moved = this.moveTowards(this.target.pos, deltaTime, map); this.mesh.lookAt(this.target.pos.x, this.pos.y, this.target.pos.z); } else { this.state = 'idle'; } break; case 'attacking': if (this.target?.mesh) { this.mesh.lookAt(this.target.pos.x, this.pos.y, this.target.pos.z); this.attack(this.target); } else { this.state = 'idle'; } break; }
                 this.worldPos2D = worldToScreen(this.pos);
             }
             findTarget(player, npcs) {
                  let potentialTargets = [];
                  if (player?.mesh && player.stats.hp > 0) potentialTargets.push(player);
                  // Add fightable NPCs (only if in village? depends on game logic)
                  if (currentMap.isVillage) {
                       npcs.forEach(npc => {
                            if (npc?.mesh && npc.canFight && npc.stats.hp > 0) potentialTargets.push(npc);
                       });
                  }

                  let closestTarget = null;
                  let minDistSq = (this.target ? distSqXZ(this.pos, this.target.pos) : Infinity); // Start with current target distance or infinity

                  // Check current target validity
                  if (this.target) {
                       if (!potentialTargets.includes(this.target) || this.target.stats.hp <= 0) {
                            this.target = null; // Target invalid
                            this.state = 'idle';
                            minDistSq = Infinity; // Force scan
                       } else {
                            // Check if target moved too far away (beyond AGGRO range * 1.5)
                             const maxChaseDistSq = (this.currentStats.aggroRange ** 2) * 2.25;
                             if (minDistSq > maxChaseDistSq) {
                                  this.target = null; this.state = 'idle'; minDistSq = Infinity;
                             } else {
                                  closestTarget = this.target; // Assume current is still best
                             }
                       }
                  }

                 // Scan for closer targets within aggro range
                  const aggroRangeSq = this.currentStats.aggroRange ** 2;
                  for (let pTarget of potentialTargets) {
                       const dSq = distSqXZ(this.pos, pTarget.pos);
                       if (dSq < aggroRangeSq && dSq < minDistSq) {
                            minDistSq = dSq;
                            closestTarget = pTarget;
                       }
                  }

                  // Update state based on closest valid target
                  if (closestTarget) {
                       this.target = closestTarget;
                       const attackRangeSq = this.currentStats.attackRange ** 2;
                       if (minDistSq <= attackRangeSq) {
                            this.state = 'attacking';
                       } else {
                            this.state = 'chasing';
                       }
                  } else {
                        // No target found or lost target, revert to idle if not already idle/wandering
                        if(this.state === 'chasing' || this.state === 'attacking') {
                             this.state = 'idle';
                        }
                        this.target = null;
                  }
             }

             setWanderTarget(map) {
                  const angle = Math.random() * Math.PI * 2;
                  const dist = Math.random() * TILE_SIZE * 3 + TILE_SIZE * 1.5;
                  const tryX = this.pos.x + Math.cos(angle) * dist;
                  const tryZ = this.pos.z + Math.sin(angle) * dist;
                  if (!map.isObstacle(tryX, tryZ) && !map.isOutsideBounds(tryX, tryZ)) {
                       this.wanderTarget = new THREE.Vector3(tryX, this.pos.y, tryZ);
                  } else {
                       this.wanderTarget = null; // Failed
                  }
             }
              moveTowards(targetVector3, deltaTime, map) {
                 if (!targetVector3 || !this.mesh) return false;
                  const moveDir = targetVector3.clone().sub(this.pos);
                  moveDir.y = 0; // Move on XZ plane
                   if (moveDir.lengthSq() < 0.01) return false; // Already close

                   moveDir.normalize();
                  const moveAmount = this.currentStats.speed * deltaTime;
                  const moveVector = moveDir.multiplyScalar(moveAmount);
                   const nextPos = this.pos.clone().add(moveVector);

                   // Basic Map Collision
                  if (!map.isObstacle(nextPos.x, nextPos.z) && !map.isOutsideBounds(nextPos.x, nextPos.z)) {
                       // TODO: Add basic unit-unit collision avoidance?
                       this.pos.copy(nextPos);
                       this.mesh.position.copy(this.pos);
                       return true;
                  } else {
                       // Hit obstacle - maybe try sliding? Basic: just stop.
                        return false;
                  }
              }
             dispose() {
                  if (this.mesh) {
                       if(this.eliteParticleEmitter) this.mesh.remove(this.eliteParticleEmitter); // Remove particles
                       scene.remove(this.mesh);
                       const index = intersectableUnits.indexOf(this.mesh);
                       if (index > -1) intersectableUnits.splice(index, 1);
                       this.mesh.geometry.dispose();
                       this.mesh.material.dispose();
                       this.mesh = null;
                  }
                   if(this.eliteParticleEmitter){
                        this.eliteParticleEmitter.geometry.dispose();
                        this.eliteParticleEmitter.material.dispose();
                        this.eliteParticleEmitter = null;
                   }
                  uiManager?.removeWorldHealthBar(this);
                  this.invalid = true;
             }
        }


        // --- NPC Class ---
        console.log("载入: NPC类");
        /* ... NPC class mostly same, check update/findTarget ... */
        class Npc { constructor(npcId, x, z) { const data = NpcData[npcId]; if (!data) { this.invalid = true; return; } this.id = npcId; this.name = data.name; this.size = data.size || TILE_SIZE * 0.9; this.pos = new THREE.Vector3(x, this.size * 0.5, z); this.color = new THREE.Color(data.color || 0x0000ff); this.icon = data.icon || 'default_npc'; this.dialogue = data.dialogue || [`你好。`]; this.canFight = data.canFight || false; this.invalid = false; this.mesh = this.createMesh(); this.mesh.userData = { gameObject: this, type: 'Npc' }; scene.add(this.mesh); intersectableUnits.push(this.mesh); this.baseStats = JSON.parse(JSON.stringify({ maxHP: data.hp || 50, attack: data.attack || 0, defense: data.defense || 0, speed: data.speed || 1, attackRange: data.attackRange || TILE_SIZE * 1.0, aggroRange: data.aggroRange || TILE_SIZE * 4, })); this.pursuitRangeMultiplier = data.pursuitRangeMultiplier || 1.0; this.currentStats = { ...this.baseStats }; this.stats = { hp: this.baseStats.maxHP }; this.targetEnemy = null; this.state = 'idle'; this.lastAttackTime = -Infinity; this.attackCooldown = (data.attackCooldown || 2.0) + Math.random() * 0.2 - 0.1; this.healthBarElement = null; this.worldPos2D = { x: -1000, y: -1000}; } createMesh() { const radius = this.size * 0.35; const height = this.size * 0.9; const geo = new THREE.CapsuleGeometry(radius, height, 4, 10); const mat = new THREE.MeshStandardMaterial({ color: this.color, roughness: 0.8, metalness: 0.1 }); const mesh = new THREE.Mesh(geo, mat); mesh.position.copy(this.pos); mesh.castShadow = true; mesh.receiveShadow = false; return mesh; } interact(player) { if (this.state === 'dead' || this.invalid) return; const msg = randomFromArray(this.dialogue) || `你好。`; if (uiManager) uiManager.addMessage(`${this.name}: "${msg}"`, 'cyan', 4000); playSound('npcInteract'); if(player?.mesh) { this.mesh.lookAt(player.pos.x, this.pos.y, player.pos.z); } } takeDamage(damage, attacker) { if (this.state === 'dead' || this.invalid) return; if (!this.stats) this.stats = { hp: 0 }; this.stats.hp -= damage; this.stats.hp = Math.max(0, this.stats.hp); if (uiManager) uiManager.addFloatingText(`-${damage}`, this.pos, 'orange'); if (this.mesh) { const originalColor = this.mesh.material.color.getHex(); this.mesh.material.color.setHex(0xff8c00); setTimeout(() => { if(this.mesh) this.mesh.material.color.setHex(originalColor); }, 100); } if (this.stats.hp <= 0) { this.die(attacker); } else { if (this.canFight && attacker instanceof Monster) { if(attacker.mesh && attacker.stats.hp > 0){ this.targetEnemy = attacker; if (this.state !== 'fighting') { this.state = 'fighting'; console.log(`NPC ${this.name} 开始攻击 ${attacker.name}!`); } } } } } die(killer) { if (this.state === 'dead' || this.invalid) return; this.stats.hp = 0; this.state = 'dead'; const killerName = killer?.name ?? '未知原因'; console.log(`NPC ${this.name} 被 ${killerName} 杀死了...`); const index = intersectableUnits.indexOf(this.mesh); if (index > -1) intersectableUnits.splice(index, 1); if (this.mesh) { this.mesh.castShadow = false; this.mesh.material.transparent = true; this.mesh.material.opacity = 0.4; this.mesh.rotation.z = -Math.PI / 2 + (Math.random()-0.5)*0.3; } uiManager?.removeWorldHealthBar(this); } attack(target) { if (!target || !target.mesh || target.stats.hp <= 0 || this.state !== 'fighting' || this.invalid) { this.targetEnemy = null; if(this.stats.hp > 0) this.state = 'idle'; return; } const now = gameTime; if (now - this.lastAttackTime >= this.attackCooldown) { const targetDefense = target.currentStats?.defense ?? 0; let damage = Math.max(1, this.currentStats.attack - targetDefense); damage = Math.floor(damage * (Math.random() * 0.2 + 0.9)); if(typeof target.takeDamage === 'function') target.takeDamage(damage, this); this.playAttackAnimation(target); this.lastAttackTime = now; if (target.stats.hp <= 0) { this.targetEnemy = null; this.state = 'idle'; } } } playAttackAnimation(target){ if (target?.mesh) { const lineMat = new THREE.LineBasicMaterial({color: 0xaaaaff, transparent: true, opacity: 0.7}); const points = [this.pos.clone().add(new THREE.Vector3(0,this.size*0.1,0)), target.pos.clone().add(new THREE.Vector3(0,target.size*0.1,0)) ]; const lineGeo = new THREE.BufferGeometry().setFromPoints(points); const line = new THREE.Line(lineGeo, lineMat); scene.add(line); setTimeout(() => { scene.remove(line); lineMat.dispose(); lineGeo.dispose(); }, 110); } } update(deltaTime, monsters, player, map) { if (this.state === 'dead' || this.invalid) return; if (this.canFight) { this.findTarget(monsters); if (this.targetEnemy?.mesh) { this.mesh.lookAt(this.targetEnemy.pos.x, this.pos.y, this.targetEnemy.pos.z); const distSq = distSqXZ(this.pos, this.targetEnemy.pos); const attackRangeSq = this.currentStats.attackRange ** 2; if (distSq <= attackRangeSq) { this.attack(this.targetEnemy); } else { const maxPursuitDistSq = (this.currentStats.aggroRange ** 2) * (this.pursuitRangeMultiplier**2); if(distSq <= maxPursuitDistSq) { this.moveTowards(this.targetEnemy.pos, deltaTime, map); } else { if(this.state === 'fighting') console.log(`${this.name} 丢失目标 ${this.targetEnemy.name}.`); this.targetEnemy = null; this.state = 'idle'; } } } else { if(this.state === 'fighting') this.state = 'idle'; } } if (this.state === 'idle') { if(Math.random() < 0.005) { this.mesh.rotation.y += (Math.random() - 0.5) * Math.PI; } } this.worldPos2D = worldToScreen(this.pos); } findTarget(monsters) { let closestEnemy = null; let minDistSq = (this.targetEnemy ? distSqXZ(this.pos, this.targetEnemy.pos) : Infinity); const validMonsters = monsters.filter(m => m?.mesh && m.stats.hp > 0); if (this.targetEnemy) { if (!validMonsters.includes(this.targetEnemy)) { this.targetEnemy = null; this.state = 'idle'; minDistSq = Infinity; } else { const maxChaseDistSq = (this.currentStats.aggroRange ** 2) * (this.pursuitRangeMultiplier**2); if (minDistSq > maxChaseDistSq) { this.targetEnemy = null; this.state = 'idle'; minDistSq = Infinity; } else { closestEnemy = this.targetEnemy; } } } const aggroRangeSq = this.currentStats.aggroRange ** 2; for (let monster of validMonsters) { const dSq = distSqXZ(this.pos, monster.pos); if (dSq < aggroRangeSq && dSq < minDistSq) { minDistSq = dSq; closestEnemy = monster; } } if (closestEnemy) { if (this.targetEnemy !== closestEnemy) { this.targetEnemy = closestEnemy; if(this.state !== 'fighting') console.log(`NPC ${this.name} 锁定目标 ${closestEnemy.name}.`); } this.state = 'fighting'; } else { if(this.state === 'fighting') this.state = 'idle'; this.targetEnemy = null; } } moveTowards(targetVector3, deltaTime, map) { if (!targetVector3 || !this.mesh) return false; const moveDir = targetVector3.clone().sub(this.pos); moveDir.y = 0; if (moveDir.lengthSq() < 0.01) return false; moveDir.normalize(); const moveAmount = this.currentStats.speed * deltaTime; const moveVector = moveDir.multiplyScalar(moveAmount); const nextPos = this.pos.clone().add(moveVector); if (!map.isObstacle(nextPos.x, nextPos.z) && !map.isOutsideBounds(nextPos.x, nextPos.z)) { this.pos.copy(nextPos); this.mesh.position.copy(this.pos); return true; } return false; } dispose() { if (this.mesh) { scene.remove(this.mesh); const index = intersectableUnits.indexOf(this.mesh); if (index > -1) intersectableUnits.splice(index, 1); this.mesh.geometry.dispose(); this.mesh.material.dispose(); this.mesh = null; } uiManager?.removeWorldHealthBar(this); this.invalid = true; } }


        // --- UI Manager (HTML Overlay Version) ---
        console.log("载入: UI管理器");
        class UIManager {
            constructor() {
                this.hudElement = document.getElementById('hud');
                this.hpBar = document.getElementById('hp-bar-inner'); this.hpText = document.getElementById('hp-bar-text');
                this.mpBar = document.getElementById('mp-bar-inner'); this.mpText = document.getElementById('mp-bar-text');
                this.xpBar = document.getElementById('xp-bar-inner'); this.xpText = document.getElementById('xp-bar-text');
                 this.skillBarSlots = [ document.getElementById('skill-slot-0'), document.getElementById('skill-slot-1'), document.getElementById('skill-slot-2'), document.getElementById('skill-slot-3'), ]; // Cache skill bar slots
                this.systemMessagesContainer = document.getElementById('system-messages');
                this.inventoryPanel = document.getElementById('inventory-panel'); this.inventoryGrid = document.getElementById('inventory-grid');
                this.equipmentPanel = document.getElementById('equipment-panel'); this.equipmentGrid = document.getElementById('equipment-grid');
                 this.skillPanel = document.getElementById('skill-panel'); // Skill panel elements
                 this.skillPointsDisplay = document.getElementById('skill-points-display');
                 this.skillListContainer = document.getElementById('skill-list');
                this.tooltipElement = document.getElementById('tooltip');
                this.floatingTextContainer = document.getElementById('floating-text-container');
                this.gameOverScreen = document.getElementById('game-over-screen'); this.loadingScreen = document.getElementById('loading-screen'); this.errorScreen = document.getElementById('error-screen');
                this.maxMessages = 6; this.systemMessages = []; this.showInventory = false; this.showSkills = false; // Track skill panel visibility
                this.inventorySlots = []; this.equipmentSlots = {};
                this.calculateLayout(); this.createInventorySlots(); this.createEquipmentSlots();
                 this.updateSkillBar(); // Initial update
             }
              showError(message) {
                   this.errorScreen.textContent = message;
                   this.errorScreen.classList.add('visible');
                   this.loadingScreen.style.display = 'none'; // Hide loading
              }

             hideLoading() {
                   this.loadingScreen.style.display = 'none';
             }

             updateHUD() {
                 if (!player || !player.stats || !player.currentStats) return;
                 const hpPercent = (player.currentStats.maxHP > 0 ? player.stats.hp / player.currentStats.maxHP : 0) * 100;
                 const mpPercent = (player.currentStats.maxMP > 0 ? player.stats.mp / player.currentStats.maxMP : 0) * 100;
                 const xpPercent = (player.currentStats.xpToNextLevel > 0 ? player.stats.xp / player.currentStats.xpToNextLevel : 0) * 100;

                 this.hpBar.style.width = `${hpPercent}%`;
                 this.hpText.textContent = `${player.stats.hp}/${player.currentStats.maxHP}`;
                 this.mpBar.style.width = `${mpPercent}%`;
                 this.mpText.textContent = `${player.stats.mp}/${player.currentStats.maxMP}`;
                 this.xpBar.style.width = `${xpPercent}%`;
                  this.xpText.textContent = `Lvl ${player.stats.level} (${player.stats.xp}/${player.currentStats.xpToNextLevel})`;
             }

             addMessage(text, colorHex = '#FFFFFF', duration = 3000) {
                  const messageEl = document.createElement('div');
                  messageEl.classList.add('message');
                  messageEl.textContent = text;
                  messageEl.style.color = colorHex; // Use hex color directly

                  this.systemMessagesContainer.prepend(messageEl); // Add to top (bottom visually due to flex-reverse)
                  const messageData = { element: messageEl };
                  this.systemMessages.push(messageData);

                  // Auto-fade and remove
                  messageData.timeoutId = setTimeout(() => {
                       messageEl.classList.add('fading');
                       setTimeout(() => {
                           if (messageEl.parentNode) { // Check if still attached
                                messageEl.parentNode.removeChild(messageEl);
                           }
                           const index = this.systemMessages.indexOf(messageData);
                           if (index > -1) this.systemMessages.splice(index, 1);
                       }, 500); // Remove after fade out transition
                  }, duration);

                  // Prune old messages if exceeding max
                  if (this.systemMessages.length > this.maxMessages) {
                       const oldestMessage = this.systemMessages.shift();
                       if (oldestMessage && oldestMessage.element.parentNode) {
                            clearTimeout(oldestMessage.timeoutId); // Prevent removal errors
                            oldestMessage.element.parentNode.removeChild(oldestMessage.element);
                       }
                  }
             }

             addFloatingText(text, worldPos, color = 'white', duration = 1.0, size = 16) {
                 const textEl = document.createElement('div');
                 textEl.classList.add('floating-text');
                 textEl.textContent = text;
                 textEl.style.color = color;
                 textEl.style.fontSize = `${size}px`;

                 this.floatingTextContainer.appendChild(textEl);

                  // Calculate initial screen position
                  const screenPos = worldToScreen(worldPos);
                  const startY = screenPos.y;
                  textEl.style.left = `${screenPos.x}px`;
                  textEl.style.top = `${startY}px`;
                  textEl.style.opacity = 1;

                  // Animate upwards movement and fade
                  const endY = startY - 50; // Move up 50 pixels
                  textEl.style.transform = `translate(-50%, -50px)`; // Use transform for smoother animation
                  textEl.style.opacity = 0;
                  textEl.style.transition = `transform ${duration}s ease-out, opacity ${duration}s ease-out`;


                 // Remove element after animation
                  setTimeout(() => {
                      if (textEl.parentNode) {
                          textEl.parentNode.removeChild(textEl);
                      }
                  }, duration * 1000);
             }
            calculateLayout() {
                 const margin = 15;
                 const panelWidthInv = 4 * (45 + 6) + 6 + 20;
                 const panelWidthEq = 1 * (45 + 6) + 6 + 80 + 20;
                 this.inventoryPanel.style.right = `${margin}px`; this.inventoryPanel.style.top = '50%'; this.inventoryPanel.style.transform = 'translateY(-50%)'; this.inventoryPanel.style.width = `${panelWidthInv}px`;
                 this.equipmentPanel.style.right = `${margin + panelWidthInv + margin}px`; this.equipmentPanel.style.top = '50%'; this.equipmentPanel.style.transform = 'translateY(-50%)'; this.equipmentPanel.style.width = `${panelWidthEq}px`;
                  // Skill panel is centered, width set in CSS
             }
             createInventorySlots() {
                  this.inventoryGrid.innerHTML = ''; // Clear existing
                  this.inventorySlots = [];
                  for (let i = 0; i < PlayerDefaults.inventorySize; i++) {
                       const slotEl = this.createSlotElement(i, 'inventory');
                       this.inventoryGrid.appendChild(slotEl);
                       this.inventorySlots.push(slotEl);
                  }
             }
             createEquipmentSlots() {
                  this.equipmentGrid.innerHTML = ''; // Clear existing
                  this.equipmentSlots = {};
                   const slotOrder = ['weapon', 'helmet', 'armor', 'boots', 'amulet', 'ring1', 'ring2'];
                   const slotLabels = { weapon: 'Weapon', helmet: 'Helmet', armor: 'Armor', boots: 'Boots', amulet: 'Amulet', ring1: 'Ring 1', ring2: 'Ring 2' };

                  slotOrder.forEach(slotName => {
                       const slotEl = this.createSlotElement(slotName, 'equipment');
                       const labelEl = document.createElement('div');
                       labelEl.classList.add('slot-label');
                       labelEl.textContent = slotLabels[slotName] || slotName;
                       this.equipmentGrid.appendChild(slotEl);
                       this.equipmentGrid.appendChild(labelEl);
                       this.equipmentSlots[slotName] = slotEl;
                  });
             }

             createSlotElement(id, type) {
                  const slotEl = document.createElement('div');
                  slotEl.classList.add('item-slot');
                  slotEl.dataset.slotId = id; // Store index or name
                  slotEl.dataset.slotType = type; // 'inventory' or 'equipment'

                  // Placeholder for item icon structure
                  slotEl.innerHTML = `
                      <div class="item-icon"></div>
                      <div class="item-quantity"></div>
                  `;

                   // Add event listeners directly here
                   slotEl.addEventListener('click', (e) => {
                       e.stopPropagation(); // Prevent click from bubbling to canvas/document
                       this.handleSlotClick(id, type, e.button); // Pass button: 0=left, 2=right
                   });
                    slotEl.addEventListener('contextmenu', (e) => {
                        e.preventDefault(); // Prevent browser context menu on right click
                         e.stopPropagation();
                        this.handleSlotClick(id, type, 2); // Treat contextmenu as right click
                   });
                   slotEl.addEventListener('mouseenter', () => this.handleSlotMouseEnter(id, type));
                   slotEl.addEventListener('mouseleave', () => this.handleSlotMouseLeave());

                  return slotEl;
             }
             updateInventory() {
                 if (!player || !player.inventory) return;
                 for (let i = 0; i < this.inventorySlots.length; i++) {
                     this.updateSlotElement(this.inventorySlots[i], player.inventory[i]);
                 }
             }
             updateEquipment() {
                 if (!player || !player.equipment) return;
                 for (const slotName in this.equipmentSlots) {
                     this.updateSlotElement(this.equipmentSlots[slotName], player.equipment[slotName]);
                 }
             }

             updateSlotElement(slotEl, item) {
                  const iconEl = slotEl.querySelector('.item-icon');
                  const quantityEl = slotEl.querySelector('.item-quantity');
                  if (!iconEl || !quantityEl) return;

                  if (item) {
                      iconEl.className = `item-icon icon-${item.icon || 'default'} ${item.rarity || 'common'}`; // Update icon class
                      iconEl.style.display = 'block';
                      if (item.stackable && item.quantity > 1) {
                          quantityEl.textContent = item.quantity;
                          quantityEl.style.display = 'block';
                      } else {
                          quantityEl.style.display = 'none';
                      }
                       slotEl.dataset.hasItem = 'true'; // Mark slot as having an item for tooltip logic
                  } else {
                      iconEl.className = 'item-icon'; // Reset class
                      iconEl.style.display = 'none';
                      quantityEl.style.display = 'none';
                       slotEl.dataset.hasItem = 'false';
                  }
             }

             updateSkillBar() {
                 if (!player || !this.skillBarSlots) return;
                 for (let i = 0; i < this.skillBarSlots.length; i++) {
                      const slotEl = this.skillBarSlots[i];
                      const skillId = player.skillSlots[i];
                      const skillIconDiv = slotEl.querySelector('.skill-icon');
                      const skillNameSpan = slotEl.querySelector('.skill-name');
                      const cooldownOverlay = slotEl.querySelector('.skill-cooldown-overlay');

                      if (skillId && SkillData[skillId] && skillIconDiv && skillNameSpan) {
                           const skill = SkillData[skillId];
                           skillIconDiv.style.backgroundColor = '#777'; // TODO: Use actual icons later
                           skillNameSpan.textContent = skill.name;
                            // Check and display cooldown
                            const now = gameTime;
                            const cooldownEndTime = player.skillCooldowns[skillId] || 0;
                           if(now < cooldownEndTime){
                                cooldownOverlay.textContent = (cooldownEndTime - now).toFixed(1);
                                cooldownOverlay.classList.add('visible');
                           } else {
                                cooldownOverlay.classList.remove('visible');
                           }
                      } else if(skillIconDiv && skillNameSpan) {
                           skillIconDiv.style.backgroundColor = '#555'; // Empty slot style
                           skillNameSpan.textContent = '';
                           cooldownOverlay?.classList.remove('visible');
                      }
                 }
             }
              // Call this from animate loop or when cooldown starts
             updateSkillSlotCooldown(slotIndex, duration) {
                  const slotEl = this.skillBarSlots[slotIndex];
                  if(!slotEl) return;
                  const cooldownOverlay = slotEl.querySelector('.skill-cooldown-overlay');
                  const skillId = player.skillSlots[slotIndex];
                  if(!cooldownOverlay || !skillId) return;

                 const endTime = player.skillCooldowns[skillId];
                 const updateDisplay = () => {
                      const now = gameTime;
                      const remaining = endTime - now;
                      if(remaining > 0){
                          cooldownOverlay.textContent = remaining.toFixed(1);
                          cooldownOverlay.classList.add('visible');
                          requestAnimationFrame(updateDisplay); // Continue updating
                      } else {
                          cooldownOverlay.classList.remove('visible');
                      }
                 };
                 updateDisplay();
             }


             toggleInventory() { /* ... same ... */
			 
			 
                 this.showInventory = !this.showInventory;
                 if (this.showInventory) {
                     if(this.showSkills) this.toggleSkillPanel(); // Close skills if opening inventory
                     this.inventoryPanel.classList.add('visible'); this.equipmentPanel.classList.add('visible');
                     this.updateInventory(); this.updateEquipment(); playSound('openInventory');
                 } else {
                     this.inventoryPanel.classList.remove('visible'); this.equipmentPanel.classList.remove('visible');
                     this.hideTooltip(); playSound('closeInventory');
                 }
             }
             toggleSkillPanel() {
                 this.showSkills = !this.showSkills;
                 if(this.showSkills){
                     if(this.showInventory) this.toggleInventory(); // Close inventory if opening skills
                     this.updateSkillPanel(); // Refresh content
                     this.skillPanel.classList.add('visible');
                      playSound('openInventory', 0.1, 0.9); // Slightly different sound?
                 } else {
                      this.skillPanel.classList.remove('visible');
                      playSound('closeInventory', 0.1, 0.9);
                 }
             }

             updateSkillPanel() {
                 if (!player || !this.skillPanel.classList.contains('visible')) return;

                 this.skillPointsDisplay.textContent = `${UIText.availableSkillPoints}: ${player.skillPointsAvailable}`;
                 this.skillListContainer.innerHTML = ''; // Clear previous list

                 Object.keys(SkillData).forEach(skillId => {
                      const skill = SkillData[skillId];
                      const entryEl = document.createElement('div');
                      entryEl.classList.add('skill-entry');

                      const learned = player.skillsLearned.has(skillId);
                      const canAfford = player.skillPointsAvailable >= skill.skillPointCost;
                      const levelMet = player.stats.level >= skill.unlockLevel;
                      const canUnlock = !learned && canAfford && levelMet;

                      entryEl.classList.toggle('locked', !learned && !canUnlock);
                      entryEl.classList.toggle('can-unlock', canUnlock);

                      let requirements = `${UIText.requiresLevel}: ${skill.unlockLevel}`;
                      if(!learned) requirements += `, ${UIText.skillPointCost}: ${skill.skillPointCost}`;

                      let actionsHTML = '';
                       if (learned) {
                            actionsHTML = `<span class="${learned ? 'skill-unlocked-text' : ''}">${learned ? '已学习' : ''}</span>`;
                             // Add assign buttons if learned
                            actionsHTML += `<div style="margin-top: 5px;">`;
                            for(let i=0; i<player.skillSlots.length; i++){
                                 const isAssigned = player.skillSlots[i] === skillId;
                                 actionsHTML += `<button class="skill-assign-button" data-skill-id="${skillId}" data-slot-index="${i}" ${isAssigned ? 'disabled' : ''}>${UIText.assignTo} ${i+1}</button>`;
                            }
                           // Add unassign button if currently assigned
                           const assignedSlotIndex = player.skillSlots.indexOf(skillId);
                           if(assignedSlotIndex !== -1){
                                actionsHTML += `<button class="skill-unassign-button" data-slot-index="${assignedSlotIndex}" style="background-color:#a44;">${UIText.removeSlot} ${assignedSlotIndex+1}</button>`;
                           }
                            actionsHTML += `</div>`;

                       } else if (canUnlock) {
                            actionsHTML = `<button class="skill-unlock-button" data-skill-id="${skillId}">${UIText.unlock}</button>`;
                       } else {
                           // Cannot unlock yet, maybe show reason? (Level or Points)
                           let reason = !levelMet ? `(需等级 ${skill.unlockLevel})` : `(需 ${skill.skillPointCost} 技能点)`;
                           actionsHTML = `<span style="color:#aaa; font-size:11px;">${reason}</span>`;
                       }


                      entryEl.innerHTML = `
                           <div class="skill-header">
                                <span class="skill-name">${skill.name}</span>
                                <span class="skill-cost">${UIText.manaCost}: ${skill.mpCost} | ${UIText.cooldown}: ${skill.cooldown}s</span>
                           </div>
                           <div class="skill-description">${skill.description}</div>
                           <div class="skill-requirements">${requirements}</div>
                           <div class="skill-actions">${actionsHTML}</div>
                      `;
                       this.skillListContainer.appendChild(entryEl);
                 });

                 // Add event listeners for the new buttons
                 this.skillListContainer.querySelectorAll('.skill-unlock-button').forEach(button => {
                     button.addEventListener('click', (e) => {
                          const skillId = e.target.dataset.skillId;
                           if(player.learnSkill(skillId)){
                                this.updateSkillPanel(); // Refresh after learning
                           }
                     });
                 });
                 this.skillListContainer.querySelectorAll('.skill-assign-button').forEach(button => {
                      button.addEventListener('click', (e) => {
                           const skillId = e.target.dataset.skillId;
                           const slotIndex = parseInt(e.target.dataset.slotIndex);
                            if(player.assignSkillToSlot(skillId, slotIndex)){
                                // Optionally close skill panel after assigning?
                                // this.toggleSkillPanel();
                                this.updateSkillPanel(); // Refresh panel to update buttons
                            }
                      });
                 });
                  this.skillListContainer.querySelectorAll('.skill-unassign-button').forEach(button => {
                      button.addEventListener('click', (e) => {
                           const slotIndex = parseInt(e.target.dataset.slotIndex);
                            player.unassignSkillFromSlot(slotIndex);
                            this.updateSkillPanel(); // Refresh panel
                      });
                  });
             }

              handleSlotClick(id, type, button) {
                   if (!player) return;
                   console.log(`Slot clicked: type=${type}, id=${id}, button=${button}`); // Debug
                    if(button === 2) { // Right Click
                         if(type === 'inventory') {
                              const item = player.inventory[id];
                              if(item?.type === 'consumable') player.useItem(id);
                              else if(item?.type === 'equipment') player.equipItem(id);
                         } else if (type === 'equipment') {
                              player.unequipItem(id); // 'id' here is the slot name
                         }
                    } else if (button === 0) { // Left Click
                         // TODO: Implement item dragging/moving if desired
                          console.log("Left click on slot - Drag/Move not implemented.");
                    }
              }
              handleSlotMouseEnter(id, type) {
                   let item = null;
                   if(type === 'inventory') item = player?.inventory[id];
                   else if(type === 'equipment') item = player?.equipment[id];

                   if(item) this.showTooltip(item);
                   else this.hideTooltip();
              }
              handleSlotMouseLeave() {
                  this.hideTooltip();
              }

             // --- Tooltip Handling ---
             showTooltip(item) {
                  if (!item || !this.tooltipElement) return;
                  this.tooltipElement.innerHTML = this.generateItemTooltipHTML(item);
                  this.tooltipElement.style.display = 'block';
                  // Position tooltip near mouse - need mouse coords from event if possible,
                  // otherwise position relative to slot (less ideal)
                   // Let's update position on mouse move instead
             }
              hideTooltip() {
                  if (this.tooltipElement) this.tooltipElement.style.display = 'none';
              }
              updateTooltipPosition(mouseX, mouseY) {
                   if (!this.tooltipElement || this.tooltipElement.style.display === 'none') return;
                   const margin = 15;
                   let x = mouseX + margin;
                   let y = mouseY + margin;
                   const screenW = window.innerWidth;
                   const screenH = window.innerHeight;
                   const tipRect = this.tooltipElement.getBoundingClientRect();

                   if (x + tipRect.width > screenW) x = mouseX - tipRect.width - margin;
                   if (y + tipRect.height > screenH) y = mouseY - tipRect.height - margin;
                   x = Math.max(0, x); y = Math.max(0, y);

                   this.tooltipElement.style.left = `${x}px`;
                   this.tooltipElement.style.top = `${y}px`;
              }
             generateItemTooltipHTML(item) {
                 const rarityColor = getRarityHexColor(item.rarity);
                 let tip = `<div style="color: ${rarityColor}; font-weight: bold; margin-bottom: 5px;">${item.name}</div>`;

                 const slotText = UIText[item.slot] || item.slot || 'Unknown Slot';
                 const typeText = item.type === 'equipment' ? `${UIText.equip} (${slotText})` :
                                  item.type === 'consumable' ? `<span style="color:#DDA0DD;">${UIText.use}</span>` :
                                   item.type === 'material' ? `<span style="color:#B0B0B0;">Material</span>` : item.type;
                 tip += `<div style="font-size: 11px; color: #ccc; margin-bottom: 8px;">${typeText}</div>`;


                 if (item.stats) {
                      tip += `<div style="margin-bottom: 5px;">`;
                      for (const stat in item.stats) {
                           let sign = item.stats[stat] >= 0 ? '+' : '';
                           let statText = UIText[stat] || stat;
                           tip += `<div style="color: #FFFFFFA0;">${statText}: ${sign}${item.stats[stat]}</div>`;
                      }
                      tip += `</div>`;
                 }
                 if (item.effect) {
                     tip += `<div style="margin-bottom: 5px;">`;
                      for (const effect in item.effect) {
                           let effectText = UIText[effect] || effect;
                           tip += `Restore ${effectText}: ${item.effect[effect]}<br>`;
                      }
                      tip += `</div>`;
                 }

                 if (item.stackable) {
                      tip += `Quantity: ${item.quantity} / ${item.maxStack}<br>`;
                 }

                 tip += `<div style="margin-top: 8px; color: #B0B0B0; font-style: italic;">"${item.description || ''}"</div>`;
                 return tip;
             }

             // --- World Health Bars ---
             addWorldHealthBar(unit, isNpc = false) {
                 if (!unit || !unit.mesh) return null;
                 const barEl = document.createElement('div');
                 barEl.classList.add('health-bar-world');
                 const innerBarEl = document.createElement('div');
                 innerBarEl.classList.add('health-bar-world-inner');
                 if(isNpc) innerBarEl.classList.add('npc-health-bar-world-inner');
                 barEl.appendChild(innerBarEl);

                  // Add Name/Affix display
                  const nameEl = document.createElement('div');
                  nameEl.style.fontSize = '9px';
                  nameEl.style.color = unit.isElite ? '#ffcc00' : '#ffffff'; // Gold name for elites
                  nameEl.style.position = 'absolute';
                  nameEl.style.bottom = '6px'; // Position below the bar
                  nameEl.style.left = '50%';
                  nameEl.style.transform = 'translateX(-50%)';
                  nameEl.style.whiteSpace = 'nowrap';
                  nameEl.style.textShadow = '1px 1px 1px black';
                  nameEl.textContent = unit.name; // Will include affixes if elite
                  barEl.appendChild(nameEl); // Add name below bar

                 this.floatingTextContainer.appendChild(barEl);
                 worldHealthBars.push({ unit: unit, element: barEl, innerElement: innerBarEl, nameElement: nameEl }); // Store name element too
                 return barEl;
             }
              removeWorldHealthBar(unit) {
                   const index = worldHealthBars.findIndex(wb => wb.unit === unit);
                   if (index > -1) {
                        const barData = worldHealthBars[index];
                        if (barData.element.parentNode) {
                             barData.element.parentNode.removeChild(barData.element);
                        }
                        worldHealthBars.splice(index, 1);
                   }
              }
              updateWorldHealthBars() {
                   worldHealthBars.forEach(barData => {
                       const unit = barData.unit;
                       if (!unit || !unit.mesh || !unit.stats || !unit.baseStats || unit.state === 'dead') {
                           barData.element.style.display = 'none'; return;
                       }
                       if (unit.stats.hp < unit.baseStats.maxHP || unit.isElite) { // Always show for elites
                           const hpPercent = (unit.baseStats.maxHP > 0 ? unit.stats.hp / unit.baseStats.maxHP : 0) * 100;
                           barData.innerElement.style.width = `${hpPercent}%`;
                            // Update name text in case it changes (e.g. target name) - only if needed
                            // barData.nameElement.textContent = unit.name;

                           const screenPos = unit.worldPos2D; // Use cached position
                           const barYOffset = -unit.size * TILE_SIZE * 0.15; // Adjust offset as needed
                            const finalY = screenPos.y + barYOffset;

                           if (screenPos.x < -50 || screenPos.x > window.innerWidth + 50 || screenPos.y < -50 || screenPos.y > window.innerHeight + 50) {
                               barData.element.style.display = 'none';
                           } else {
                               barData.element.style.left = `${screenPos.x}px`;
                               barData.element.style.top = `${finalY}px`;
                               barData.element.style.display = 'block';
                           }
                       } else {
                           barData.element.style.display = 'none'; // Hide if full health and not elite
                       }
                   });
               }


             showGameOverScreen() {
                  this.gameOverScreen.classList.add('visible');
             }
              hideGameOverScreen() {
                   this.gameOverScreen.classList.remove('visible');
              }
             update() { this.updateWorldHealthBars(); this.updateSkillBar(); /* Update cooldowns visually */ }
        }

        // =============================================
        // --- Main Game Logic ---
        // =============================================
        console.log("载入: 主逻辑");

        function init() {
            try {
                console.log("游戏初始化开始...");
                scene = new THREE.Scene(); scene.background = new THREE.Color(0x101015); scene.fog = new THREE.Fog(0x101015, TILE_SIZE * 15, TILE_SIZE * 35);
                const aspect = window.innerWidth / window.innerHeight; camera = new THREE.PerspectiveCamera(50, aspect, 0.1, TILE_SIZE * 100); camera.position.set(0, TILE_SIZE * 10, TILE_SIZE * 8); camera.lookAt(0, 0, 0);
                renderer = new THREE.WebGLRenderer({ antialias: true }); renderer.setSize(window.innerWidth, window.innerHeight); renderer.shadowMap.enabled = true; renderer.shadowMap.type = THREE.PCFSoftShadowMap; document.body.appendChild(renderer.domElement);
                raycaster = new THREE.Raycaster(); mouseNDC = new THREE.Vector2();
                const ambientLight = new THREE.AmbientLight(0x404060, 1.5); scene.add(ambientLight); const directionalLight = new THREE.DirectionalLight(0xffeedd, 1.8); directionalLight.position.set(TILE_SIZE * 5, TILE_SIZE * 15, TILE_SIZE * 10); directionalLight.castShadow = true; directionalLight.shadow.mapSize.width = 2048; directionalLight.shadow.mapSize.height = 2048; directionalLight.shadow.camera.near = 0.5; directionalLight.shadow.camera.far = TILE_SIZE * 50; directionalLight.shadow.camera.left = -MapSettings.wildernessWidth * TILE_SIZE * 0.6; directionalLight.shadow.camera.right = MapSettings.wildernessWidth * TILE_SIZE * 0.6; directionalLight.shadow.camera.top = MapSettings.wildernessHeight * TILE_SIZE * 0.6; directionalLight.shadow.camera.bottom = -MapSettings.wildernessHeight * TILE_SIZE * 0.6; scene.add(directionalLight);
                const groundGeometry = new THREE.PlaneGeometry(MapSettings.wildernessWidth * TILE_SIZE * 2, MapSettings.wildernessHeight * TILE_SIZE * 2); const groundMaterial = new THREE.MeshStandardMaterial({ color: 0x222222, visible: false }); groundPlane = new THREE.Mesh(groundGeometry, groundMaterial); groundPlane.rotation.x = -Math.PI / 2; groundPlane.position.y = -0.1; groundPlane.userData.type = 'Ground'; scene.add(groundPlane);
                uiManager = new UIManager();
                console.log("生成初始地图..."); villageMap = new GameMap(MapSettings.villageWidth, MapSettings.villageHeight, true); wildernessMap = new GameMap(MapSettings.wildernessWidth, MapSettings.wildernessHeight, false);
                console.log("创建玩家..."); let startPos = villageMap?.entryPoint ?? new THREE.Vector3(0, 0, TILE_SIZE * 2); player = new Player(startPos.x, startPos.z); player.healthBarElement = uiManager.addWorldHealthBar(player);
                npcs.length = 0; currentMap = villageMap; gameState = 'village'; switchMap(villageMap, player.pos);
                centerCameraOnPlayer(true);
                if (uiManager) { uiManager.addMessage(UIText.welcome, getRarityHexColor('rare'), 5000); uiManager.addMessage("点击屏幕启用声音", '#cccc88', 10000); }
                if (player) { const hpPot = new Item('hp_potion_small', 5); if(!hpPot.invalid) player.pickupItem({ item: hpPot }); const sword = new Item('rusty_sword'); if(!sword.invalid) player.pickupItem({ item: sword }); const armor = new Item('leather_armor'); if(!armor.invalid) player.pickupItem({ item: armor }); uiManager?.updateInventory(); uiManager?.updateEquipment(); }
                setupSounds();
                window.addEventListener('resize', onWindowResize); window.addEventListener('keydown', onKeyDown); window.addEventListener('keyup', onKeyUp); renderer.domElement.addEventListener('mousedown', onMouseDown); renderer.domElement.addEventListener('mousemove', onMouseMove); renderer.domElement.addEventListener('contextmenu', (e) => e.preventDefault());
                console.log("游戏初始化完毕. 初始状态:", gameState); uiManager?.hideLoading(); animate();
            } catch (error) { console.error("初始化失败:", error); uiManager?.showError("初始化失败! 请检查控制台。"); }
        }

        // --- Web Audio API Sound Functions ---
        function setupSounds() { /* ... (same Web Audio setup) ... */ try { audioContext = new (window.AudioContext || window.webkitAudioContext)(); if (!audioContext) { console.warn("Web Audio API not supported."); return; } masterGain = audioContext.createGain(); masterGain.gain.setValueAtTime(masterVolume, audioContext.currentTime); masterGain.connect(audioContext.destination); const soundDefs = { playerAttack: { type: 'sine', freq: 330 }, playerHit: { type: 'sawtooth', freq: 165 }, monsterHit: { type: 'square', freq: 220 }, pickupItem: { type: 'triangle', freq: 880 }, levelUp: { type: 'sine', freq: 660 }, equipItem: { type: 'sine', freq: 440 }, useItem: { type: 'triangle', freq: 523 }, openInventory: { type: 'sine', freq: 494 }, closeInventory: { type: 'sine', freq: 466 }, invalidAction: { type: 'sawtooth', freq: 110 }, playerDeath: { type: 'sawtooth', freq: 82 }, monsterAttackRanged: { type: 'square', freq: 294 }, npcInteract: { type: 'triangle', freq: 587 } }; for (const name in soundDefs) { const def = soundDefs[name]; const osc = audioContext.createOscillator(); const gainNode = audioContext.createGain(); osc.type = def.type; osc.frequency.setValueAtTime(def.freq, audioContext.currentTime); gainNode.gain.setValueAtTime(0, audioContext.currentTime); osc.connect(gainNode); gainNode.connect(masterGain); osc.start(); soundOscillators[name] = osc; soundGains[name] = gainNode; } console.log("Web Audio声音已设置。"); } catch (e) { console.error("设置Web Audio失败:", e); audioContext = null; } }
        function playSound(soundName, duration = 0.1, volume = 0.8) { /* ... (same Web Audio play) ... */ if (!audioContext || !soundGains[soundName] || !audioInitialized) return; const gainNode = soundGains[soundName]; const now = audioContext.currentTime; const peakVol = volume; gainNode.gain.cancelScheduledValues(now); gainNode.gain.setValueAtTime(gainNode.gain.value, now); gainNode.gain.linearRampToValueAtTime(peakVol, now + 0.01); gainNode.gain.linearRampToValueAtTime(0, now + duration + 0.1); }
        function initializeAudio() { /* ... (same Web Audio init) ... */ if (!audioContext) { console.warn("无法初始化声音，AudioContext 不可用。"); return; } if (!audioInitialized && audioContext.state === 'suspended') { audioContext.resume().then(() => { console.log("AudioContext已恢复。"); audioInitialized = true; if(uiManager) uiManager.addMessage("声音已启用", "#afc", 1500); }).catch(e => console.error("AudioContext恢复错误:", e)); } else if (audioContext.state === 'running') { audioInitialized = true; } }

        function spawnNpcsForMap(map) { /* ... (same logic using map.npcSpawnPoints) ... */ npcs.forEach(npc => npc.dispose()); npcs.length = 0; intersectableUnits.splice(0, intersectableUnits.length, ...intersectableUnits.filter(m => !(m.userData.gameObject instanceof Npc))); if (!map || !map.npcSpawnPoints || map.npcSpawnPoints.length === 0) { console.log("当前地图没有NPC出生点。"); return; } const npcTypesToSpawn = map.isVillage ? Object.keys(NpcData) : ['villager_guard']; console.log(`为地图 (${map.isVillage ? '村庄' : '野外'}) 生成NPCs... 类型: ${npcTypesToSpawn.join(', ')}`); let npcIndex = 0; map.npcSpawnPoints.forEach((spawnPos) => { if (spawnPos instanceof THREE.Vector3) { let npcId; if (map.isVillage) { npcId = npcTypesToSpawn[npcIndex % npcTypesToSpawn.length]; } else { npcId = 'villager_guard'; } if (npcId && NpcData[npcId]) { let newNpc = new Npc(npcId, spawnPos.x, spawnPos.z); if (newNpc && !newNpc.invalid) { npcs.push(newNpc); if(newNpc.canFight) { newNpc.healthBarElement = uiManager?.addWorldHealthBar(newNpc, true); } } npcIndex++; } } }); console.log(`生成了 ${npcs.length} 个 NPCs.`); }

        function animate() { /* ... (same main loop structure) ... */
             requestAnimationFrame(animate);
             const deltaTime = clock.getDelta();
             gameTime += deltaTime;

             if (gameState !== 'gameOver' && gameState !== 'paused') {
                 let playerMoved = false;
                 if (player && player.stats.hp > 0) {
                      const allUnits = [player, ...monsters, ...npcs];
                      playerMoved = player.update(deltaTime, allUnits, currentMap);
                      if (playerMoved) { checkMapTransition(); checkItemPickup(); }
                 }

                 const currentUnits = [player, ...monsters, ...npcs]; // Units for monster update checks
                 for (let i = monsters.length - 1; i >= 0; i--) { // Iterate backwards for safe removal
                     const monster = monsters[i];
                     if (monster && !monster.invalid) {
                          if(monster.state !== 'dead') monster.update(deltaTime, player, npcs, currentMap);
                          // Optionally remove dead monsters after some time?
                     } else { monsters.splice(i, 1); }
                 }

                 npcs.forEach(npc => { if (npc && npc.state !== 'dead') npc.update(deltaTime, monsters, player, currentMap); });

                 const allUnitsForProj = [player, ...monsters, ...npcs];
                 for (let i = projectiles.length - 1; i >= 0; i--) { if (!projectiles[i]?.update(deltaTime, allUnitsForProj, currentMap)) projectiles.splice(i, 1); }

                 for (let i = worldItems.length - 1; i >= 0; i--) { const item = worldItems[i]; if(item && !item.invalid) { item.update(); if(item.isExpired()) worldItems.splice(i,1); } else { worldItems.splice(i, 1); } }

                 if (gameState === 'wilderness') spawnMonsters();
             }

             updateCamera(deltaTime);
             uiManager?.update();
             renderer.render(scene, camera);
         }

        function updateCamera(deltaTime) {
             if (!player || !player.pos) return;
             // Target slightly behind the player from the camera's angle
             const cameraOffset = new THREE.Vector3(0, TILE_SIZE * 10, TILE_SIZE * 8); // Consistent offset from origin (like initial pos)
             const targetCamPos = player.pos.clone().add(cameraOffset);

              // Smooth interpolation
             const lerpFactor = 1.0 - Math.pow(0.02, deltaTime); // Smoother lerp based on delta time
             camera.position.lerp(targetCamPos, lerpFactor);

              // Always look at the player's position (or slightly in front?)
              const lookAtPos = player.pos.clone();
              // Optional: look slightly ahead based on movement? Simpler to just look at player.
             camera.lookAt(lookAtPos);

             // Map boundary clamping could be added here if needed, but perspective makes it tricky.
        }
        function centerCameraOnPlayer(immediate = false) {
             if (!player || !player.pos) return;
              const cameraOffset = new THREE.Vector3(0, TILE_SIZE * 10, TILE_SIZE * 8);
              const targetCamPos = player.pos.clone().add(cameraOffset);
              if (immediate) {
                   camera.position.copy(targetCamPos);
              } else {
                   // Just set target for lerp (handled by updateCamera)
                    // Maybe force a larger lerp step?
                     camera.position.lerp(targetCamPos, 0.5); // Faster lerp
              }
               camera.lookAt(player.pos);
        }
        function checkMapTransition() {
             if (!player || !player.pos || !currentMap) return;

             if (currentMap.isVillage && currentMap.isOnExit(player.pos.x, player.pos.z)) {
                  if (wildernessMap?.entryPoint) {
                      switchMap(wildernessMap, wildernessMap.entryPoint);
                      if (uiManager) uiManager.addMessage(UIText.leaveVillage, '#ffb464', 3000);
                  } else { console.error("Wilderness invalid!"); }
             } else if (!currentMap.isVillage && currentMap.isOnVillageEntrance(player.pos.x, player.pos.z)) {
                  if (villageMap?.entryPoint) {
                       switchMap(villageMap, villageMap.entryPoint);
                       if (uiManager) uiManager.addMessage(UIText.enterVillage, '#96c8ff', 3000);
                  } else { console.error("Village invalid!"); }
             }
        }
		
		
        function switchMap(newMap, playerSpawnPoint) { /* ... (same logic, calls spawnNpcsForMap) ... */ if (!newMap || !playerSpawnPoint) { console.error("切换地图失败."); return; } console.log(`切换地图到 ${newMap.isVillage ? '村庄' : '野外'}`); if (currentMap && currentMap !== newMap) { currentMap.dispose(); } projectiles.forEach(p => p.dispose()); projectiles.length = 0; worldItems.forEach(i => i.dispose()); worldItems.length = 0; monsters.forEach(m => m.dispose()); monsters.length = 0; visualEffects.length = 0; worldHealthBars.forEach(wb => { if(wb.element.parentNode) wb.element.parentNode.removeChild(wb.element); }); worldHealthBars.length = 0; currentMap = newMap; gameState = currentMap.isVillage ? 'village' : 'wilderness'; spawnNpcsForMap(currentMap); if (player?.pos) { player.pos.copy(playerSpawnPoint); player.pos.y = player.size * 0.5; if(player.mesh) player.mesh.position.copy(player.pos); player.targetMovePos = null; player.targetEnemy = null; player.isMoving = false; if (!worldHealthBars.some(wb => wb.unit === player)) { player.healthBarElement = uiManager?.addWorldHealthBar(player); } } centerCameraOnPlayer(true); console.log("地图切换完毕."); }
        function spawnMonsters() { /* ... (same logic, uses Monster constructor which now handles elites) ... */ if (!currentMap || currentMap.isVillage || gameState !== 'wilderness' || !player?.pos) return; if (typeof MonsterData === 'undefined' || typeof Monster === 'undefined') return; const now = gameTime; if (now - lastMonsterSpawnTime > MapSettings.monsterSpawnInterval / 1000.0) { lastMonsterSpawnTime = now; let aliveMonsters = monsters.filter(m => m && m.state !== 'dead').length; if (aliveMonsters < MapSettings.maxMonsters) { const spawnPoint = currentMap.getRandomSpawnPoint(player.pos, MapSettings.monsterSpawnCheckRadius ** 2); if (spawnPoint) { let tooClose = monsters.some(m => m?.mesh && m.state !== 'dead' && distSqXZ(spawnPoint, m.pos) < (TILE_SIZE * 1.5)**2); if (!tooClose) { const monsterIds = Object.keys(MonsterData); if (monsterIds.length > 0) { const randomMonsterId = randomFromArray(monsterIds); if (randomMonsterId) { let newMonster = new Monster(randomMonsterId, spawnPoint.x, spawnPoint.z); if (newMonster && !newMonster.invalid) { monsters.push(newMonster); newMonster.healthBarElement = uiManager?.addWorldHealthBar(newMonster); } } } } } } } }
         function checkItemPickup() {
             if (!player?.pos || !worldItems || worldItems.length === 0) return;
             const pickupRadiusSq = player.pickupRadiusSq;

             for (let i = worldItems.length - 1; i >= 0; i--) {
                  const droppedItem = worldItems[i];
                  if (!droppedItem || !droppedItem.mesh || droppedItem.invalid) continue;

                  if (distSqXZ(player.pos, droppedItem.pos) < pickupRadiusSq) {
                       if (player.pickupItem(droppedItem)) { // pickupItem handles UI messages etc.
                            droppedItem.dispose(); // Remove mesh, mark invalid
                            worldItems.splice(i, 1); // Remove from array
                       } else {
                            // Pickup failed (inventory full)
                       }
                  }
             }
         }
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
             uiManager?.calculateLayout(); // Adjust HTML UI layout
        }
		
		
        function onKeyDown(event) {
            const key = event.key.toLowerCase();
             keysPressed[key] = true;

             if (gameState === 'gameOver') { if (key === 'r') { restartGame(); } return; }

             // --- UI Toggles ---
             if (key === 'i') uiManager?.toggleInventory();
             if (key === 'n') uiManager?.toggleSkillPanel(); // 'N' for skills panel
             if (event.key === 'Escape') { // Use event.key for Escape
                 if (uiManager?.showInventory) uiManager.toggleInventory();
                 else if (uiManager?.showSkills) uiManager.toggleSkillPanel();
                 // Could add Pause menu toggle here
             }

             // --- Skill Usage ---
             if (['1', '2', '3', '4'].includes(key)) {
                 const slotIndex = parseInt(key) - 1;
                 player?.useSkill(slotIndex);
             }

             // --- Debug Keys ---
             if (key === 'l') { if (player?.stats) player.gainXP(player.currentStats.xpToNextLevel - player.stats.xp + 1); }
             if (key === 'h') { if (player?.stats) { player.stats.hp = player.currentStats.maxHP; player.stats.mp = player.currentStats.maxMP; uiManager?.addFloatingText("++MAX++", player.pos, 'lime', 1.0, 18); uiManager?.updateHUD();} }
             if (key === 'k') { let nearest = monsters.filter(m=>m?.mesh && m.state!=='dead').sort((a,b)=>distSqXZ(player.pos,a.pos)-distSqXZ(player.pos,b.pos))[0]; if(nearest) nearest.takeDamage(99999, player); }
             if (key === 't') { if(villageMap?.entryPoint) { if(currentMap !== villageMap) switchMap(villageMap, villageMap.entryPoint); else { player.pos.copy(villageMap.entryPoint); player.pos.y=player.size*0.5; if(player.mesh)player.mesh.position.copy(player.pos); player.targetMovePos = null; player.targetEnemy = null; player.isMoving = false; centerCameraOnPlayer(true); } } }
             if (key === 'g') { const ids = Object.keys(ItemData); if(ids.length > 0){ const item = new Item(randomFromArray(ids)); if(!item.invalid) player.pickupItem({item: item}); } }
              if (key === 'p') { // Debug: Add skill point
                  if(player) { player.skillPointsAvailable++; console.log("Added 1 skill point."); uiManager?.updateSkillPanel();}
              }
        }
        function onKeyUp(event) { keysPressed[event.key.toLowerCase()] = false; }
        function onMouseMove(event) {
             // Update mouse NDC coordinates for raycasting
             mouseNDC.x = (event.clientX / window.innerWidth) * 2 - 1;
             mouseNDC.y = -(event.clientY / window.innerHeight) * 2 + 1;

              // Update tooltip position if it's visible
              uiManager?.updateTooltipPosition(event.clientX, event.clientY);

              // TODO: Add hover effects? (Highlight monster/item under cursor)
        }
		
		
        function onMouseDown(event) {
             if (!audioInitialized) initializeAudio(); // Enable audio on first click
             if (gameState === 'gameOver') return;

             // Check if click is on an HTML UI element (handled by element's listeners)
             // We only process clicks that reach the canvas.

             // Update Raycaster
             raycaster.setFromCamera(mouseNDC, camera);

              // Objects to check for intersection (Order matters!)
              // 1. Units (Monsters, NPCs, Items)
              // 2. Ground Plane
              const intersectsUnits = raycaster.intersectObjects(intersectableUnits);
              let clickedObject = null;

              if (intersectsUnits.length > 0) {
                   // Find the closest intersectable unit
                   const closestUnitIntersect = intersectsUnits[0];
                   clickedObject = closestUnitIntersect.object.userData.gameObject; // Get our game object back

                   if (clickedObject) {
                        console.log("Clicked on:", clickedObject.name || clickedObject.item?.name);
                        if (clickedObject instanceof Monster) {
                             player?.setAttackTarget(clickedObject);
                             return; // Handled
                        } else if (clickedObject instanceof Npc && currentMap.isVillage) {
                             const distSq = distSqXZ(player.pos, clickedObject.pos);
                             const interactDistSq = (TILE_SIZE * 2.0)**2; // Interaction range
                              if (distSq < interactDistSq) {
                                   clickedObject.interact(player);
                              } else {
                                   player?.moveTo(clickedObject.pos); // Move closer to interact
                              }
                              return; // Handled
                        } else if (clickedObject instanceof DroppedItem) {
                             const distSq = distSqXZ(player.pos, clickedObject.pos);
                             if (distSq < player.pickupRadiusSq) {
                                   if (player.pickupItem(clickedObject)) { // Try direct pickup
                                        clickedObject.dispose(); // Remove mesh etc.
                                        const index = worldItems.indexOf(clickedObject);
                                        if(index > -1) worldItems.splice(index, 1);
                                   }
                             } else {
                                  player?.moveTo(clickedObject.pos); // Move closer to pickup
                             }
                             return; // Handled
                        }
                   }
              }

             // If no unit was clicked, check for ground click to move
              const intersectsGround = raycaster.intersectObject(groundPlane);
              if (intersectsGround.length > 0) {
                   const intersectionPoint = intersectsGround[0].point;
                   // Check if the target point is walkable on the map grid
                   if (currentMap && !currentMap.isObstacle(intersectionPoint.x, intersectionPoint.z) && !currentMap.isOutsideBounds(intersectionPoint.x, intersectionPoint.z)) {
                        player?.moveTo(intersectionPoint);
                   } else {
                         playSound('invalidAction'); // Clicked unwalkable ground
                   }
                   return; // Handled
              }

             // Clicked on empty space or unhandled object
             console.log("Clicked empty space.");

        }
		
        function restartGame() {
             console.log("Restarting game...");
             uiManager?.hideGameOverScreen();

             // 1. Clear existing game objects & resources
             projectiles.forEach(p => p.dispose()); projectiles.length = 0;
             worldItems.forEach(i => i.dispose()); worldItems.length = 0;
             monsters.forEach(m => m.dispose()); monsters.length = 0;
              npcs.forEach(n => n.dispose()); npcs.length = 0;
               visualEffects.length = 0;
              worldHealthBars.forEach(wb => { if(wb.element.parentNode) wb.element.parentNode.removeChild(wb.element); }); worldHealthBars.length = 0;
              if (player) { player.mesh && scene.remove(player.mesh); player = null; } // Remove player mesh

             // 2. Dispose current map resources
              if (currentMap) { currentMap.dispose(); }
              villageMap = null; wildernessMap = null; currentMap = null;

             // 3. Reset timers and state
             lastMonsterSpawnTime = 0;
             gameTime = 0;
             audioInitialized = false; // Require new click for audio

             // 4. Re-initialize (like setup)
             intersectableUnits.length = 0; // Clear intersectable array

             console.log("Re-generating maps...");
             villageMap = new GameMap(MapSettings.villageWidth, MapSettings.villageHeight, true);
             wildernessMap = new GameMap(MapSettings.wildernessWidth, MapSettings.wildernessHeight, false);

             console.log("Re-creating player...");
             let startPos = villageMap?.entryPoint ?? new THREE.Vector3(0, 0, TILE_SIZE * 2);
             player = new Player(startPos.x, startPos.z);
              player.healthBarElement = uiManager.addWorldHealthBar(player);

             console.log("Re-spawning NPCs...");
             spawnInitialNpcs();

             // 5. Reset map and state
             currentMap = villageMap;
             gameState = 'village';
             switchMap(villageMap, player.pos); // Re-setup the map display and player pos

             // 6. Reset UI elements
			uiManager?.hideGameOverScreen();
              // Give starting items again
              if (player) {
                   const hpPot = new Item('hp_potion_small', 5); if(!hpPot.invalid) player.pickupItem({ item: hpPot });
                   const sword = new Item('rusty_sword'); if(!sword.invalid) player.pickupItem({ item: sword });
                   const armor = new Item('leather_armor'); if(!armor.invalid) player.pickupItem({ item: armor });
                   uiManager?.updateInventory();
              }

             console.log("Game restart complete.");
        }


        // --- Start the game ---
        init();

    </script>
</body>
</html>
