<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Diablo Clone (Three.js)</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; color: white; font-family: sans-serif; }
        canvas { display: block; }
        #ui-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none; /* Allow clicks to pass through to canvas by default */
            color: white;
            font-size: 12px;
        }
        .ui-element {
            pointer-events: auto; /* Enable pointer events for specific UI elements */
            position: absolute;
            background-color: rgba(25, 25, 25, 0.85);
            border: 1px solid rgba(180, 150, 100, 0.7);
            border-radius: 4px;
            padding: 5px;
            box-shadow: 0 0 10px rgba(0,0,0,0.5);
        }
        #hud {
            bottom: 10px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 5px;
            width: 50%;
            min-width: 300px;
            max-width: 500px;
            padding: 8px;
        }
        #bottom-bars{
             display: flex;
             justify-content: center;
             width: 100%;
             gap: 10px;
        }
        .stat-bar-container {
             flex-grow: 1;
             display: flex;
             align-items: center;
             gap: 5px;
        }
        .stat-label{
            width: 30px;
            text-align: right;
            font-size: 11px;
            color: #ddd;
        }
        .stat-bar {
            flex-grow: 1;
            height: 18px;
            background-color: rgba(50, 50, 50, 0.8);
            border-radius: 3px;
            position: relative;
            border: 1px solid #444;
            overflow: hidden; /* Ensure inner bar respects border radius */
        }
        .stat-bar-inner {
            height: 100%;
            position: absolute;
            top: 0;
            left: 0;
            border-radius: 3px;
            transition: width 0.2s ease-out;
        }
        .hp-bar { background-color: rgba(200, 40, 40, 0.9); }
        .mp-bar { background-color: rgba(80, 80, 220, 0.9); }
        .xp-bar { background-color: rgba(200, 200, 80, 0.9); height: 8px; }
        .bar-text {
            position: absolute;
            width: 100%;
            height: 100%;
            top: 0;
            left: 0;
            text-align: center;
            line-height: 18px; /* Match bar height */
            font-size: 11px;
            font-weight: bold;
            color: white;
            text-shadow: 1px 1px 1px black;
        }
        .xp-bar-text {
             line-height: 8px; font-size: 9px;
        }

        #system-messages {
            position: absolute;
            bottom: 100px; /* Above HUD */
            left: 15px;
            max-width: 40%;
            display: flex;
            flex-direction: column-reverse; /* New messages appear at bottom */
            gap: 3px;
        }
        .message {
            background-color: rgba(0,0,0,0.6);
            padding: 3px 6px;
            border-radius: 3px;
            font-size: 13px;
            opacity: 1;
            transition: opacity 0.5s ease-out;
        }
        .message.fading {
             opacity: 0;
        }

        #inventory-panel, #equipment-panel {
             display: none; /* Hidden by default */
             flex-direction: column;
             gap: 5px;
        }
        #inventory-panel.visible, #equipment-panel.visible {
             display: flex;
        }
         .panel-title {
             text-align: center;
             font-size: 16px;
             font-family: 'Georgia', serif;
             color: #e0d0b0;
             margin-bottom: 5px;
         }
         .slot-grid {
             display: grid;
             gap: 6px;
         }
         .inventory-grid {
             grid-template-columns: repeat(4, 45px); /* Match JS config */
         }
         .equipment-grid {
              grid-template-columns: 45px 1fr; /* Slot and Label */
              align-items: center;
         }
         .item-slot {
            width: 45px;
            height: 45px;
            background-color: rgba(40, 40, 40, 0.9);
            border: 1px solid #666;
            border-radius: 4px;
            position: relative;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
         }
         .item-slot:hover {
             border-color: #aaa;
         }
         .item-icon { /* Placeholder for actual icon */
            width: 70%;
            height: 70%;
            border-radius: 3px;
            background-color: grey; /* Default */
            position:relative; /* For glow */
            box-shadow: inset 0 0 5px rgba(0,0,0,0.5);
         }
         .item-icon::before { /* Rarity Glow */
              content: '';
              position: absolute;
              top: -3px; left: -3px; right: -3px; bottom: -3px;
              border-radius: 5px;
              box-shadow: 0 0 5px 2px transparent;
              opacity: 0.7;
         }
         .item-icon.common::before { box-shadow: 0 0 5px 2px transparent; }
         .item-icon.uncommon::before { box-shadow: 0 0 7px 3px #00FF00; }
         .item-icon.rare::before { box-shadow: 0 0 8px 3px #0070FF; }
         .item-icon.legendary::before { box-shadow: 0 0 10px 4px #A335EE; }

         .icon-consumable-hp { background-color: #f55; }
         .icon-consumable-mp { background-color: #55f; }
         .icon-equipment-weapon { background: linear-gradient(45deg, #aaa, #ddd); width: 30%; height: 80%;}
         .icon-equipment-armor { background-color: #bbb; width: 80%; height: 80%;}
         .icon-equipment-helmet { background-color: #aaa; border-radius: 50% 50% 0 0; width: 70%; height: 60%; align-self: flex-start; margin-top: 15%;}
         .icon-equipment-boots { background-color: #986; width: 60%; height: 50%; align-self: flex-end; margin-bottom: 10%;}
         .icon-material { background-color: #999; border-radius: 50%;}

         .item-quantity {
            position: absolute;
            bottom: 2px;
            right: 4px;
            font-size: 11px;
            font-weight: bold;
            color: white;
            text-shadow: 1px 1px 1px black;
         }
         .slot-label {
            font-size: 11px;
            color: #bbb;
            padding-left: 5px;
         }

         #tooltip {
            position: absolute;
            display: none; /* Hidden by default */
            max-width: 250px;
            background-color: rgba(15, 15, 15, 0.95);
            border: 1px solid #b4b478;
            border-radius: 4px;
            padding: 8px 12px;
            font-size: 13px;
            line-height: 1.4;
            white-space: pre-wrap; /* Respect newlines */
            z-index: 100;
            pointer-events: none; /* Tooltip doesn't block clicks */
         }

         #floating-text-container {
             position: absolute;
             top: 0; left: 0;
             width: 100%; height: 100%;
             overflow: hidden;
             pointer-events: none;
             z-index: 50;
         }
         .floating-text {
             position: absolute;
             font-size: 16px;
             font-weight: bold;
             text-shadow: 1px 1px 2px black;
             white-space: nowrap;
             transform: translateX(-50%); /* Center horizontally */
             transition: transform 1s ease-out, opacity 1s ease-out;
         }

        .health-bar-world {
            position: absolute;
            width: 40px; /* Fixed width for simplicity */
            height: 5px;
            background-color: rgba(80, 0, 0, 0.7);
            border: 1px solid black;
            border-radius: 2px;
            transform: translateX(-50%); /* Center */
            overflow: hidden;
        }
        .health-bar-world-inner {
            height: 100%;
            background-color: #ff0000;
            transition: width 0.2s linear;
        }
         .npc-health-bar-world-inner { background-color: #00cc00; } /* Green for NPCs */

        #game-over-screen {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background-color: rgba(0,0,0,0.8);
            display: none; /* Hidden by default */
            justify-content: center;
            align-items: center;
            flex-direction: column;
            text-align: center;
            z-index: 200;
            pointer-events: auto;
        }
        #game-over-screen.visible {
            display: flex;
        }
        #game-over-screen h1 {
             font-size: 72px;
             color: #c02020;
             font-family: 'Georgia', serif;
             margin-bottom: 20px;
        }
        #game-over-screen p {
             font-size: 24px;
             color: #ccc;
        }
        #loading-screen {
             position: absolute;
             top: 0; left: 0; width: 100%; height: 100%;
             background-color: #050505;
             display: flex;
             justify-content: center;
             align-items: center;
             z-index: 500;
             font-size: 24px;
        }
        #error-screen {
             position: absolute;
             top: 0; left: 0; width: 100%; height: 100%;
             background-color: #300000;
             display: none; /* Hidden by default */
             justify-content: center;
             align-items: center;
             z-index: 500;
             font-size: 24px;
             color: red;
             text-align: center;
             padding: 20px;
        }
        #error-screen.visible { display: flex; }

    </style>
</head>
<body>
    <!-- UI Overlay Container -->
    <div id="ui-overlay">
        <!-- Heads Up Display (HUD) -->
        <div id="hud" class="ui-element">
            <div id="bottom-bars">
                <div class="stat-bar-container">
                     <span class="stat-label">HP</span>
                    <div id="hp-bar" class="stat-bar">
                        <div id="hp-bar-inner" class="stat-bar-inner hp-bar"></div>
                        <div id="hp-bar-text" class="bar-text">100/100</div>
                    </div>
                </div>
                <div class="stat-bar-container">
                    <div id="mp-bar" class="stat-bar">
                        <div id="mp-bar-inner" class="stat-bar-inner mp-bar"></div>
                        <div id="mp-bar-text" class="bar-text">50/50</div>
                    </div>
                    <span class="stat-label" style="text-align:left;">MP</span>
                </div>
            </div>
             <div class="stat-bar-container" style="width:100%;">
                  <!-- <span class="stat-label">XP</span> -->
                  <div id="xp-bar" class="stat-bar xp-bar">
                       <div id="xp-bar-inner" class="stat-bar-inner xp-bar"></div>
                       <div id="xp-bar-text" class="bar-text xp-bar-text">Lvl 1 (0/100)</div>
                  </div>
             </div>
              <!-- Skill bar placeholder -->
             <div id="skill-bar" style="display: flex; gap: 5px; margin-top: 8px;">
                  <div class="item-slot" style="width:40px; height:40px;"><span style="font-size:10px;">[LMB]</span></div>
                  <div class="item-slot" style="width:40px; height:40px;"><span style="font-size:10px;">[RMB]</span></div>
                  <div class="item-slot" style="width:40px; height:40px;"><span style="font-size:10px;">[1]</span></div>
                  <div class="item-slot" style="width:40px; height:40px;"><span style="font-size:10px;">[2]</span></div>
                  <div class="item-slot" style="width:40px; height:40px;"><span style="font-size:10px;">[3]</span></div>
                  <div class="item-slot" style="width:40px; height:40px;"><span style="font-size:10px;">[4]</span></div>
             </div>
        </div>

        <!-- System Messages Area -->
        <div id="system-messages">
            <!-- Messages dynamically added here -->
        </div>

        <!-- Inventory Panel -->
        <div id="inventory-panel" class="ui-element">
            <div class="panel-title">Inventory</div>
            <div id="inventory-grid" class="slot-grid inventory-grid">
                <!-- Inventory slots dynamically added here -->
            </div>
        </div>

        <!-- Equipment Panel -->
        <div id="equipment-panel" class="ui-element">
            <div class="panel-title">Equipment</div>
            <div id="equipment-grid" class="slot-grid equipment-grid">
                <!-- Equipment slots dynamically added here -->
            </div>
        </div>

        <!-- Tooltip -->
        <div id="tooltip">Tooltip text goes here</div>

        <!-- Container for floating text / world health bars -->
        <div id="floating-text-container">
            <!-- Floating text elements dynamically added here -->
        </div>
    </div>

     <!-- Loading Screen -->
     <div id="loading-screen">Loading...</div>
     <!-- Error Screen -->
     <div id="error-screen">An Error Occurred! Check Console.</div>
     <!-- Game Over Screen -->
     <div id="game-over-screen">
         <h1>YOU DIED</h1>
         <p>Press [R] to Restart</p>
     </div>

    <!-- Three.js Library (use module type for imports) -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                 "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <!-- p5.js Sound Library (Optional, for oscillator sounds) -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.0/addons/p5.sound.min.js"></script>

    <!-- Game Script -->
    <script type="module">
        import * as THREE from 'three';
        // import { OrbitControls } from 'three/addons/controls/OrbitControls.js'; // Optional for debugging camera

        // --- Global Variables ---
        let scene, camera, renderer, raycaster, mouseNDC;
        let player;
        const monsters = [];
        const npcs = [];
        const worldItems = [];
        const projectiles = [];
        const visualEffects = []; // 3D visual effects (particle systems, etc. - simplified for now)
        const floatingTexts = []; // Manage HTML floating text elements
        const worldHealthBars = []; // Manage HTML world health bar elements

        let villageMap;
        let wildernessMap;
        let currentMap; // Reference to the currently active map object
        let mapMeshGroup; // THREE.Group to hold map meshes

        let uiManager; // Instance of UIManager (HTML version)

        // Game state management
        let gameState = 'loading'; // 'loading', 'village', 'wilderness', 'gameOver', 'paused'
        let lastMonsterSpawnTime = 0;
        let gameTime = 0; // Simple time counter

        // Input state
        const keysPressed = {};

        // Raycasting intersectables
        let groundPlane; // A single large plane for ground raycasting
        const intersectableUnits = []; // Meshes of monsters, npcs, items
        const mapObstacleMeshes = []; // Meshes representing map obstacles (used less often?)

        // Sound Variables (using p5.sound oscillators)
        const sounds = {};
        let masterVolume = 0.2;
        let audioInitialized = false;

        // --- Constants & Game Data ---
        const TILE_SIZE = 5; // Size of a tile in 3D world units
        const HALF_TILE_SIZE = TILE_SIZE / 2.0;

        console.log("Loading: gamedata.js");
        // --- Constants from gamedata.js ---
        const UIText = { hp: "HP", mp: "MP", level: "Level", xp: "XP", attack: "Attack", defense: "Defense", inventory: "Inventory", equip: "Equipment", use: "Use", drop: "Drop", pickup: "Pickup", moveTo: "Move to", attackTarget: "Attack", npcGreeting: ["Hello, adventurer!", "The village is safe, the wilds are not.", "Need something?"], enemySpotted: "Enemy spotted!", levelUp: "Level Up!", itemDropped: "Dropped", inventoryFull: "Inventory Full!", welcome: "Welcome to Sanctuary Village", leaveVillage: "Leave Village", enterVillage: "Enter Village", /* ... */ };
        const ItemData = { 'hp_potion_small': { name: "Small HP Potion", type: 'consumable', effect: { hp: 50 }, stackable: true, maxStack: 10, icon: 'consumable-hp', description: "Restores minor health.", rarity: 'common'}, 'mp_potion_small': { name: "Small MP Potion", type: 'consumable', effect: { mp: 30 }, stackable: true, maxStack: 10, icon: 'consumable-mp', description: "Restores minor mana.", rarity: 'common'}, 'rusty_sword': { name: "Rusty Sword", type: 'equipment', slot: 'weapon', stats: { attack: 3 }, icon: 'equipment-weapon', description: "A worn sword.", rarity: 'common' }, 'short_bow': { name: "Short Bow", type: 'equipment', slot: 'weapon', stats: { attack: 4 }, icon: 'equipment-weapon', description: "A simple bow.", rarity: 'common' }, 'sharp_dagger': { name: "Sharp Dagger", type: 'equipment', slot: 'weapon', stats: { attack: 5 }, icon: 'equipment-weapon', description: "Quick and sharp.", rarity: 'uncommon'}, 'glowing_staff': { name: "Glowing Staff", type: 'equipment', slot: 'weapon', stats: { attack: 4, maxMP: 20}, icon: 'equipment-weapon', description: "Glows faintly.", rarity: 'uncommon'}, 'leather_armor': { name: "Leather Armor", type: 'equipment', slot: 'armor', stats: { defense: 2 }, icon: 'equipment-armor', description: "Basic leather.", rarity: 'common' }, 'iron_helmet': { name: "Iron Helmet", type: 'equipment', slot: 'helmet', stats: { defense: 3 }, icon: 'equipment-helmet', description: "Simple head protection.", rarity: 'common'}, 'hardened_leather_boots': { name: "Hard Leather Boots", type: 'equipment', slot: 'boots', stats: { defense: 1, speed: 0.5 }, icon: 'equipment-boots', description: "Sturdy boots.", rarity: 'uncommon'}, 'magic_ring': { name: "Magic Ring", type: 'equipment', slot: 'ring', stats: { maxMP: 15 }, icon: 'equipment-ring', description: "A magical ring.", rarity: 'rare'}, 'goblin_ear': { name: "Goblin Ear", type: 'material', stackable: true, maxStack: 50, icon: 'material', description: "A goblin's ear.", rarity: 'common' }, /* ... */ };
        const MonsterData = { 'goblin': { name: "Goblin", hp: 25, mp: 0, attack: 5, defense: 1, xp: 10, speed: 2.5, attackType: 'melee', attackRange: TILE_SIZE * 0.8, aggroRange: TILE_SIZE * 6, color: 0x009600, size: TILE_SIZE * 0.6, icon: 'goblin', lootTable: [{ itemId: 'hp_potion_small', chance: 0.3 },{ itemId: 'goblin_ear', chance: 0.7 },{ itemId: 'rusty_sword', chance: 0.05 },{ itemId: 'sharp_dagger', chance: 0.02}] }, 'skeleton': { name: "Skeleton Archer", hp: 43, mp: 0, attack: 2, defense: 3, xp: 18, speed: 3.0, attackType: 'ranged', attackRange: TILE_SIZE * 7, projectileType: 'arrow', projectileSpeed: 15, projectileDamage: 6, aggroRange: TILE_SIZE * 9, color: 0xcccccc, size: TILE_SIZE * 0.7, icon: 'skeleton', lootTable: [{ itemId: 'hp_potion_small', chance: 0.2 },{ itemId: 'mp_potion_small', chance: 0.1 },{ itemId: 'leather_armor', chance: 0.08 },{ itemId: 'short_bow', chance: 0.04 }] }, 'bat': { name: "Giant Bat", hp: 20, mp: 0, attack: 4, defense: 0, xp: 8, speed: 4.5, attackType: 'melee', attackRange: TILE_SIZE * 0.6, aggroRange: TILE_SIZE * 8, color: 0x333333, size: TILE_SIZE * 0.5, icon: 'bat', lootTable: [{ itemId: 'hp_potion_small', chance: 0.15 },] } /* ... */ };
        const NpcData = { 'villager_elder': { name: "Elder", hp: 100, attack: 5, defense: 2, color: 0x4444ff, size: TILE_SIZE * 0.7, icon: 'elder', dialogue: ["May the light guide you.", "The world beyond is perilous.", "Seek the blacksmith or merchant if you need wares."], canFight: true, aggroRange: TILE_SIZE * 4, attackRange: TILE_SIZE * 1.0 }, 'villager_guard': { name: "Guard", hp: 150, attack: 15, defense: 5, color: 0x999999, size: TILE_SIZE * 0.8, icon: 'guard', dialogue: ["Halt! This is a safe village.", "I will protect this place.", "Report any suspicious activity."], canFight: true, aggroRange: TILE_SIZE * 7, attackRange: TILE_SIZE * 1.2, pursuitRangeMultiplier: 1.5 }, 'villager_farmer': { name: "Farmer", hp: 80, attack: 3, defense: 1, color: 0x8B4513, size: TILE_SIZE * 0.7, icon: 'farmer', dialogue: ["Hope for a good harvest...", "Bah, monsters are everywhere.", "Be careful out there, young one."], canFight: false } /* ... */ };
        const PlayerDefaults = { hp: 110, mp: 50, attack: 5, defense: 1, speed: 4.0, level: 1, xp: 0, xpToNextLevel: 100, attackRange: TILE_SIZE * 1.0, pickupRadius: TILE_SIZE * 1.5, inventorySize: 20, color: 0xffd700, size: TILE_SIZE * 0.7 };
        const MapSettings = { wildernessWidth: 80, wildernessHeight: 80, villageWidth: 20, villageHeight: 20, wallThickness: 1, noiseScale: 0.08, obstacleDensity: 0.1, maxMonsters: 30, monsterSpawnInterval: 4000, monsterSpawnCheckRadius: TILE_SIZE * 10, };
        const RarityColors = { common: '#FFFFFF', uncommon: '#00FF00', rare: '#0070FF', legendary: '#A335EE', default: '#FFFFFF' };
        const TILE_TYPE_FLOOR = 0;
        const TILE_TYPE_WALL = 1;
        const TILE_TYPE_EXIT = 2;
        const TILE_TYPE_WATER = 3;
        const TILE_TYPE_VILLAGE_ENTRANCE = 4;

        // --- Utility Functions ---
        console.log("Loading: utils.js");
        function distSqXZ(pos1, pos2) {
            const dx = pos1.x - pos2.x;
            const dz = pos1.z - pos2.z;
            return dx * dx + dz * dz;
        }

        function randomFromArray(arr) {
            if (!arr || arr.length === 0) return null;
            return arr[Math.floor(Math.random() * arr.length)];
        }

         // World coordinates to Screen coordinates
         function worldToScreen(vector3) {
             if (!camera) return { x: -1000, y: -1000 }; // Return off-screen if camera isn't ready

             const vector = vector3.clone();
             vector.project(camera);

             const x = (vector.x * 0.5 + 0.5) * renderer.domElement.clientWidth;
             const y = (vector.y * -0.5 + 0.5) * renderer.domElement.clientHeight;

             return { x: x, y: y };
         }

         // Get Rarity Color (returns hex string)
         function getRarityHexColor(rarity) {
             return RarityColors[rarity] || RarityColors.default;
         }
          function getRarityTHREEColor(rarity) {
              return new THREE.Color(getRarityHexColor(rarity));
         }

        // --- Item Classes ---
        console.log("Loading: item.js");
        class Item {
            constructor(itemId, quantity = 1) {
                const data = ItemData[itemId];
                if (!data) {
                    console.error("Invalid item ID:", itemId);
                    this.id = 'invalid_item'; this.name = 'Error Item'; this.type = 'error'; this.description = `Invalid ID: ${itemId}`; this.icon = 'error'; this.stackable = false; this.maxStack = 1; this.quantity = 0; this.rarity = 'common'; return;
                }
                this.id = itemId; this.name = data.name; this.type = data.type; this.description = data.description; this.icon = data.icon || 'default'; this.stackable = data.stackable || false; this.maxStack = data.maxStack || 1; this.quantity = this.stackable ? quantity : 1; this.rarity = data.rarity || 'common';
                if (this.type === 'equipment') { this.slot = data.slot; this.stats = data.stats || {}; }
                else if (this.type === 'consumable') { this.effect = data.effect || {}; }
            }

            addQuantity(amount) {
                if (!this.stackable) return 0; // Return 0 overflow if not stackable
                this.quantity += amount;
                if (this.quantity > this.maxStack) {
                    let overflow = this.quantity - this.maxStack;
                    this.quantity = this.maxStack;
                    return overflow;
                }
                return 0; // No overflow
            }

            use(target) {
                if (this.type === 'consumable' && this.quantity > 0) {
                    console.log(`${target.name} uses ${this.name}`);
                    let effectApplied = false;
                    for (const effectKey in this.effect) {
                         const maxStatKey = `max${effectKey.toUpperCase()}`;
                        if (target.stats.hasOwnProperty(effectKey) && target.currentStats.hasOwnProperty(maxStatKey)) {
                            let effectAmount = this.effect[effectKey];
                            let currentVal = target.stats[effectKey];
                            let maxVal = target.currentStats[maxStatKey];
                             let newVal = Math.min(maxVal, currentVal + effectAmount);
                             let actualEffect = newVal - currentVal;
                             if(actualEffect > 0) {
                                target.stats[effectKey] = newVal;
                                if (uiManager) uiManager.addFloatingText(`+${actualEffect}`, target.pos, 'lime');
                                effectApplied = true;
                             }
                        } else { console.warn(`Target ${target.name} missing stat '${effectKey}' or '${maxStatKey}'`); }
                    }
                    if(effectApplied){
                         this.quantity--;
                         playSound('useItem');
                         return this.quantity > 0; // Return true if quantity > 0 after use
                    }
                }
                 return this.quantity > 0; // Return true if not consumable or failed use but still exists
            }
        }

        class DroppedItem {
            constructor(item, x, z) { // Use x, z for ground position
                if (!item || item.type === 'error') {
                     console.error("Attempted DroppedItem with invalid item:", item);
                     this.invalid = true; this.item = null; this.pos = new THREE.Vector3(x, 0, z); this.mesh = null; return;
                }
                this.item = item;
                this.pos = new THREE.Vector3(x, HALF_TILE_SIZE * 0.5, z); // Position slightly above ground
                this.pickupRadiusSq = (PlayerDefaults.pickupRadius ** 2) * 0.8;
                this.creationTime = gameTime;
                this.lifespan = 60; // Seconds
                this.bobbingOffset = 0;
                this.bobbingSpeed = Math.random() * 0.05 + 0.05;
                this.rotationSpeed = Math.random() * 0.01 + 0.005;
                this.invalid = false;
                this.mesh = this.createMesh();
                 this.mesh.userData = { gameObject: this, type: 'DroppedItem' }; // Link mesh back to object
                 scene.add(this.mesh);
                 intersectableUnits.push(this.mesh);
            }

             createMesh() {
                 const geo = new THREE.BoxGeometry(TILE_SIZE * 0.2, TILE_SIZE * 0.2, TILE_SIZE * 0.2);
                 // Simple color based on rarity for now
                  const mat = new THREE.MeshStandardMaterial({
                       color: getRarityTHREEColor(this.item.rarity),
                       emissive: getRarityTHREEColor(this.item.rarity),
                       emissiveIntensity: this.item.rarity === 'common' ? 0 : 0.3,
                       metalness: 0.2,
                       roughness: 0.6
                  });
                  const mesh = new THREE.Mesh(geo, mat);
                  mesh.position.copy(this.pos);
                  mesh.castShadow = true;
                  return mesh;
             }

            isExpired() {
                return this.invalid || (gameTime - this.creationTime > this.lifespan);
            }

            update() {
                if (this.invalid || !this.mesh) return;
                 if (this.isExpired()) {
                      this.dispose();
                      return; // Needs removal
                 }

                // Bobbing and rotating
                 this.bobbingOffset = Math.sin(gameTime * this.bobbingSpeed * 100) * (TILE_SIZE * 0.1); // Use gameTime
                 this.mesh.position.y = (HALF_TILE_SIZE * 0.5) + this.bobbingOffset;
                 this.mesh.rotation.y += this.rotationSpeed;
            }

            // Call this when the item is picked up or expires
            dispose() {
                 if (this.mesh) {
                      scene.remove(this.mesh);
                      this.mesh.geometry.dispose();
                      this.mesh.material.dispose();
                       // Remove from intersectable array
                      const index = intersectableUnits.indexOf(this.mesh);
                      if (index > -1) intersectableUnits.splice(index, 1);
                 }
                 this.mesh = null;
                 this.invalid = true; // Mark as fully invalid
            }

            // No render method needed - position updated in update()
        }


        // --- Projectile Class ---
        console.log("Loading: projectile.js");
        class Projectile {
             constructor(startX, startY, startZ, targetX, targetY, targetZ, speed, damage, owner, type = 'arrow') {
                 this.pos = new THREE.Vector3(startX, startY, startZ);
                 this.targetPos = new THREE.Vector3(targetX, targetY, targetZ); // Store initial target
                 this.vel = this.targetPos.clone().sub(this.pos).normalize().multiplyScalar(speed);
                 this.damage = damage;
                 this.owner = owner; // The object that fired it (Player, Monster, Npc)
                 this.type = type;
                 this.size = TILE_SIZE * 0.3;
                 this.creationTime = gameTime;
                 this.lifespan = 5; // Seconds
                 this.collided = false;
                 this.mesh = this.createMesh();
                  this.mesh.userData = { gameObject: this, type: 'Projectile' }; // Link mesh back
                  scene.add(this.mesh);
                  // Make projectile look towards velocity
                  this.mesh.lookAt(this.pos.clone().add(this.vel));
             }

             createMesh() {
                  let geo, mat;
                  if (this.type === 'arrow') {
                       geo = new THREE.CylinderGeometry(TILE_SIZE*0.02, TILE_SIZE*0.02, this.size, 4);
                       mat = new THREE.MeshStandardMaterial({ color: 0x8B4513, roughness: 0.8 }); // Brown
                  } else { // Default magic missile
                       geo = new THREE.SphereGeometry(this.size * 0.3, 8, 8);
                       mat = new THREE.MeshStandardMaterial({ color: 0xff00ff, emissive: 0xff00ff, emissiveIntensity: 0.8, roughness: 0.5 }); // Purple
                  }
                  const mesh = new THREE.Mesh(geo, mat);
                  mesh.position.copy(this.pos);
                   // Rotate cylinder to align with Z axis initially before lookAt
                   if(this.type === 'arrow') mesh.quaternion.setFromAxisAngle(new THREE.Vector3(1,0,0), Math.PI / 2);
                  mesh.castShadow = false; // Projectiles usually don't cast shadows
                  return mesh;
             }

             update(deltaTime, allUnits, map) {
                 if (this.collided || (gameTime - this.creationTime > this.lifespan) || !this.mesh) {
                      if(!this.collided) this.dispose(); // Dispose if expired but didn't hit anything
                      return false; // Needs removal
                 }

                 // Move projectile
                 const moveDelta = this.vel.clone().multiplyScalar(deltaTime);
                 this.pos.add(moveDelta);
                 this.mesh.position.copy(this.pos);

                 // --- Collision Detection ---
                 // 1. Map Boundaries / Obstacles (Simple Check)
                 if (map.isObstacle(this.pos.x, this.pos.z) || map.isOutsideBounds(this.pos.x, this.pos.z)) {
                      this.handleCollision(null); // Hit environment
                      return false;
                 }

                 // 2. Units (Player, Monsters, NPCs)
                  const projectileRadiusSq = (this.size * 0.5)**2; // Simple bounding sphere check
                  for (const unit of allUnits) {
                      if (!unit || unit === this.owner || !unit.mesh || unit.state === 'dead' || !unit.stats || unit.stats.hp <= 0) {
                          continue; // Skip self, dead units, or invalid units
                      }

                      // Ensure unit is targetable (e.g., monster projectile hits player/npc, player hits monster)
                      const ownerIsPlayer = this.owner instanceof Player;
                      const ownerIsMonster = this.owner instanceof Monster;
                      const ownerIsNpc = this.owner instanceof Npc;
                      const unitIsPlayer = unit instanceof Player;
                      const unitIsMonster = unit instanceof Monster;
                      const unitIsNpc = unit instanceof Npc;

                      let canHit = false;
                      if (ownerIsPlayer && unitIsMonster) canHit = true;
                      if (ownerIsMonster && (unitIsPlayer || (unitIsNpc && unit.canFight))) canHit = true;
                      if (ownerIsNpc && unitIsMonster) canHit = true; // NPCs attack monsters

                      if (!canHit) continue;

                      const unitRadiusSq = (unit.size * 0.5)**2;
                      const collisionDistSq = projectileRadiusSq + unitRadiusSq; // Sum of radii squared for sphere collision

                      if (distSqXZ(this.pos, unit.pos) < collisionDistSq) {
                            // Check Y height as well? Simple check for now.
                           if (Math.abs(this.pos.y - unit.pos.y) < unit.size * 0.7) { // Check if Y levels roughly match
                                this.handleCollision(unit); // Hit a unit
                                return false; // Needs removal
                           }
                      }
                  }

                 return true; // Still active
             }

             handleCollision(target) {
                  this.collided = true;
                  if (target && typeof target.takeDamage === 'function') {
                      // console.log(`Projectile hit ${target.name}`);
                      target.takeDamage(this.damage, this.owner);
                      // Play target hit sound maybe
                  } else {
                       // Hit environment
                       // Play wall hit sound maybe
                       // Spawn spark effect
                  }
                  this.dispose();
             }

             dispose() {
                  if (this.mesh) {
                       scene.remove(this.mesh);
                       this.mesh.geometry.dispose();
                       this.mesh.material.dispose();
                       this.mesh = null;
                  }
                  this.collided = true; // Ensure it's marked for removal
             }
        }

        // --- Map Class ---
        console.log("Loading: map.js");
        class GameMap {
             constructor(widthTiles, heightTiles, isVillage = false) {
                 this.width = widthTiles;
                 this.height = heightTiles;
                 this.isVillage = isVillage;
                 this.grid = []; // 2D array storing tile types (0: floor, 1: wall, 2: exit, 3: water, 4: village entrance)
                 this.mapWidthUnits = this.width * TILE_SIZE;
                 this.mapHeightUnits = this.height * TILE_SIZE;

                 this.spawnPoints = []; // Array of Vector3 for spawn locations
                 this.exitPoint = null; // Vector3
                 this.entryPoint = null; // Vector3

                 // Materials (cached for performance)
                 this.materials = {
                     [TILE_TYPE_FLOOR]: new THREE.MeshStandardMaterial({ color: this.isVillage ? 0xA08264 : 0x326432, roughness: 0.9, metalness: 0.1 }), // Brownish / Greenish floor
                     [TILE_TYPE_WALL]: new THREE.MeshStandardMaterial({ color: this.isVillage ? 0x644628 : 0x5A5A5A, roughness: 0.8, metalness: 0.2 }), // Darker wall / Mountain grey
                     [TILE_TYPE_EXIT]: new THREE.MeshStandardMaterial({ color: 0xFFFF00, emissive: 0xAAAA00, roughness: 0.7 }), // Yellow exit marker
                     [TILE_TYPE_WATER]: new THREE.MeshStandardMaterial({ color: 0x285096, roughness: 0.3, metalness: 0.1, transparent: true, opacity: 0.7 }), // Blue water
                     [TILE_TYPE_VILLAGE_ENTRANCE]: new THREE.MeshStandardMaterial({ color: 0x00FFFF, emissive: 0x00AAAA, roughness: 0.7 }), // Cyan entrance marker
                     default: new THREE.MeshStandardMaterial({ color: 0xff00ff }) // Error magenta
                 };
                 // Instanced Mesh setup
                 this.tileGeometry = new THREE.BoxGeometry(TILE_SIZE, TILE_SIZE, TILE_SIZE); // Use cubes for tiles
                 this.tileInstances = {}; // Store instanced meshes per material type
                 this.maxInstances = this.width * this.height;

                 // Generation needs noise functions, adapt from p5 style
                 this.noiseSeed = Math.random() * 10000;
                 this.noiseDetail = { octaves: 5, falloff: 0.55 }; // Mimic p5 noiseDetail params

                 console.log(`Generating map (${this.isVillage ? 'Village' : 'Wilderness'})...`);
                 this.generateMapGrid(); // Generate the 2D grid first
                 console.log(`Generating map mesh...`);
                 this.createMapMesh(); // Then create the 3D representation
                 console.log("Map generation complete.");
             }

             // --- Perlin Noise Simulation (Basic) ---
             // Very basic pseudo-random noise, NOT Perlin. Replace with a real Perlin library if needed.
             simpleNoise(x, y) {
                  // Combine multiple layers of simple seeded random
                  const scale1 = 0.1; const scale2 = 0.3; const scale3 = 0.7;
                  const amp1 = 0.5; const amp2 = 0.3; const amp3 = 0.2;

                  const seededRandom = (seed) => {
                       let x = Math.sin(seed) * 10000;
                       return x - Math.floor(x);
                  };

                   let n1 = seededRandom(this.noiseSeed + x * scale1 + y * scale1 * 5.1);
                   let n2 = seededRandom(this.noiseSeed * 1.3 + x * scale2 + y * scale2 * 4.9);
                   let n3 = seededRandom(this.noiseSeed * 0.8 + x * scale3 + y * scale3 * 5.3);

                   return (n1 * amp1 + n2 * amp2 + n3 * amp3); // Combine layers
              }

             generateMapGrid() {
                 // Initialize grid
                 for (let y = 0; y < this.height; y++) {
                     this.grid[y] = new Array(this.width);
                 }

                 if (this.isVillage) {
                     this.generateVillageLayout();
                 } else {
                     this.generateWildernessLayout();
                 }
                 // Ensure entry/exit points are Vector3
                 if (this.exitPoint && !(this.exitPoint instanceof THREE.Vector3)) {
                      this.exitPoint = new THREE.Vector3(this.exitPoint.x, 0, this.exitPoint.y); // Convert p5 vector style if needed
                 }
                 if (this.entryPoint && !(this.entryPoint instanceof THREE.Vector3)) {
                      this.entryPoint = new THREE.Vector3(this.entryPoint.x, 0, this.entryPoint.y);
                 }
                 this.spawnPoints = this.spawnPoints.map(p => p instanceof THREE.Vector3 ? p : new THREE.Vector3(p.x, 0, p.y));
             }

             // --- Adapted Grid Generation Logic (using Math.random, Math.floor etc.) ---
             generateVillageLayout() {
                 let drunkX = Math.floor(this.width / 2);
                 let drunkY = Math.floor(this.height / 2);
                 let steps = Math.floor(this.width * this.height * 0.6);
                 let floorTile = TILE_TYPE_FLOOR;
                 let wallTile = TILE_TYPE_WALL;
                 let exitTile = TILE_TYPE_EXIT;

                 for(let y=0; y<this.height; ++y){
                      for(let x=0; x<this.width; ++x){
                           this.grid[y][x] = wallTile; // Fill with walls first
                      }
                 }

                 this.grid[drunkY][drunkX] = floorTile;
                 let wallThickness = MapSettings.wallThickness;

                 for (let i = 0; i < steps; i++) {
                     let dir = Math.floor(Math.random() * 4);
                     let nx = drunkX, ny = drunkY;
                     switch (dir) {
                         case 0: ny = Math.max(wallThickness, drunkY - 1); break;
                         case 1: nx = Math.min(this.width - 1 - wallThickness, drunkX + 1); break;
                         case 2: ny = Math.min(this.height - 1 - wallThickness, drunkY + 1); break;
                         case 3: nx = Math.max(wallThickness, drunkX - 1); break;
                     }
                     if (nx >= wallThickness && nx < this.width - wallThickness && ny >= wallThickness && ny < this.height - wallThickness) {
                           drunkX = nx; drunkY = ny;
                           this.grid[drunkY][drunkX] = floorTile;
                           if (Math.random() < 0.4) {
                               let dx = Math.floor(Math.random()*3) - 1; // -1, 0, 1
                               let dy = Math.floor(Math.random()*3) - 1;
                                if(Math.abs(dx)+Math.abs(dy) === 1){
                                     let wx = drunkX+dx; let wy = drunkY+dy;
                                     if (wx >= wallThickness && wx < this.width - wallThickness && wy >= wallThickness && wy < this.height - wallThickness) {
                                          this.grid[wy][wx] = floorTile;
                                     }
                                }
                           }
                      } else {
                            drunkX = Math.floor(Math.random() * (this.width * 0.2) + this.width * 0.4);
                            drunkY = Math.floor(Math.random() * (this.height * 0.2) + this.height * 0.4);
                            if(this.grid[drunkY]) this.grid[drunkY][drunkX] = floorTile;
                      }
                 }

                 // Create Exit
                 const exitSide = Math.floor(Math.random() * 4);
                 let exitX = Math.floor(this.width / 2);
                 let exitY = Math.floor(this.height / 2);
                 const exitWidth = 2;
                 let pathX = exitX; let pathY = exitY;

                 if (exitSide === 0) { // Top
                     exitY = wallThickness - 1;
                     while(pathY >= exitY) { if(this.grid[pathY]) this.grid[pathY][pathX] = floorTile; if(this.grid[pathY] && pathX+1 < this.width) this.grid[pathY][pathX+1] = floorTile; pathY--; }
                     for(let i = 0; i < exitWidth; i++) if(this.grid[exitY] && pathX+i < this.width) this.grid[exitY][pathX+i] = exitTile;
                     this.exitPoint = new THREE.Vector3((pathX + exitWidth/2 - this.width/2) * TILE_SIZE, 0, (exitY - 0.5 - this.height/2) * TILE_SIZE);
                     this.entryPoint = new THREE.Vector3((pathX + exitWidth/2 - this.width/2) * TILE_SIZE, 0, (exitY + 1.5 - this.height/2) * TILE_SIZE);
                 } else if (exitSide === 1) { // Right
                     exitX = this.width - wallThickness;
                     while(pathX <= exitX) { if(this.grid[pathY]) this.grid[pathY][pathX] = floorTile; if(pathY+1 < this.height && this.grid[pathY+1]) this.grid[pathY+1][pathX] = floorTile; pathX++; }
                     for(let i = 0; i < exitWidth; i++) if(pathY+i < this.height && this.grid[pathY+i]) this.grid[pathY+i][exitX] = exitTile;
                     this.exitPoint = new THREE.Vector3((exitX + 0.5 - this.width/2) * TILE_SIZE, 0, (pathY + exitWidth/2 - this.height/2) * TILE_SIZE);
                     this.entryPoint = new THREE.Vector3((exitX - 1.5 - this.width/2) * TILE_SIZE, 0, (pathY + exitWidth/2 - this.height/2) * TILE_SIZE);
                 } else if (exitSide === 2) { // Bottom
                      exitY = this.height - wallThickness;
                      while(pathY <= exitY) { if(this.grid[pathY]) this.grid[pathY][pathX] = floorTile; if(this.grid[pathY] && pathX+1 < this.width) this.grid[pathY][pathX+1] = floorTile; pathY++; }
                      for(let i = 0; i < exitWidth; i++) if(this.grid[exitY] && pathX+i < this.width) this.grid[exitY][pathX+i] = exitTile;
                      this.exitPoint = new THREE.Vector3((pathX + exitWidth/2 - this.width/2) * TILE_SIZE, 0, (exitY + 0.5 - this.height/2) * TILE_SIZE);
                      this.entryPoint = new THREE.Vector3((pathX + exitWidth/2 - this.width/2) * TILE_SIZE, 0, (exitY - 1.5 - this.height/2) * TILE_SIZE);
                 } else { // Left
                     exitX = wallThickness - 1;
                     while(pathX >= exitX) { if(this.grid[pathY]) this.grid[pathY][pathX] = floorTile; if(pathY+1 < this.height && this.grid[pathY+1]) this.grid[pathY+1][pathX] = floorTile; pathX--; }
                      for(let i = 0; i < exitWidth; i++) if(pathY+i < this.height && this.grid[pathY+i]) this.grid[pathY+i][exitX] = exitTile;
                      this.exitPoint = new THREE.Vector3((exitX - 0.5 - this.width/2) * TILE_SIZE, 0, (pathY + exitWidth/2 - this.height/2) * TILE_SIZE);
                      this.entryPoint = new THREE.Vector3((exitX + 1.5 - this.width/2) * TILE_SIZE, 0, (pathY + exitWidth/2 - this.height/2) * TILE_SIZE);
                 }
                 this.exitPoint = this.exitPoint || new THREE.Vector3(0,0,0);
                 this.entryPoint = this.entryPoint || new THREE.Vector3(0,0, TILE_SIZE * 2);


                  // Place some house walls
                 for (let i = 0; i < 7; i++) {
                     let houseX = Math.floor(Math.random() * (this.width - 2*wallThickness - 2) + wallThickness + 1);
                     let houseY = Math.floor(Math.random() * (this.height - 2*wallThickness - 2) + wallThickness + 1);
                     if (this.grid[houseY]?.[houseX] === floorTile && distSqXZ(this.getTileCenter(houseX, houseY), this.entryPoint) > (TILE_SIZE * 4)**2) {
                          this.grid[houseY][houseX] = wallTile;
                           if(this.grid[houseY+1]?.[houseX] === floorTile && Math.random()<0.7) this.grid[houseY+1][houseX] = wallTile;
                           if(this.grid[houseY]?.[houseX+1] === floorTile && Math.random()<0.7) this.grid[houseY][houseX+1] = wallTile;
                     }
                 }

                 // Set Spawn Points (NPCs)
                 this.spawnPoints = [];
                 let attempts = 50;
                 while (this.spawnPoints.length < 6 && attempts > 0) {
                     let sx = Math.floor(Math.random() * (this.width - 2*wallThickness) + wallThickness);
                     let sy = Math.floor(Math.random() * (this.height - 2*wallThickness) + wallThickness);
                     if (this.grid[sy]?.[sx] === floorTile && distSqXZ(this.getTileCenter(sx, sy), this.entryPoint) > (TILE_SIZE*3)**2) {
                          this.spawnPoints.push(this.getTileCenter(sx, sy));
                     }
                     attempts--;
                 }
                 // Add one near entrance
                  this.spawnPoints.push(this.entryPoint.clone().add(new THREE.Vector3(TILE_SIZE, 0, 0)));

             }

              generateWildernessLayout() {
                 const waterLevel = 0.38;
                 const mountainLevel = 0.68;
                 const floorTile = TILE_TYPE_FLOOR;
                 const wallTile = TILE_TYPE_WALL;
                 const waterTile = TILE_TYPE_WATER;
                 const entranceTile = TILE_TYPE_VILLAGE_ENTRANCE;

                 for (let y = 0; y < this.height; y++) {
                     for (let x = 0; x < this.width; x++) {
                          // Use simpleNoise instead of p5's noise
                          let n = this.simpleNoise(x * MapSettings.noiseScale, y * MapSettings.noiseScale);
                          let n2 = this.simpleNoise(x * MapSettings.noiseScale * 2 + 100, y * MapSettings.noiseScale * 2 + 100);
                          let finalN = (n * 0.7 + n2 * 0.3);

                         if (finalN < waterLevel) this.grid[y][x] = waterTile;
                         else if (finalN > mountainLevel || x < 1 || x >= this.width - 1 || y < 1 || y >= this.height - 1) this.grid[y][x] = wallTile;
                         else this.grid[y][x] = floorTile;
                     }
                 }

                 // Drunkard's walk for pathing
                 let drunkX = Math.floor(this.width / 2);
                 let drunkY = Math.floor(this.height / 2);
                 let steps = Math.floor(this.width * this.height * 0.4);
                  if (this.grid[drunkY]) this.grid[drunkY][drunkX] = floorTile;

                 for (let i = 0; i < steps; i++) {
                      let dir = Math.floor(Math.random()*4);
                      let nx = drunkX, ny = drunkY;
                      switch(dir){ case 0: ny = Math.max(1, drunkY-1); break; case 1: nx = Math.min(this.width-2, drunkX+1); break; case 2: ny = Math.min(this.height-2, drunkY+1); break; case 3: nx = Math.max(1, drunkX-1); break; }
                       drunkX=nx; drunkY=ny;
                       if(this.grid[drunkY]?.[drunkX] !== undefined){
                           this.grid[drunkY][drunkX] = floorTile;
                           if (Math.random() < 0.5) { // Widen path
                               let dx = Math.floor(Math.random()*3) - 1; let dy = Math.floor(Math.random()*3) - 1;
                               if(Math.abs(dx)+Math.abs(dy) === 1){
                                    let wx = drunkX+dx; let wy = drunkY+dy;
                                     if(wx > 0 && wx < this.width-1 && wy > 0 && wy < this.height-1 && this.grid[wy]?.[wx] !== waterTile) {
                                          this.grid[wy][wx] = floorTile;
                                     }
                               }
                           }
                       } else { // Hit edge or invalid, recenter
                           drunkX = Math.floor(Math.random() * (this.width * 0.2) + this.width * 0.4);
                           drunkY = Math.floor(Math.random() * (this.height * 0.2) + this.height * 0.4);
                            if(this.grid[drunkY]) this.grid[drunkY][drunkX] = floorTile;
                       }
                 }


                 // Set Entry/Exit Point (matches village exit conceptually)
                 let entryX = Math.floor(this.width / 2);
                 let entryY = this.height - 2; // Start near bottom edge
                 let attempts = 20;
                 while (attempts > 0 && (this.grid[entryY]?.[entryX] !== floorTile)) {
                     entryY--;
                     if (entryY <= 1) { entryY = Math.floor(this.height/2); break; } // Prevent infinite loop
                     attempts--;
                 }
                 if(this.grid[entryY]?.[entryX] !== floorTile) { // Force if still not found
                     entryY = Math.floor(this.height/2); entryX = Math.floor(this.width/2);
                     if(this.grid[entryY]) this.grid[entryY][entryX] = floorTile;
                 }
                  // Ensure entrance tile exists before placing marker
                  if(this.grid[entryY]?.[entryX-1] !== undefined) this.grid[entryY][entryX-1] = entranceTile; // Mark tile left of entry

                 this.entryPoint = this.getTileCenter(entryX, entryY);
                 this.exitPoint = this.entryPoint; // Exit is the same spot (leads back to village conceptually)

                  // Clear area around entrance
                  for(let dy = -1; dy <= 1; dy++){
                      for(let dx = -1; dx <= 1; dx++){
                           let checkY = entryY + dy;
                           let checkX = entryX + dx;
                           if(this.grid[checkY]?.[checkX] === wallTile) this.grid[checkY][checkX] = floorTile;
                      }
                  }


                 // Set Spawn Points (Monsters)
                 this.spawnPoints = [];
                 let spawnAttempts = MapSettings.maxMonsters * 5;
                 const entryCheckPos = this.entryPoint;
                 const minSpawnDistSq = (MapSettings.monsterSpawnCheckRadius ** 2) * 0.8;

                 while (this.spawnPoints.length < MapSettings.maxMonsters * 1.5 && spawnAttempts > 0) {
                     let sx = Math.floor(Math.random() * (this.width - 2) + 1);
                     let sy = Math.floor(Math.random() * (this.height - 2) + 1);
                     if (this.grid[sy]?.[sx] === floorTile) {
                          const spawnPos = this.getTileCenter(sx, sy);
                          if (distSqXZ(spawnPos, entryCheckPos) > minSpawnDistSq) {
                               this.spawnPoints.push(spawnPos);
                          }
                     }
                     spawnAttempts--;
                 }
             }
             // --- End Adapted Grid Generation ---

             getTileCenter(gridX, gridY) {
                  // Map grid coords to centered world coords
                  const worldX = (gridX - this.width / 2 + 0.5) * TILE_SIZE;
                  const worldZ = (gridY - this.height / 2 + 0.5) * TILE_SIZE;
                  return new THREE.Vector3(worldX, 0, worldZ); // Y=0 for ground level center
             }
             getWorldCoordFromGrid(gridX, gridY) {
                 const worldX = (gridX - this.width / 2) * TILE_SIZE;
                 const worldZ = (gridY - this.height / 2) * TILE_SIZE;
                 return { x: worldX, z: worldZ };
             }
             getGridCoordFromWorld(worldX, worldZ) {
                 const gridX = Math.floor(worldX / TILE_SIZE + this.width / 2);
                 const gridY = Math.floor(worldZ / TILE_SIZE + this.height / 2);
                 return { x: gridX, y: gridY };
             }

             getTileType(worldX, worldZ) {
                 const { x: gridX, y: gridY } = this.getGridCoordFromWorld(worldX, worldZ);
                 if (gridY >= 0 && gridY < this.height && gridX >= 0 && gridX < this.width) {
                     return this.grid[gridY]?.[gridX]; // Return type or undefined
                 }
                 return undefined; // Out of bounds
             }

             isObstacle(worldX, worldZ) {
                 const type = this.getTileType(worldX, worldZ);
                 // Walls and Water are obstacles
                 return type === TILE_TYPE_WALL || type === TILE_TYPE_WATER;
             }

             isOutsideBounds(worldX, worldZ) {
                  const halfWidth = this.mapWidthUnits / 2;
                  const halfHeight = this.mapHeightUnits / 2;
                   return worldX < -halfWidth || worldX >= halfWidth || worldZ < -halfHeight || worldZ >= halfHeight;
             }

             // Check using world coordinates
             isOnExit(worldX, worldZ) {
                 if (!this.exitPoint) return false;
                 // Check grid type OR distance to exit point
                  const type = this.getTileType(worldX, worldZ);
                  if (type === TILE_TYPE_EXIT) return true;
                  // Fallback distance check
                  const exitRadiusSq = (TILE_SIZE * 1.0)**2; // Smaller radius for exit point check
                  return distSqXZ(new THREE.Vector3(worldX, 0, worldZ), this.exitPoint) < exitRadiusSq;
             }

             isOnVillageEntrance(worldX, worldZ) {
                 if (this.isVillage) return false;
                  const type = this.getTileType(worldX, worldZ);
                  return type === TILE_TYPE_VILLAGE_ENTRANCE;
             }


             getRandomSpawnPoint(referencePos = null, minDistanceSq = 0) {
                  if (!this.spawnPoints || this.spawnPoints.length === 0) return null;

                  let validPoints = this.spawnPoints;
                  if (referencePos && minDistanceSq > 0) {
                      validPoints = this.spawnPoints.filter(pt => pt && distSqXZ(pt, referencePos) > minDistanceSq);
                  }

                  if (validPoints.length === 0) validPoints = this.spawnPoints; // Fallback if filtering removed all
                  return randomFromArray(validPoints.filter(pt => pt))?.clone(); // Return a clone
             }

             // Create the 3D representation using InstancedMesh
             createMapMesh() {
                 if (mapMeshGroup) scene.remove(mapMeshGroup); // Clear previous map
                 mapMeshGroup = new THREE.Group();
                 mapObstacleMeshes.length = 0; // Clear obstacle mesh list

                 const dummy = new THREE.Object3D(); // Used to set instance transforms

                 // Initialize InstancedMesh for each material type
                 for (const type in this.materials) {
                     if (this.materials.hasOwnProperty(type)) {
                         this.tileInstances[type] = new THREE.InstancedMesh(
                             this.tileGeometry,
                             this.materials[type],
                             this.maxInstances // Allocate max possible instances initially
                         );
                         this.tileInstances[type].count = 0; // Start with 0 visible instances
                         this.tileInstances[type].castShadow = true;
                         this.tileInstances[type].receiveShadow = true;
                          mapMeshGroup.add(this.tileInstances[type]);
                     }
                 }

                 // Populate instances based on grid data
                 for (let y = 0; y < this.height; y++) {
                     for (let x = 0; x < this.width; x++) {
                         const tileType = this.grid[y][x];
                         if (tileType === undefined || tileType === null) continue; // Skip empty grid cells

                         const instancedMesh = this.tileInstances[tileType] || this.tileInstances.default;
                         if (!instancedMesh) continue;

                         const instanceIndex = instancedMesh.count;
                         const tilePos = this.getTileCenter(x, y);

                         // Adjust Y position based on type (e.g., walls higher, floor lower)
                         let tileY = -HALF_TILE_SIZE; // Default floor level
                          if(tileType === TILE_TYPE_WALL) tileY = HALF_TILE_SIZE; // Walls sit higher
                          else if (tileType === TILE_TYPE_WATER) tileY = -HALF_TILE_SIZE * 1.2; // Water slightly lower

                         dummy.position.set(tilePos.x, tileY, tilePos.z);
                         dummy.updateMatrix();
                         instancedMesh.setMatrixAt(instanceIndex, dummy.matrix);
                         instancedMesh.count++;

                          // Add to obstacle list if it's a wall or water
                          if (tileType === TILE_TYPE_WALL || tileType === TILE_TYPE_WATER) {
                               mapObstacleMeshes.push({ x: tilePos.x, z: tilePos.z, type: tileType}); // Store simplified obstacle info
                          }
                     }
                 }

                 // Update instance matrices
                 for (const type in this.tileInstances) {
                      if (this.tileInstances[type]) {
                            this.tileInstances[type].instanceMatrix.needsUpdate = true;
                      }
                 }

                 scene.add(mapMeshGroup);
             }

             dispose() {
                 if (mapMeshGroup) scene.remove(mapMeshGroup);
                 for (const type in this.tileInstances) {
                     if (this.tileInstances[type]) {
                          this.tileInstances[type].dispose(); // Dispose InstancedMesh
                     }
                 }
                  this.tileGeometry.dispose();
                 for (const type in this.materials) {
                     if (this.materials[type]) {
                          this.materials[type].dispose();
                     }
                 }
                 mapObstacleMeshes.length = 0;
                 console.log("Map disposed.");
             }
        }


        // --- Player Class ---
        console.log("Loading: player.js");
        class Player {
             constructor(x, z) { // Use x, z for ground position
                 this.pos = new THREE.Vector3(x, PlayerDefaults.size * 0.5, z); // Center Y slightly above ground
                 this.targetPos = this.pos.clone();
                 this.size = PlayerDefaults.size;
                 this.color = new THREE.Color(PlayerDefaults.color);
                 this.name = "Player";
                 this.mesh = this.createMesh();
                  this.mesh.userData = { gameObject: this, type: 'Player' };
                 scene.add(this.mesh);
                 // Player is usually not intersectable by its own projectiles/clicks
                 // intersectableUnits.push(this.mesh);

                 this.baseStats = JSON.parse(JSON.stringify({
                     maxHP: PlayerDefaults.hp, maxMP: PlayerDefaults.mp, attack: PlayerDefaults.attack, defense: PlayerDefaults.defense, speed: PlayerDefaults.speed, attackRange: PlayerDefaults.attackRange, pickupRadius: PlayerDefaults.pickupRadius, xpToNextLevel: PlayerDefaults.xpToNextLevel,
                 }));
                 this.currentStats = { ...this.baseStats };
                 this.stats = { hp: PlayerDefaults.hp, mp: PlayerDefaults.mp, level: PlayerDefaults.level, xp: PlayerDefaults.xp, };

                 this.inventory = new Array(PlayerDefaults.inventorySize).fill(null);
                 this.equipment = { weapon: null, helmet: null, armor: null, boots: null, amulet: null, ring1: null, ring2: null };

                 this.targetEnemy = null; // The Monster/NPC object being targeted
                 this.targetMovePos = null; // Specific Vector3 for movement destination
                 this.isMoving = false;
                 this.lastAttackTime = -Infinity; // Allow immediate attack
                 this.attackCooldown = 0.8; // Seconds
                 this.pickupRadiusSq = PlayerDefaults.pickupRadius ** 2;

                  // Add a health bar element
                  this.healthBarElement = null; // Will be created by UIManager
                  this.worldPos2D = { x: -1000, y: -1000}; // Store screen coords

                 this.updateCombinedStats();
             }

             createMesh() {
                  // Use Capsule for player representation
                  const radius = this.size * 0.4;
                  const height = this.size * 0.8; // Total height = height + 2 * radius
                  const geo = new THREE.CapsuleGeometry(radius, height, 4, 12); // segments for performance
                  const mat = new THREE.MeshStandardMaterial({
                       color: this.color,
                       roughness: 0.6,
                       metalness: 0.3
                       // map: playerTexture // Add texture later if needed
                  });
                  const mesh = new THREE.Mesh(geo, mat);
                  mesh.position.copy(this.pos);
                  mesh.castShadow = true;
                  mesh.receiveShadow = false; // Usually characters don't receive shadows on themselves like this
                  return mesh;
             }

             moveTo(targetVector3) {
                 this.targetMovePos = targetVector3.clone();
                 this.targetMovePos.y = this.pos.y; // Maintain current height when moving
                 this.targetEnemy = null; // Clear enemy target
                 this.isMoving = true;
                 // console.log("Player moving to:", this.targetMovePos);
             }

             setAttackTarget(enemy) {
                 if (enemy && enemy.stats && enemy.stats.hp > 0) {
                     this.targetEnemy = enemy;
                     this.targetMovePos = null; // Clear move target
                     this.isMoving = true; // Start moving towards enemy (or attack if in range)
                      playSound('targetEnemy'); // Maybe a targeting sound
                 } else {
                     this.targetEnemy = null;
                 }
             }

             attack(target) {
                 if (!target || !target.stats || target.stats.hp <= 0) {
                     this.targetEnemy = null; return;
                 }
                 const now = gameTime;
                 if (now - this.lastAttackTime >= this.attackCooldown) {
                     console.log(`${this.name} attacks ${target.name}`);
                     const targetDefense = target.currentStats?.defense ?? 0;
                     let damage = Math.max(1, this.currentStats.attack - targetDefense);
                     damage = Math.floor(damage * (Math.random() * 0.3 + 0.85)); // 85% - 115%

                     playSound('playerAttack');
                     if (typeof target.takeDamage === 'function') {
                         target.takeDamage(damage, this);
                     } else { console.error("Target has no takeDamage method:", target); }

                     this.lastAttackTime = now;
                     this.playAttackAnimation(target); // Visual effect

                     if (target.stats.hp <= 0) this.targetEnemy = null;
                 }
             }

             playAttackAnimation(target){
                  // Simple line effect for now
                   if (target?.mesh) {
                        const lineMat = new THREE.LineBasicMaterial({color: 0xffdd00, transparent: true, opacity: 0.8});
                        const points = [this.pos.clone().add(new THREE.Vector3(0,this.size*0.1,0)), target.pos.clone().add(new THREE.Vector3(0,target.size*0.1,0)) ];
                        const lineGeo = new THREE.BufferGeometry().setFromPoints(points);
                        const line = new THREE.Line(lineGeo, lineMat);
                        scene.add(line);
                        // Remove line after short duration
                        setTimeout(() => {
                             scene.remove(line);
                             lineMat.dispose();
                             lineGeo.dispose();
                        }, 150);
                   }
             }

             takeDamage(damage, attacker) {
                 if (!this.stats || this.stats.hp <= 0) return;
                 this.stats.hp -= damage;
                 if (uiManager) uiManager.addFloatingText(`-${damage}`, this.pos, 'red');
                  playSound('playerHit');

                 if (this.stats.hp <= 0) {
                      this.stats.hp = 0; // Prevent negative HP display
                      this.die(attacker);
                 } else {
                      // Flash effect?
                      if (this.mesh) {
                           const originalColor = this.mesh.material.color.getHex();
                           this.mesh.material.color.setHex(0xff0000);
                           this.mesh.material.emissive.setHex(0xff0000); this.mesh.material.emissiveIntensity = 0.8;
                           setTimeout(() => {
                                if (this.mesh) { // Check if mesh still exists (player might die)
                                     this.mesh.material.color.setHex(originalColor);
                                     this.mesh.material.emissive.setHex(0x000000); this.mesh.material.emissiveIntensity = 0;
                                }
                           }, 150);
                      }
                 }
                  uiManager?.updateHUD(); // Update HUD immediately
             }

             die(killer) {
                 if (gameState === 'gameOver') return; // Already dead
                 const killerName = killer?.name ?? 'unknown causes';
                 console.log(`${this.name} slain by ${killerName}!`);
                 playSound('playerDeath');
                 gameState = 'gameOver';
                 uiManager?.showGameOverScreen();
                 // Maybe play death animation? Make mesh fall over?
                 if(this.mesh) {
                     // this.mesh.rotation.z = Math.PI / 2; // Simple fall
                     // Make slightly transparent?
                     // this.mesh.material.transparent = true;
                     // this.mesh.material.opacity = 0.6;
                 }
             }

             gainXP(amount) {
                 if (!this.stats || this.stats.hp <= 0 || amount <= 0) return;
                 this.stats.xp += amount;
                 if (uiManager) uiManager.addMessage(`+${amount} ${UIText.xp || 'XP'}`, 'yellow', 2000);

                 while (this.stats.xp >= this.currentStats.xpToNextLevel) {
                     let required = this.currentStats.xpToNextLevel;
                     this.stats.xp -= required;
                     this.levelUp();
                 }
                 uiManager?.updateHUD();
             }

             levelUp() {
                 if (!this.stats || !this.baseStats) return;
                 this.stats.level++;
                 this.baseStats.xpToNextLevel = Math.floor(this.baseStats.xpToNextLevel * 1.6 + 50 + this.stats.level * 10);

                 const hpGain = 10 + Math.floor(this.stats.level / 2);
                 const mpGain = 5 + Math.floor(this.stats.level / 3);
                 const attackGain = 1 + Math.floor(Math.random() * 2);
                 const defenseGain = 1;

                 this.baseStats.maxHP += hpGain; this.baseStats.maxMP += mpGain;
                 this.baseStats.attack += attackGain; this.baseStats.defense += defenseGain;

                 // Full heal/mana on level up
                 this.stats.hp = this.baseStats.maxHP; this.stats.mp = this.baseStats.maxMP;

                 this.updateCombinedStats();
                 console.log(`Level Up! Reached level ${this.stats.level}!`);
                 if (uiManager) uiManager.addMessage(`${UIText.levelUp}! (${this.stats.level})`, 'lime', 3500);
                 playSound('levelUp');

                  // Play level up visual effect (Expanding ring)
                   const ringGeo = new THREE.RingGeometry(this.size * 0.1, this.size * 1.5, 32);
                   const ringMat = new THREE.MeshBasicMaterial({ color: 0xffff00, side: THREE.DoubleSide, transparent: true, opacity: 0.8});
                   const ringMesh = new THREE.Mesh(ringGeo, ringMat);
                   ringMesh.position.copy(this.pos).add(new THREE.Vector3(0, 0.1, 0)); // Slightly above ground
                   ringMesh.rotation.x = -Math.PI / 2; // Lay flat on ground
                   scene.add(ringMesh);
                   let scale = 0.1;
                   const maxScale = 2.0;
                   const duration = 500; // ms
                   const startTime = Date.now();
                   const animateRing = () => {
                        const elapsed = Date.now() - startTime;
                        if(elapsed >= duration || !ringMesh.parent) return; // Stop if duration passed or removed
                        scale = 0.1 + (maxScale - 0.1) * (elapsed / duration);
                        ringMesh.scale.set(scale, scale, scale);
                        ringMat.opacity = 0.8 * (1 - elapsed / duration);
                        requestAnimationFrame(animateRing);
                   }
                   animateRing();
                   setTimeout(() => {
                        scene.remove(ringMesh);
                        ringGeo.dispose();
                        ringMat.dispose();
                   }, duration + 50);

                 uiManager?.updateHUD();
                 uiManager?.updateCharacterStats(); // Update char sheet if open
             }

             findEmptyInventorySlot() {
                 if (!this.inventory) return -1;
                 return this.inventory.findIndex(slot => slot === null);
             }

             pickupItem(droppedItem) {
                 if (!droppedItem || !droppedItem.item || droppedItem.invalid || !this.inventory) return false;
                 const item = droppedItem.item;
                 let pickedUp = false;
                 let remainingQuantity = item.quantity; // Track quantity for messaging

                 // Try stacking first
                 if (item.stackable) {
                     for (let i = 0; i < this.inventory.length; i++) {
                         if (this.inventory[i] && this.inventory[i].id === item.id && this.inventory[i].quantity < this.inventory[i].maxStack) {
                             let overflow = this.inventory[i].addQuantity(item.quantity);
                             if (overflow === 0) { // Fully stacked
                                  pickedUp = true;
                                  break; // Exit loop, item fully picked up
                             } else {
                                  // Partially stacked, update item quantity for placing remainder
                                  item.quantity = overflow;
                                  // Don't set pickedUp = true yet, need to find a new slot
                             }
                         }
                     }
                 }

                 // If not fully stacked, find empty slot
                 if (!pickedUp) {
                     const emptySlotIndex = this.findEmptyInventorySlot();
                     if (emptySlotIndex !== -1) {
                         this.inventory[emptySlotIndex] = item; // Place item (or remaining stack)
                         pickedUp = true;
                     }
                 }

                 if (pickedUp) {
                     const qtySuffix = item.stackable && remainingQuantity > 1 ? ` x${remainingQuantity}` : '';
                     if (uiManager) uiManager.addMessage(`${UIText.pickup}: ${item.name}${qtySuffix}`, getRarityHexColor(item.rarity), 2000);
                      playSound('pickupItem');
                     uiManager?.updateInventory(); // Update UI
                     return true; // Pickup successful
                 } else {
                     if (uiManager) uiManager.addMessage(UIText.inventoryFull, 'orange');
                     playSound('invalidAction');
                     return false; // Pickup failed
                 }
             }

             useItem(inventoryIndex) {
                 if (!this.inventory || inventoryIndex < 0 || inventoryIndex >= this.inventory.length) return;
                 const item = this.inventory[inventoryIndex];
                 if (item && item.type === 'consumable') {
                     const itemStillExists = item.use(this); // Handles stat change & floating text
                     if (!itemStillExists) {
                         this.inventory[inventoryIndex] = null;
                     }
                     uiManager?.updateInventory();
                      uiManager?.updateHUD();
                 } else { playSound('invalidAction'); }
             }

             equipItem(inventoryIndex) {
                 if (!this.inventory || !this.equipment || inventoryIndex < 0 || inventoryIndex >= this.inventory.length) return;
                 const item = this.inventory[inventoryIndex];
                 if (!item || item.type !== 'equipment') { playSound('invalidAction'); return; }

                 let targetSlot = item.slot;
                  if (targetSlot === 'ring') { // Handle rings
                      if (!this.equipment['ring1']) targetSlot = 'ring1';
                      else if (!this.equipment['ring2']) targetSlot = 'ring2';
                      else targetSlot = 'ring1'; // Default replace ring1
                  }
                 if (!this.equipment.hasOwnProperty(targetSlot)) { playSound('invalidAction'); return; }

                 let previouslyEquipped = this.equipment[targetSlot];
                 this.equipment[targetSlot] = item;
                 this.inventory[inventoryIndex] = previouslyEquipped; // Swap back

                 console.log(`Equipped ${item.name} to ${targetSlot}`);
                 playSound('equipItem');
                 this.updateCombinedStats();
                 uiManager?.updateInventory();
                 uiManager?.updateEquipment();
                  uiManager?.updateHUD(); // Stats might change HP/MP display
                  uiManager?.updateCharacterStats();
             }

             unequipItem(slot) {
                 if (!this.equipment || !this.equipment[slot]) return;
                 const itemToUnequip = this.equipment[slot];
                 const emptySlotIndex = this.findEmptyInventorySlot();

                 if (emptySlotIndex !== -1) {
                     this.inventory[emptySlotIndex] = itemToUnequip;
                     this.equipment[slot] = null;
                     console.log(`Unequipped ${itemToUnequip.name} to inventory slot ${emptySlotIndex}`);
                     playSound('equipItem');
                     this.updateCombinedStats();
                     uiManager?.updateInventory();
                     uiManager?.updateEquipment();
                      uiManager?.updateHUD();
                      uiManager?.updateCharacterStats();
                 } else {
                      if (uiManager) uiManager.addMessage(`${UIText.inventoryFull}, cannot unequip ${itemToUnequip.name}`, 'orange');
                      playSound('invalidAction');
                 }
             }

             updateCombinedStats() {
                 if (!this.baseStats || !this.currentStats || !this.equipment || !this.stats) return;
                 // Reset current stats to base stats
                 this.currentStats = { ...this.baseStats };

                 // Apply equipment stats
                 for (const slot in this.equipment) {
                     const item = this.equipment[slot];
                     if (item?.stats) {
                         for (const stat in item.stats) {
                             const value = item.stats[stat];
                             if (value === undefined || value === null) continue;
                             if (this.currentStats.hasOwnProperty(stat)) {
                                 this.currentStats[stat] += value;
                             } else { console.warn(`Item ${item.name} has unhandled stat: ${stat}`); }
                         }
                     }
                 }
                  // Ensure attackRange and pickupRadius are present
                  this.currentStats.attackRange = this.currentStats.attackRange ?? PlayerDefaults.attackRange;
                  this.currentStats.pickupRadius = this.currentStats.pickupRadius ?? PlayerDefaults.pickupRadius;
                  this.pickupRadiusSq = this.currentStats.pickupRadius ** 2;


                 // Ensure HP/MP don't exceed new max values
                 this.stats.hp = Math.min(this.stats.hp, this.currentStats.maxHP);
                 this.stats.mp = Math.min(this.stats.mp, this.currentStats.maxMP);
                 this.currentStats.speed = Math.max(0.5, this.currentStats.speed); // Min speed

                 // Update UI if available
                 uiManager?.updateHUD();
                 uiManager?.updateCharacterStats();
             }

             update(deltaTime, units, map) {
                 if (this.stats.hp <= 0) return false;

                 let moved = false;
                 let targetDestination = null;

                 // --- Determine Target Destination ---
                 if (this.targetEnemy) {
                     if (!this.targetEnemy.mesh || this.targetEnemy.stats.hp <= 0) {
                         this.targetEnemy = null; // Target died or invalid
                         this.isMoving = false;
                     } else {
                         const distSq = distSqXZ(this.pos, this.targetEnemy.pos);
                         const attackRangeSq = this.currentStats.attackRange ** 2;
                         if (distSq <= attackRangeSq) {
                             this.isMoving = false; // Stop to attack
                             this.attack(this.targetEnemy);
                         } else {
                             targetDestination = this.targetEnemy.pos; // Move towards enemy
                             this.isMoving = true;
                         }
                         // Face the target when attacking or chasing
                         this.mesh.lookAt(this.targetEnemy.pos.x, this.pos.y, this.targetEnemy.pos.z);
                     }
                 } else if (this.targetMovePos) {
                     const distSq = distSqXZ(this.pos, this.targetMovePos);
                      // Use speed * deltaTime as threshold? Or small fixed value?
                     if (distSq < (this.currentStats.speed * deltaTime * 1.5)**2 || distSq < 0.1) {
                         this.isMoving = false; // Reached destination
                         this.targetMovePos = null;
                         this.pos.x = this.targetMovePos ? this.targetMovePos.x : this.pos.x; // Snap roughly?
                         this.pos.z = this.targetMovePos ? this.targetMovePos.z : this.pos.z;
                     } else {
                         targetDestination = this.targetMovePos; // Move towards point
                         this.isMoving = true;
                         // Face movement direction
                         this.mesh.lookAt(this.targetMovePos.x, this.pos.y, this.targetMovePos.z);
                     }
                 } else {
                      this.isMoving = false; // No target
                 }


                 // --- Execute Movement ---
                 if (this.isMoving && targetDestination) {
                      const moveDir = targetDestination.clone().sub(this.pos);
                      moveDir.y = 0; // Move only on XZ plane
                      if (moveDir.lengthSq() > 0.001) { // Avoid normalizing zero vector
                          moveDir.normalize();
                          const moveAmount = this.currentStats.speed * deltaTime;
                          const moveVector = moveDir.multiplyScalar(moveAmount);
                          const nextPos = this.pos.clone().add(moveVector);

                          // Basic Collision Check (Map only for now)
                          if (!map.isObstacle(nextPos.x, nextPos.z) && !map.isOutsideBounds(nextPos.x, nextPos.z)) {
                              this.pos.copy(nextPos);
                              this.mesh.position.copy(this.pos);
                              moved = true;
                               // Play step sound periodically?
                          } else {
                              this.isMoving = false; // Hit wall
                              this.targetMovePos = null; // Stop trying to move to that point
                              // Play bump sound?
                              playSound('invalidAction', 0.05, 0.4);
                          }
                      } else {
                           this.isMoving = false; // Already at target (should have been caught above)
                      }
                 }


                 // --- Passive Updates ---
                 // MP Regen (using gameTime, assuming 60fps target for deltaTime)
                  // Regen 1 MP every 3 seconds approx
                 if (gameTime % 180 < deltaTime * 60) { // Check if cross boundary
                     if (this.stats.mp < this.currentStats.maxMP) {
                         this.stats.mp = Math.min(this.currentStats.maxMP, this.stats.mp + 1);
                         uiManager?.updateHUD();
                     }
                 }

                  // Update screen position for UI elements
                  this.worldPos2D = worldToScreen(this.pos);

                 return moved;
             }

             // No render needed, mesh position updated in update()
        }

        // --- Monster Class ---
        console.log("Loading: monster.js");
        class Monster {
            constructor(monsterId, x, z) {
                const data = MonsterData[monsterId];
                if (!data) { /* ... error handling ... */ this.invalid = true; return; }
                this.id = monsterId; this.name = data.name;
                 this.size = data.size || TILE_SIZE * 0.8;
                 this.pos = new THREE.Vector3(x, this.size * 0.5, z); // Position based on size
                this.color = new THREE.Color(data.color || 0xff0000);
                this.icon = data.icon || 'default_monster';
                this.attackType = data.attackType || 'melee';
                 this.invalid = false;
                 this.mesh = this.createMesh();
                  this.mesh.userData = { gameObject: this, type: 'Monster' };
                  scene.add(this.mesh);
                  intersectableUnits.push(this.mesh);

                this.baseStats = JSON.parse(JSON.stringify({
                    maxHP: data.hp || 10, maxMP: data.mp || 0, attack: data.attack || 1, defense: data.defense || 0, speed: data.speed || 1, attackRange: data.attackRange || TILE_SIZE * 1.5, aggroRange: data.aggroRange || TILE_SIZE * 5, projectileType: data.projectileType, projectileSpeed: data.projectileSpeed, projectileDamage: data.projectileDamage || data.attack || 1
                }));
                this.currentStats = { ...this.baseStats };
                this.stats = { hp: this.baseStats.maxHP, mp: this.baseStats.maxMP };

                this.xpReward = data.xp || 0;
                this.lootTable = data.lootTable || [];

                this.target = null; // Player or NPC object
                 this.state = 'idle'; // 'idle', 'wandering', 'chasing', 'attacking', 'dead'
                 this.lastAttackTime = -Infinity;
                 this.attackCooldown = (this.attackType === 'ranged' ? 2.5 : 1.5) + Math.random() * 0.4 - 0.2; // Seconds + variance
                 this.wanderTarget = null;
                 this.lastWanderTime = -Infinity;
                 this.wanderCooldown = Math.random() * 5 + 4; // 4-9 seconds

                  // Add a health bar element
                  this.healthBarElement = null; // Will be created by UIManager
                  this.worldPos2D = { x: -1000, y: -1000}; // Store screen coords
            }

             createMesh() {
                  // Simple geometry based on type? Sphere for bat, Box for goblin/skel?
                  let geo;
                  const mat = new THREE.MeshStandardMaterial({ color: this.color, roughness: 0.7, metalness: 0.2 });
                  if (this.icon === 'bat') {
                       geo = new THREE.SphereGeometry(this.size * 0.5, 10, 8); // Sphere for bat
                  } else {
                        // Slightly different box proportions
                       geo = new THREE.BoxGeometry(this.size * 0.7, this.size, this.size * 0.6);
                  }
                  const mesh = new THREE.Mesh(geo, mat);
                  mesh.position.copy(this.pos);
                  mesh.castShadow = true;
                  mesh.receiveShadow = false;
                  return mesh;
             }

             takeDamage(damage, attacker) {
                 if (this.state === 'dead' || this.invalid) return;
                 if (!this.stats) this.stats = { hp: 0 };
                 if (!this.baseStats) this.baseStats = { maxHP: 0 };

                 this.stats.hp -= damage;
                 if (uiManager) uiManager.addFloatingText(`-${damage}`, this.pos, 'yellow');
                  // Play monster hit sound

                 // Flash effect
                 if (this.mesh) {
                      const originalColor = this.mesh.material.color.getHex();
                      this.mesh.material.color.setHex(0xffffff);
                      this.mesh.material.emissive.setHex(0xffffff); this.mesh.material.emissiveIntensity = 0.7;
                      setTimeout(() => {
                           if (this.mesh) {
                                this.mesh.material.color.setHex(originalColor);
                                this.mesh.material.emissive.setHex(0x000000); this.mesh.material.emissiveIntensity = 0;
                           }
                      }, 100);
                 }

                 if (this.stats.hp <= 0) {
                     this.die(attacker);
                 } else {
                      // Aggro logic
                       const isPlayer = attacker instanceof Player;
                      if (!this.target || (isPlayer && !(this.target instanceof Player))) {
                           if (attacker.mesh && attacker.stats.hp > 0) { // Check attacker is valid target
                                this.target = attacker;
                                if (this.state === 'idle' || this.state === 'wandering') {
                                     this.state = 'chasing';
                                     this.wanderTarget = null;
                                }
                           }
                      }
                 }
             }

             die(killer) {
                 if (this.state === 'dead' || this.invalid) return;
                 this.state = 'dead';
                 this.stats.hp = 0;
                 const killerName = killer?.name ?? 'the environment';
                 console.log(`${this.name} slain by ${killerName}!`);
                 // Play death sound

                 if (killer && typeof killer.gainXP === 'function') {
                     killer.gainXP(this.xpReward);
                 }
                 this.dropLoot();

                  // Remove from intersectables, make mesh semi-transparent/fall?
                  const index = intersectableUnits.indexOf(this.mesh);
                  if (index > -1) intersectableUnits.splice(index, 1);
                 if (this.mesh) {
                      this.mesh.castShadow = false;
                      this.mesh.material.transparent = true;
                      this.mesh.material.opacity = 0.4;
                       // Simple fall animation over time?
                       const fallDuration = 1.0; // seconds
                       const startRot = this.mesh.rotation.clone();
                       const endRot = new THREE.Euler(0, this.mesh.rotation.y, Math.PI / 2 + (Math.random()-0.5)*0.5); // Fall sideways
                       const startTime = gameTime;
                       const fallAnim = () => {
                           if(!this.mesh) return; // Stop if disposed
                           const elapsed = gameTime - startTime;
                           const progress = Math.min(1.0, elapsed / fallDuration);
                           this.mesh.rotation.copy(startRot).slerp(endRot, progress);
                           this.mesh.position.y = (this.size * 0.5) * (1.0 - progress * 0.8); // Sink slightly
                           if(progress < 1.0) requestAnimationFrame(fallAnim);
                       };
                       fallAnim();
                 }
                 // Remove health bar
                 uiManager?.removeWorldHealthBar(this);
             }

             dropLoot() {
                  if (this.invalid) return;
                  this.lootTable.forEach(loot => {
                      if (Math.random() < loot.chance) {
                          const itemInstance = new Item(loot.itemId);
                          if (itemInstance && !itemInstance.invalid) {
                              const dropOffset = new THREE.Vector3(
                                   (Math.random() - 0.5) * TILE_SIZE * 0.4,
                                   0,
                                   (Math.random() - 0.5) * TILE_SIZE * 0.4
                              );
                              const dropPos = this.pos.clone().add(dropOffset);
                              worldItems.push(new DroppedItem(itemInstance, dropPos.x, dropPos.z));
                          }
                      }
                  });
             }

              attack(target) {
                  if (!target || !target.mesh || target.stats.hp <= 0 || this.state === 'dead' || this.invalid) {
                      this.target = null; this.state = 'idle'; return;
                  }
                  const now = gameTime;
                  if (now - this.lastAttackTime >= this.attackCooldown) {
                      if (this.attackType === 'melee') {
                           const targetDefense = target.currentStats?.defense ?? 0;
                           let damage = Math.max(1, this.currentStats.attack - targetDefense);
                           damage = Math.floor(damage * (Math.random() * 0.2 + 0.9)); // 90-110%

                            if(typeof target.takeDamage === 'function') target.takeDamage(damage, this);
                            // Play melee sound
                            // Simple attack effect
                             this.playAttackAnimation(target);

                      } else if (this.attackType === 'ranged') {
                          // Create projectile
                           const startPos = this.pos.clone().add(new THREE.Vector3(0, this.size * 0.3, 0)); // Start slightly higher
                           const targetPos = target.pos.clone().add(new THREE.Vector3(0, target.size * 0.3, 0)); // Aim for center mass
                           projectiles.push(new Projectile(
                                startPos.x, startPos.y, startPos.z,
                                targetPos.x, targetPos.y, targetPos.z,
                                this.currentStats.projectileSpeed || 10,
                                this.currentStats.projectileDamage || this.currentStats.attack,
                                this, // owner
                                this.currentStats.projectileType || 'arrow'
                           ));
                            playSound('monsterAttackRanged');
                      }
                       this.lastAttackTime = now;
                       if (target.stats.hp <= 0) { this.target = null; this.state = 'idle'; }
                  }
              }

             playAttackAnimation(target){
                   if (target?.mesh) {
                       const lineMat = new THREE.LineBasicMaterial({color: 0xff8888, transparent: true, opacity: 0.7});
                       const points = [this.pos.clone().add(new THREE.Vector3(0,this.size*0.1,0)), target.pos.clone().add(new THREE.Vector3(0,target.size*0.1,0)) ];
                       const lineGeo = new THREE.BufferGeometry().setFromPoints(points);
                       const line = new THREE.Line(lineGeo, lineMat);
                       scene.add(line);
                       setTimeout(() => {
                            scene.remove(line);
                            lineMat.dispose();
                            lineGeo.dispose();
                       }, 120);
                   }
             }

              update(deltaTime, player, npcs, map) {
                  if (this.state === 'dead' || this.invalid) return;

                   // Target Acquisition / State Update
                   this.findTarget(player, npcs);

                   // Action based on state
                   let moved = false;
                   switch (this.state) {
                       case 'idle':
                           if (gameTime - this.lastWanderTime > this.wanderCooldown) {
                                this.state = 'wandering'; this.lastWanderTime = gameTime;
                                this.wanderCooldown = Math.random() * 5 + 4; // Reset cooldown
                           }
                           break;
                       case 'wandering':
                           if (!this.wanderTarget) this.setWanderTarget(map);
                           if (this.wanderTarget) {
                               moved = this.moveTowards(this.wanderTarget, deltaTime, map);
                               if (!moved || distSqXZ(this.pos, this.wanderTarget) < (this.currentStats.speed * deltaTime * 1.5)**2) {
                                    this.wanderTarget = null; this.state = 'idle';
                               }
                           } else { this.state = 'idle'; } // Failed wander
                           break;
                       case 'chasing':
                           if (this.target?.mesh) {
                               moved = this.moveTowards(this.target.pos, deltaTime, map);
                               // Maybe face target while chasing
                                this.mesh.lookAt(this.target.pos.x, this.pos.y, this.target.pos.z);
                           } else { this.state = 'idle'; } // Target lost
                           break;
                       case 'attacking':
                           if (this.target?.mesh) {
                                // Face target when attacking
                               this.mesh.lookAt(this.target.pos.x, this.pos.y, this.target.pos.z);
                               this.attack(this.target); // Attack handles cooldown
                           } else { this.state = 'idle'; } // Target lost
                           break;
                   }

                  // Update screen position for UI
                  this.worldPos2D = worldToScreen(this.pos);
              }

             findTarget(player, npcs) {
                  let potentialTargets = [];
                  if (player?.mesh && player.stats.hp > 0) potentialTargets.push(player);
                  // Add fightable NPCs (only if in village? depends on game logic)
                  if (currentMap.isVillage) {
                       npcs.forEach(npc => {
                            if (npc?.mesh && npc.canFight && npc.stats.hp > 0) potentialTargets.push(npc);
                       });
                  }

                  let closestTarget = null;
                  let minDistSq = (this.target ? distSqXZ(this.pos, this.target.pos) : Infinity); // Start with current target distance or infinity

                  // Check current target validity
                  if (this.target) {
                       if (!potentialTargets.includes(this.target) || this.target.stats.hp <= 0) {
                            this.target = null; // Target invalid
                            this.state = 'idle';
                            minDistSq = Infinity; // Force scan
                       } else {
                            // Check if target moved too far away (beyond AGGRO range * 1.5)
                             const maxChaseDistSq = (this.currentStats.aggroRange ** 2) * 2.25;
                             if (minDistSq > maxChaseDistSq) {
                                  this.target = null; this.state = 'idle'; minDistSq = Infinity;
                             } else {
                                  closestTarget = this.target; // Assume current is still best
                             }
                       }
                  }

                 // Scan for closer targets within aggro range
                  const aggroRangeSq = this.currentStats.aggroRange ** 2;
                  for (let pTarget of potentialTargets) {
                       const dSq = distSqXZ(this.pos, pTarget.pos);
                       if (dSq < aggroRangeSq && dSq < minDistSq) {
                            minDistSq = dSq;
                            closestTarget = pTarget;
                       }
                  }

                  // Update state based on closest valid target
                  if (closestTarget) {
                       this.target = closestTarget;
                       const attackRangeSq = this.currentStats.attackRange ** 2;
                       if (minDistSq <= attackRangeSq) {
                            this.state = 'attacking';
                       } else {
                            this.state = 'chasing';
                       }
                  } else {
                        // No target found or lost target, revert to idle if not already idle/wandering
                        if(this.state === 'chasing' || this.state === 'attacking') {
                             this.state = 'idle';
                        }
                        this.target = null;
                  }
             }

             setWanderTarget(map) {
                  const angle = Math.random() * Math.PI * 2;
                  const dist = Math.random() * TILE_SIZE * 3 + TILE_SIZE * 1.5;
                  const tryX = this.pos.x + Math.cos(angle) * dist;
                  const tryZ = this.pos.z + Math.sin(angle) * dist;
                  if (!map.isObstacle(tryX, tryZ) && !map.isOutsideBounds(tryX, tryZ)) {
                       this.wanderTarget = new THREE.Vector3(tryX, this.pos.y, tryZ);
                  } else {
                       this.wanderTarget = null; // Failed
                  }
             }

              moveTowards(targetVector3, deltaTime, map) {
                 if (!targetVector3 || !this.mesh) return false;
                  const moveDir = targetVector3.clone().sub(this.pos);
                  moveDir.y = 0; // Move on XZ plane
                   if (moveDir.lengthSq() < 0.01) return false; // Already close

                   moveDir.normalize();
                  const moveAmount = this.currentStats.speed * deltaTime;
                  const moveVector = moveDir.multiplyScalar(moveAmount);
                   const nextPos = this.pos.clone().add(moveVector);

                   // Basic Map Collision
                  if (!map.isObstacle(nextPos.x, nextPos.z) && !map.isOutsideBounds(nextPos.x, nextPos.z)) {
                       // TODO: Add basic unit-unit collision avoidance?
                       this.pos.copy(nextPos);
                       this.mesh.position.copy(this.pos);
                       return true;
                  } else {
                       // Hit obstacle - maybe try sliding? Basic: just stop.
                        return false;
                  }
              }

             dispose() {
                  if (this.mesh) {
                       scene.remove(this.mesh);
                       const index = intersectableUnits.indexOf(this.mesh);
                       if (index > -1) intersectableUnits.splice(index, 1);
                       this.mesh.geometry.dispose();
                       this.mesh.material.dispose();
                       this.mesh = null;
                  }
                  uiManager?.removeWorldHealthBar(this);
                  this.invalid = true;
             }

        }


        // --- NPC Class ---
        console.log("Loading: npc.js");
        class Npc {
            constructor(npcId, x, z) {
                const data = NpcData[npcId];
                 if (!data) { /* ... error handling ... */ this.invalid = true; return; }
                 this.id = npcId; this.name = data.name;
                 this.size = data.size || TILE_SIZE * 0.9;
                 this.pos = new THREE.Vector3(x, this.size * 0.5, z);
                 this.color = new THREE.Color(data.color || 0x0000ff);
                 this.icon = data.icon || 'default_npc';
                 this.dialogue = data.dialogue || [`Greetings.`];
                 this.canFight = data.canFight || false;
                 this.invalid = false;
                 this.mesh = this.createMesh();
                  this.mesh.userData = { gameObject: this, type: 'Npc' };
                  scene.add(this.mesh);
                  intersectableUnits.push(this.mesh); // NPCs can be clicked

                 this.baseStats = JSON.parse(JSON.stringify({
                      maxHP: data.hp || 50, attack: data.attack || 0, defense: data.defense || 0, speed: data.speed || 1, attackRange: data.attackRange || TILE_SIZE * 1.0, aggroRange: data.aggroRange || TILE_SIZE * 4,
                 }));
                 this.pursuitRangeMultiplier = data.pursuitRangeMultiplier || 1.0;
                 this.currentStats = { ...this.baseStats };
                 this.stats = { hp: this.baseStats.maxHP };

                 this.targetEnemy = null; // Monster target
                 this.state = 'idle'; // 'idle', 'fighting', 'dead'
                 this.lastAttackTime = -Infinity;
                 this.attackCooldown = (data.attackCooldown || 2.0) + Math.random() * 0.2 - 0.1; // Seconds

                  // Add a health bar element if fightable
                  this.healthBarElement = null;
                  this.worldPos2D = { x: -1000, y: -1000};
                   if(this.canFight) this.healthBarElement = uiManager?.addWorldHealthBar(this, true); // true for NPC style


            }
             createMesh() {
                  // Capsule for NPCs too
                  const radius = this.size * 0.35;
                  const height = this.size * 0.9;
                  const geo = new THREE.CapsuleGeometry(radius, height, 4, 10);
                  const mat = new THREE.MeshStandardMaterial({
                       color: this.color,
                       roughness: 0.8,
                       metalness: 0.1
                  });
                  const mesh = new THREE.Mesh(geo, mat);
                  mesh.position.copy(this.pos);
                  mesh.castShadow = true;
                   mesh.receiveShadow = false;
                  return mesh;
             }
             interact(player) {
                 if (this.state === 'dead' || this.invalid) return;
                 const msg = randomFromArray(this.dialogue) || `Hello.`;
                 if (uiManager) uiManager.addMessage(`${this.name}: "${msg}"`, 'cyan', 4000);
                  playSound('npcInteract'); // Needs defining

                  // Face the player when interacting
                  if(player?.mesh) {
                      this.mesh.lookAt(player.pos.x, this.pos.y, player.pos.z);
                  }
                 // TODO: Open quest/trade UI?
             }
              takeDamage(damage, attacker) {
                  if (this.state === 'dead' || this.invalid) return;
                  if (!this.stats) this.stats = { hp: 0 };

                  this.stats.hp -= damage;
                  if (uiManager) uiManager.addFloatingText(`-${damage}`, this.pos, 'orange');
                  // Play NPC hit sound

                  // Flash effect
                  if (this.mesh) {
                      const originalColor = this.mesh.material.color.getHex();
                      this.mesh.material.color.setHex(0xff8c00); // Dark Orange flash
                      setTimeout(() => { if(this.mesh) this.mesh.material.color.setHex(originalColor); }, 100);
                  }

                  if (this.stats.hp <= 0) {
                      this.die(attacker);
                  } else {
                       // Aggro if can fight and attacked by a monster
                       if (this.canFight && attacker instanceof Monster) {
                           if(attacker.mesh && attacker.stats.hp > 0){
                                this.targetEnemy = attacker;
                                if (this.state !== 'fighting') {
                                     this.state = 'fighting';
                                     console.log(`${this.name} is fighting ${attacker.name}!`);
                                }
                           }
                       }
                  }
              }
              die(killer) {
                  if (this.state === 'dead' || this.invalid) return;
                  this.stats.hp = 0;
                  this.state = 'dead';
                  const killerName = killer?.name ?? 'causes unknown';
                  console.log(`NPC ${this.name} slain by ${killerName}.`);
                   // Play NPC death sound

                   // Remove from intersectables, make mesh transparent/fall?
                  const index = intersectableUnits.indexOf(this.mesh);
                  if (index > -1) intersectableUnits.splice(index, 1);
                  if (this.mesh) {
                       this.mesh.castShadow = false;
                       this.mesh.material.transparent = true;
                       this.mesh.material.opacity = 0.4;
                       // Simple fall sideways
                       this.mesh.rotation.z = -Math.PI / 2 + (Math.random()-0.5)*0.3;
                  }
                  // Remove health bar
                  uiManager?.removeWorldHealthBar(this);
              }
              attack(target) {
                  if (!target || !target.mesh || target.stats.hp <= 0 || this.state !== 'fighting' || this.invalid) {
                       this.targetEnemy = null; if(this.stats.hp > 0) this.state = 'idle'; return;
                  }
                  const now = gameTime;
                  if (now - this.lastAttackTime >= this.attackCooldown) {
                       const targetDefense = target.currentStats?.defense ?? 0;
                       let damage = Math.max(1, this.currentStats.attack - targetDefense);
                       damage = Math.floor(damage * (Math.random() * 0.2 + 0.9));

                       if(typeof target.takeDamage === 'function') target.takeDamage(damage, this);
                       // Play NPC attack sound
                        this.playAttackAnimation(target);

                       this.lastAttackTime = now;
                       if (target.stats.hp <= 0) { this.targetEnemy = null; this.state = 'idle'; }
                  }
              }

              playAttackAnimation(target){
                  if (target?.mesh) {
                       const lineMat = new THREE.LineBasicMaterial({color: 0xaaaaff, transparent: true, opacity: 0.7});
                       const points = [this.pos.clone().add(new THREE.Vector3(0,this.size*0.1,0)), target.pos.clone().add(new THREE.Vector3(0,target.size*0.1,0)) ];
                       const lineGeo = new THREE.BufferGeometry().setFromPoints(points);
                       const line = new THREE.Line(lineGeo, lineMat);
                       scene.add(line);
                       setTimeout(() => {
                            scene.remove(line);
                            lineMat.dispose();
                            lineGeo.dispose();
                       }, 110);
                   }
              }

              update(deltaTime, monsters, player, map) {
                 if (this.state === 'dead' || this.invalid) return;
                  if (this.canFight) {
                      this.findTarget(monsters); // Find monster target

                      if (this.targetEnemy?.mesh) {
                           // Face target
                           this.mesh.lookAt(this.targetEnemy.pos.x, this.pos.y, this.targetEnemy.pos.z);

                           const distSq = distSqXZ(this.pos, this.targetEnemy.pos);
                           const attackRangeSq = this.currentStats.attackRange ** 2;
                            if (distSq <= attackRangeSq) {
                                this.attack(this.targetEnemy);
                           } else {
                                // Chase if within pursuit range
                                const maxPursuitDistSq = (this.currentStats.aggroRange ** 2) * (this.pursuitRangeMultiplier**2);
                                if(distSq <= maxPursuitDistSq) {
                                     this.moveTowards(this.targetEnemy.pos, deltaTime, map);
                                } else { // Target ran too far
                                      if(this.state === 'fighting') console.log(`${this.name} lost target ${this.targetEnemy.name}.`);
                                     this.targetEnemy = null; this.state = 'idle';
                                }
                           }
                      } else {
                           // No target, ensure idle state
                           if(this.state === 'fighting') this.state = 'idle';
                      }
                  }

                  // Idle behavior? Wander slightly?
                  if (this.state === 'idle') {
                       // Maybe turn occasionally?
                       if(Math.random() < 0.005) {
                            this.mesh.rotation.y += (Math.random() - 0.5) * Math.PI;
                       }
                  }

                  // Update screen position for UI
                  this.worldPos2D = worldToScreen(this.pos);
              }

             findTarget(monsters) {
                  let closestEnemy = null;
                  let minDistSq = (this.targetEnemy ? distSqXZ(this.pos, this.targetEnemy.pos) : Infinity);
                   const validMonsters = monsters.filter(m => m?.mesh && m.stats.hp > 0);

                   // Check current target
                   if (this.targetEnemy) {
                        if (!validMonsters.includes(this.targetEnemy)) {
                             this.targetEnemy = null; this.state = 'idle'; minDistSq = Infinity;
                        } else {
                             const maxChaseDistSq = (this.currentStats.aggroRange ** 2) * (this.pursuitRangeMultiplier**2);
                             if (minDistSq > maxChaseDistSq) {
                                  this.targetEnemy = null; this.state = 'idle'; minDistSq = Infinity;
                             } else {
                                   closestEnemy = this.targetEnemy; // Still valid
                             }
                        }
                   }

                  // Scan for closer monsters
                  const aggroRangeSq = this.currentStats.aggroRange ** 2;
                  for (let monster of validMonsters) {
                       const dSq = distSqXZ(this.pos, monster.pos);
                       if (dSq < aggroRangeSq && dSq < minDistSq) {
                           minDistSq = dSq;
                           closestEnemy = monster;
                       }
                  }

                   // Update target and state
                  if (closestEnemy) {
                       if (this.targetEnemy !== closestEnemy) {
                            this.targetEnemy = closestEnemy;
                            if(this.state !== 'fighting') console.log(`NPC ${this.name} targets ${closestEnemy.name}.`);
                       }
                       this.state = 'fighting'; // Set to fighting if target found
                  } else {
                       if(this.state === 'fighting') this.state = 'idle';
                       this.targetEnemy = null;
                  }
             }

             moveTowards(targetVector3, deltaTime, map) {
                 // Same movement logic as Monster for now
                 if (!targetVector3 || !this.mesh) return false;
                 const moveDir = targetVector3.clone().sub(this.pos);
                 moveDir.y = 0;
                 if (moveDir.lengthSq() < 0.01) return false;
                 moveDir.normalize();
                 const moveAmount = this.currentStats.speed * deltaTime;
                 const moveVector = moveDir.multiplyScalar(moveAmount);
                 const nextPos = this.pos.clone().add(moveVector);
                 if (!map.isObstacle(nextPos.x, nextPos.z) && !map.isOutsideBounds(nextPos.x, nextPos.z)) {
                      this.pos.copy(nextPos);
                      this.mesh.position.copy(this.pos);
                      return true;
                 }
                 return false;
             }

             dispose() {
                 if (this.mesh) {
                      scene.remove(this.mesh);
                      const index = intersectableUnits.indexOf(this.mesh);
                      if (index > -1) intersectableUnits.splice(index, 1);
                      this.mesh.geometry.dispose();
                      this.mesh.material.dispose();
                      this.mesh = null;
                 }
                  uiManager?.removeWorldHealthBar(this);
                 this.invalid = true;
             }

        }


        // --- UI Manager (HTML Overlay Version) ---
        console.log("Loading: ui.js");
        class UIManager {
             constructor() {
                 this.hudElement = document.getElementById('hud');
                 this.hpBar = document.getElementById('hp-bar-inner');
                 this.hpText = document.getElementById('hp-bar-text');
                 this.mpBar = document.getElementById('mp-bar-inner');
                 this.mpText = document.getElementById('mp-bar-text');
                 this.xpBar = document.getElementById('xp-bar-inner');
                 this.xpText = document.getElementById('xp-bar-text');
                 this.systemMessagesContainer = document.getElementById('system-messages');
                 this.inventoryPanel = document.getElementById('inventory-panel');
                 this.inventoryGrid = document.getElementById('inventory-grid');
                 this.equipmentPanel = document.getElementById('equipment-panel');
                 this.equipmentGrid = document.getElementById('equipment-grid');
                 this.tooltipElement = document.getElementById('tooltip');
                 this.floatingTextContainer = document.getElementById('floating-text-container');
                 this.gameOverScreen = document.getElementById('game-over-screen');
                 this.loadingScreen = document.getElementById('loading-screen');
                 this.errorScreen = document.getElementById('error-screen');


                 this.maxMessages = 6;
                 this.systemMessages = []; // Array to hold { element, timeoutId }

                 this.showInventory = false;
                 this.inventorySlots = []; // Store refs to slot elements
                 this.equipmentSlots = {}; // Store refs by slot name

                 this.calculateLayout();
                 this.createInventorySlots();
                 this.createEquipmentSlots();
             }

              showError(message) {
                   this.errorScreen.textContent = message;
                   this.errorScreen.classList.add('visible');
                   this.loadingScreen.style.display = 'none'; // Hide loading
              }

             hideLoading() {
                   this.loadingScreen.style.display = 'none';
             }

             updateHUD() {
                 if (!player || !player.stats || !player.currentStats) return;
                 const hpPercent = (player.currentStats.maxHP > 0 ? player.stats.hp / player.currentStats.maxHP : 0) * 100;
                 const mpPercent = (player.currentStats.maxMP > 0 ? player.stats.mp / player.currentStats.maxMP : 0) * 100;
                 const xpPercent = (player.currentStats.xpToNextLevel > 0 ? player.stats.xp / player.currentStats.xpToNextLevel : 0) * 100;

                 this.hpBar.style.width = `${hpPercent}%`;
                 this.hpText.textContent = `${player.stats.hp}/${player.currentStats.maxHP}`;
                 this.mpBar.style.width = `${mpPercent}%`;
                 this.mpText.textContent = `${player.stats.mp}/${player.currentStats.maxMP}`;
                 this.xpBar.style.width = `${xpPercent}%`;
                  this.xpText.textContent = `Lvl ${player.stats.level} (${player.stats.xp}/${player.currentStats.xpToNextLevel})`;
             }

             addMessage(text, colorHex = '#FFFFFF', duration = 3000) {
                  const messageEl = document.createElement('div');
                  messageEl.classList.add('message');
                  messageEl.textContent = text;
                  messageEl.style.color = colorHex; // Use hex color directly

                  this.systemMessagesContainer.prepend(messageEl); // Add to top (bottom visually due to flex-reverse)
                  const messageData = { element: messageEl };
                  this.systemMessages.push(messageData);

                  // Auto-fade and remove
                  messageData.timeoutId = setTimeout(() => {
                       messageEl.classList.add('fading');
                       setTimeout(() => {
                           if (messageEl.parentNode) { // Check if still attached
                                messageEl.parentNode.removeChild(messageEl);
                           }
                           const index = this.systemMessages.indexOf(messageData);
                           if (index > -1) this.systemMessages.splice(index, 1);
                       }, 500); // Remove after fade out transition
                  }, duration);

                  // Prune old messages if exceeding max
                  if (this.systemMessages.length > this.maxMessages) {
                       const oldestMessage = this.systemMessages.shift();
                       if (oldestMessage && oldestMessage.element.parentNode) {
                            clearTimeout(oldestMessage.timeoutId); // Prevent removal errors
                            oldestMessage.element.parentNode.removeChild(oldestMessage.element);
                       }
                  }
             }

             addFloatingText(text, worldPos, color = 'white', duration = 1.0, size = 16) {
                 const textEl = document.createElement('div');
                 textEl.classList.add('floating-text');
                 textEl.textContent = text;
                 textEl.style.color = color;
                 textEl.style.fontSize = `${size}px`;

                 this.floatingTextContainer.appendChild(textEl);

                  // Calculate initial screen position
                  const screenPos = worldToScreen(worldPos);
                  const startY = screenPos.y;
                  textEl.style.left = `${screenPos.x}px`;
                  textEl.style.top = `${startY}px`;
                  textEl.style.opacity = 1;

                  // Animate upwards movement and fade
                  const endY = startY - 50; // Move up 50 pixels
                  textEl.style.transform = `translate(-50%, -50px)`; // Use transform for smoother animation
                  textEl.style.opacity = 0;
                  textEl.style.transition = `transform ${duration}s ease-out, opacity ${duration}s ease-out`;


                 // Remove element after animation
                  setTimeout(() => {
                      if (textEl.parentNode) {
                          textEl.parentNode.removeChild(textEl);
                      }
                  }, duration * 1000);
             }

             calculateLayout() {
                 // Position inventory and equipment panels based on window size
                 const margin = 15;
                 const panelWidthInv = 4 * (45 + 6) + 6 + 20; // Based on grid cols, slot size, gap, padding
                 const panelWidthEq = 1 * (45 + 6) + 6 + 80 + 20; // Col, gap, label width, padding

                 this.inventoryPanel.style.right = `${margin}px`;
                  this.inventoryPanel.style.top = '50%';
                   this.inventoryPanel.style.transform = 'translateY(-50%)';
                   this.inventoryPanel.style.width = `${panelWidthInv}px`;

                   this.equipmentPanel.style.right = `${margin + panelWidthInv + margin}px`;
                   this.equipmentPanel.style.top = '50%';
                   this.equipmentPanel.style.transform = 'translateY(-50%)';
                   this.equipmentPanel.style.width = `${panelWidthEq}px`;
             }

             createInventorySlots() {
                  this.inventoryGrid.innerHTML = ''; // Clear existing
                  this.inventorySlots = [];
                  for (let i = 0; i < PlayerDefaults.inventorySize; i++) {
                       const slotEl = this.createSlotElement(i, 'inventory');
                       this.inventoryGrid.appendChild(slotEl);
                       this.inventorySlots.push(slotEl);
                  }
             }
             createEquipmentSlots() {
                  this.equipmentGrid.innerHTML = ''; // Clear existing
                  this.equipmentSlots = {};
                   const slotOrder = ['weapon', 'helmet', 'armor', 'boots', 'amulet', 'ring1', 'ring2'];
                   const slotLabels = { weapon: 'Weapon', helmet: 'Helmet', armor: 'Armor', boots: 'Boots', amulet: 'Amulet', ring1: 'Ring 1', ring2: 'Ring 2' };

                  slotOrder.forEach(slotName => {
                       const slotEl = this.createSlotElement(slotName, 'equipment');
                       const labelEl = document.createElement('div');
                       labelEl.classList.add('slot-label');
                       labelEl.textContent = slotLabels[slotName] || slotName;
                       this.equipmentGrid.appendChild(slotEl);
                       this.equipmentGrid.appendChild(labelEl);
                       this.equipmentSlots[slotName] = slotEl;
                  });
             }

             createSlotElement(id, type) {
                  const slotEl = document.createElement('div');
                  slotEl.classList.add('item-slot');
                  slotEl.dataset.slotId = id; // Store index or name
                  slotEl.dataset.slotType = type; // 'inventory' or 'equipment'

                  // Placeholder for item icon structure
                  slotEl.innerHTML = `
                      <div class="item-icon"></div>
                      <div class="item-quantity"></div>
                  `;

                   // Add event listeners directly here
                   slotEl.addEventListener('click', (e) => {
                       e.stopPropagation(); // Prevent click from bubbling to canvas/document
                       this.handleSlotClick(id, type, e.button); // Pass button: 0=left, 2=right
                   });
                    slotEl.addEventListener('contextmenu', (e) => {
                        e.preventDefault(); // Prevent browser context menu on right click
                         e.stopPropagation();
                        this.handleSlotClick(id, type, 2); // Treat contextmenu as right click
                   });
                   slotEl.addEventListener('mouseenter', () => this.handleSlotMouseEnter(id, type));
                   slotEl.addEventListener('mouseleave', () => this.handleSlotMouseLeave());

                  return slotEl;
             }

             updateInventory() {
                 if (!player || !player.inventory) return;
                 for (let i = 0; i < this.inventorySlots.length; i++) {
                     this.updateSlotElement(this.inventorySlots[i], player.inventory[i]);
                 }
             }
             updateEquipment() {
                 if (!player || !player.equipment) return;
                 for (const slotName in this.equipmentSlots) {
                     this.updateSlotElement(this.equipmentSlots[slotName], player.equipment[slotName]);
                 }
             }

             updateSlotElement(slotEl, item) {
                  const iconEl = slotEl.querySelector('.item-icon');
                  const quantityEl = slotEl.querySelector('.item-quantity');
                  if (!iconEl || !quantityEl) return;

                  if (item) {
                      iconEl.className = `item-icon icon-${item.icon || 'default'} ${item.rarity || 'common'}`; // Update icon class
                      iconEl.style.display = 'block';
                      if (item.stackable && item.quantity > 1) {
                          quantityEl.textContent = item.quantity;
                          quantityEl.style.display = 'block';
                      } else {
                          quantityEl.style.display = 'none';
                      }
                       slotEl.dataset.hasItem = 'true'; // Mark slot as having an item for tooltip logic
                  } else {
                      iconEl.className = 'item-icon'; // Reset class
                      iconEl.style.display = 'none';
                      quantityEl.style.display = 'none';
                       slotEl.dataset.hasItem = 'false';
                  }
             }

             toggleInventory() {
                 this.showInventory = !this.showInventory;
                 if (this.showInventory) {
                     this.inventoryPanel.classList.add('visible');
                     this.equipmentPanel.classList.add('visible');
                     this.updateInventory();
                     this.updateEquipment();
                      playSound('openInventory'); // Needs defining
                 } else {
                     this.inventoryPanel.classList.remove('visible');
                     this.equipmentPanel.classList.remove('visible');
                      this.hideTooltip();
                      playSound('closeInventory'); // Needs defining
                 }
             }

              // --- Slot Interaction Handling ---
              handleSlotClick(id, type, button) {
                   if (!player) return;
                   console.log(`Slot clicked: type=${type}, id=${id}, button=${button}`); // Debug
                    if(button === 2) { // Right Click
                         if(type === 'inventory') {
                              const item = player.inventory[id];
                              if(item?.type === 'consumable') player.useItem(id);
                              else if(item?.type === 'equipment') player.equipItem(id);
                         } else if (type === 'equipment') {
                              player.unequipItem(id); // 'id' here is the slot name
                         }
                    } else if (button === 0) { // Left Click
                         // TODO: Implement item dragging/moving if desired
                          console.log("Left click on slot - Drag/Move not implemented.");
                    }
              }
              handleSlotMouseEnter(id, type) {
                   let item = null;
                   if(type === 'inventory') item = player?.inventory[id];
                   else if(type === 'equipment') item = player?.equipment[id];

                   if(item) this.showTooltip(item);
                   else this.hideTooltip();
              }
              handleSlotMouseLeave() {
                  this.hideTooltip();
              }

             // --- Tooltip Handling ---
             showTooltip(item) {
                  if (!item || !this.tooltipElement) return;
                  this.tooltipElement.innerHTML = this.generateItemTooltipHTML(item);
                  this.tooltipElement.style.display = 'block';
                  // Position tooltip near mouse - need mouse coords from event if possible,
                  // otherwise position relative to slot (less ideal)
                   // Let's update position on mouse move instead
             }
              hideTooltip() {
                  if (this.tooltipElement) this.tooltipElement.style.display = 'none';
              }
              updateTooltipPosition(mouseX, mouseY) {
                   if (!this.tooltipElement || this.tooltipElement.style.display === 'none') return;
                   const margin = 15;
                   let x = mouseX + margin;
                   let y = mouseY + margin;
                   const screenW = window.innerWidth;
                   const screenH = window.innerHeight;
                   const tipRect = this.tooltipElement.getBoundingClientRect();

                   if (x + tipRect.width > screenW) x = mouseX - tipRect.width - margin;
                   if (y + tipRect.height > screenH) y = mouseY - tipRect.height - margin;
                   x = Math.max(0, x); y = Math.max(0, y);

                   this.tooltipElement.style.left = `${x}px`;
                   this.tooltipElement.style.top = `${y}px`;
              }

             generateItemTooltipHTML(item) {
                 const rarityColor = getRarityHexColor(item.rarity);
                 let tip = `<div style="color: ${rarityColor}; font-weight: bold; margin-bottom: 5px;">${item.name}</div>`;

                 const slotText = UIText[item.slot] || item.slot || 'Unknown Slot';
                 const typeText = item.type === 'equipment' ? `${UIText.equip} (${slotText})` :
                                  item.type === 'consumable' ? `<span style="color:#DDA0DD;">${UIText.use}</span>` :
                                   item.type === 'material' ? `<span style="color:#B0B0B0;">Material</span>` : item.type;
                 tip += `<div style="font-size: 11px; color: #ccc; margin-bottom: 8px;">${typeText}</div>`;


                 if (item.stats) {
                      tip += `<div style="margin-bottom: 5px;">`;
                      for (const stat in item.stats) {
                           let sign = item.stats[stat] >= 0 ? '+' : '';
                           let statText = UIText[stat] || stat;
                           tip += `<div style="color: #FFFFFFA0;">${statText}: ${sign}${item.stats[stat]}</div>`;
                      }
                      tip += `</div>`;
                 }
                 if (item.effect) {
                     tip += `<div style="margin-bottom: 5px;">`;
                      for (const effect in item.effect) {
                           let effectText = UIText[effect] || effect;
                           tip += `Restore ${effectText}: ${item.effect[effect]}<br>`;
                      }
                      tip += `</div>`;
                 }

                 if (item.stackable) {
                      tip += `Quantity: ${item.quantity} / ${item.maxStack}<br>`;
                 }

                 tip += `<div style="margin-top: 8px; color: #B0B0B0; font-style: italic;">"${item.description || ''}"</div>`;
                 return tip;
             }

             // --- World Health Bars ---
             addWorldHealthBar(unit, isNpc = false) {
                 if (!unit || !unit.mesh) return null; // Ensure unit and mesh exist
                  const barEl = document.createElement('div');
                  barEl.classList.add('health-bar-world');
                  const innerBarEl = document.createElement('div');
                  innerBarEl.classList.add('health-bar-world-inner');
                  if(isNpc) innerBarEl.classList.add('npc-health-bar-world-inner'); // Style NPC bars differently
                  barEl.appendChild(innerBarEl);
                  this.floatingTextContainer.appendChild(barEl);
                  worldHealthBars.push({ unit: unit, element: barEl, innerElement: innerBarEl });
                  return barEl; // Return the element reference
             }
              removeWorldHealthBar(unit) {
                   const index = worldHealthBars.findIndex(wb => wb.unit === unit);
                   if (index > -1) {
                        const barData = worldHealthBars[index];
                        if (barData.element.parentNode) {
                             barData.element.parentNode.removeChild(barData.element);
                        }
                        worldHealthBars.splice(index, 1);
                   }
              }
             updateWorldHealthBars() {
                   worldHealthBars.forEach(barData => {
                        const unit = barData.unit;
                        if (!unit || !unit.mesh || !unit.stats || !unit.baseStats || unit.state === 'dead') {
                             // Unit died or became invalid, hide the bar (removal handled separately)
                             barData.element.style.display = 'none';
                             return;
                        }

                        // Show bar only if damaged
                        if (unit.stats.hp < unit.baseStats.maxHP) {
                             const hpPercent = (unit.baseStats.maxHP > 0 ? unit.stats.hp / unit.baseStats.maxHP : 0) * 100;
                             barData.innerElement.style.width = `${hpPercent}%`;

                             // Position above the unit's mesh
                             const screenPos = worldToScreen(unit.pos); // Use unit's cached screen pos? Recalc here?
                             const barYOffset = -unit.size * 0.8 * (window.innerHeight / camera.fov); // Adjust offset based on perspective/zoom? Hardcoded for now.
                              const finalY = screenPos.y - unit.size * TILE_SIZE * 0.15; // Empirical adjustment

                              // Basic visibility check (rough)
                              if (screenPos.x < -50 || screenPos.x > window.innerWidth + 50 || screenPos.y < -50 || screenPos.y > window.innerHeight + 50) {
                                  barData.element.style.display = 'none';
                              } else {
                                  barData.element.style.left = `${screenPos.x}px`;
                                  barData.element.style.top = `${finalY}px`; // Use calculated final Y
                                  barData.element.style.display = 'block';
                              }
                        } else {
                             barData.element.style.display = 'none'; // Hide if full health
                        }
                   });
              }


             // --- Game Over ---
             showGameOverScreen() {
                  this.gameOverScreen.classList.add('visible');
             }
              hideGameOverScreen() {
                   this.gameOverScreen.classList.remove('visible');
              }

             // Update called in main animation loop
             update() {
                 // Update positions of floating elements like health bars
                 this.updateWorldHealthBars();
             }
        }


        // =============================================
        // --- Main Game Logic (sketch.js equivalent) ---
        // =============================================
        console.log("Loading: sketch.js");

        function init() {
            try {
                console.log("Game init starting...");

                // --- Three.js Setup ---
                scene = new THREE.Scene();
                scene.background = new THREE.Color(0x101015);
                 scene.fog = new THREE.Fog(0x101015, TILE_SIZE * 15, TILE_SIZE * 35); // Add fog

                 const aspect = window.innerWidth / window.innerHeight;
                camera = new THREE.PerspectiveCamera(50, aspect, 0.1, TILE_SIZE * 100); // Adjust FOV, near/far
                 // Position camera looking down at an angle (Diablo-like)
                camera.position.set(0, TILE_SIZE * 10, TILE_SIZE * 8); // Y up, Z towards viewer
                 camera.lookAt(0, 0, 0); // Look at the center initially

                renderer = new THREE.WebGLRenderer({ antialias: true });
                renderer.setSize(window.innerWidth, window.innerHeight);
                 renderer.shadowMap.enabled = true; // Enable shadows
                 renderer.shadowMap.type = THREE.PCFSoftShadowMap; // Softer shadows
                document.body.appendChild(renderer.domElement);

                 // Raycaster for mouse interaction
                 raycaster = new THREE.Raycaster();
                 mouseNDC = new THREE.Vector2();

                 // Lighting
                 const ambientLight = new THREE.AmbientLight(0x404060, 1.5); // Soft ambient light
                 scene.add(ambientLight);

                 const directionalLight = new THREE.DirectionalLight(0xffeedd, 1.8); // Sun-like light
                 directionalLight.position.set(TILE_SIZE * 5, TILE_SIZE * 15, TILE_SIZE * 10); // Position high and angled
                 directionalLight.castShadow = true;
                 directionalLight.shadow.mapSize.width = 2048; // Higher resolution shadows
                 directionalLight.shadow.mapSize.height = 2048;
                 directionalLight.shadow.camera.near = 0.5;
                 directionalLight.shadow.camera.far = TILE_SIZE * 50;
                  // Adjust shadow camera bounds to cover map area
                 directionalLight.shadow.camera.left = -MapSettings.wildernessWidth * TILE_SIZE * 0.6;
                 directionalLight.shadow.camera.right = MapSettings.wildernessWidth * TILE_SIZE * 0.6;
                 directionalLight.shadow.camera.top = MapSettings.wildernessHeight * TILE_SIZE * 0.6;
                 directionalLight.shadow.camera.bottom = -MapSettings.wildernessHeight * TILE_SIZE * 0.6;
                 scene.add(directionalLight);
                 // const shadowHelper = new THREE.CameraHelper( directionalLight.shadow.camera ); scene.add( shadowHelper ); // Debug shadows

                // Ground Plane for Raycasting
                const groundGeometry = new THREE.PlaneGeometry(MapSettings.wildernessWidth * TILE_SIZE * 2, MapSettings.wildernessHeight * TILE_SIZE * 2); // Make it large
                const groundMaterial = new THREE.MeshStandardMaterial({ color: 0x222222, visible: false }); // Invisible ground for raycasting
                groundPlane = new THREE.Mesh(groundGeometry, groundMaterial);
                groundPlane.rotation.x = -Math.PI / 2; // Rotate flat
                groundPlane.position.y = -0.1; // Slightly below objects
                groundPlane.userData.type = 'Ground';
                scene.add(groundPlane);


                // --- Game Object Initialization ---
                uiManager = new UIManager();

                console.log("Generating initial maps...");
                villageMap = new GameMap(MapSettings.villageWidth, MapSettings.villageHeight, true);
                wildernessMap = new GameMap(MapSettings.wildernessWidth, MapSettings.wildernessHeight, false);

                console.log("Creating player...");
                let startPos = villageMap?.entryPoint ?? new THREE.Vector3(0, 0, TILE_SIZE * 2); // Use village entry or default
                player = new Player(startPos.x, startPos.z);
                 // Add player health bar
                 player.healthBarElement = uiManager.addWorldHealthBar(player);


                console.log("Spawning initial NPCs...");
                spawnInitialNpcs();

                currentMap = villageMap;
                gameState = 'village';
                switchMap(villageMap, player.pos); // Call switchMap to ensure correct setup

                centerCameraOnPlayer(true);

                if (uiManager) {
                    uiManager.addMessage(UIText.welcome, getRarityHexColor('rare'), 5000);
                    uiManager.addMessage("Click screen to enable sound", '#cccc88', 10000);
                }

                 // Give starting items
                 if (player) {
                     const hpPot = new Item('hp_potion_small', 5); if(!hpPot.invalid) player.pickupItem({ item: hpPot }); // Simulate pickup
                     const sword = new Item('rusty_sword'); if(!sword.invalid) player.pickupItem({ item: sword });
                     const armor = new Item('leather_armor'); if(!armor.invalid) player.pickupItem({ item: armor });
                     uiManager?.updateInventory(); // Update UI after adding items
                     uiManager?.updateEquipment();
                 }

                 // Sound Setup (Oscillators)
                 setupSounds();

                 // Event Listeners
                 window.addEventListener('resize', onWindowResize);
                 window.addEventListener('keydown', onKeyDown);
                 window.addEventListener('keyup', onKeyUp);
                 renderer.domElement.addEventListener('mousedown', onMouseDown); // Attach to canvas
                 renderer.domElement.addEventListener('mousemove', onMouseMove);
                  // Prevent right-click menu on canvas
                 renderer.domElement.addEventListener('contextmenu', (e) => e.preventDefault());

                console.log("Game init complete. Initial state:", gameState);
                 uiManager?.hideLoading(); // Hide loading screen

                // Start the animation loop
                animate();
            } catch (error) {
                 console.error("Initialization failed:", error);
                 uiManager?.showError("Initialization failed! Check console.");
            }
        }

        function setupSounds() {
             if (typeof p5 === 'undefined' || !p5.Oscillator) {
                 console.warn("p5.sound or p5.Oscillator not available. Sound effects disabled.");
                 return;
             }
             try {
                 sounds.playerAttack = new p5.Oscillator('sine'); sounds.playerAttack.freq(330); // E4
                 sounds.playerHit = new p5.Oscillator('sawtooth'); sounds.playerHit.freq(165); // E3
                 sounds.monsterHit = new p5.Oscillator('square'); sounds.monsterHit.freq(220); // A3
                 sounds.pickupItem = new p5.Oscillator('triangle'); sounds.pickupItem.freq(880); // A5
                 sounds.levelUp = new p5.Oscillator('sine'); sounds.levelUp.freq(660); // E5
                 sounds.equipItem = new p5.Oscillator('sine'); sounds.equipItem.freq(440); // A4
                 sounds.useItem = new p5.Oscillator('triangle'); sounds.useItem.freq(523); // C5
                 sounds.openInventory = new p5.Oscillator('sine'); sounds.openInventory.freq(494); // B4 up
                 sounds.closeInventory = new p5.Oscillator('sine'); sounds.closeInventory.freq(466); // Bb4 down
                 sounds.invalidAction = new p5.Oscillator('sawtooth'); sounds.invalidAction.freq(110); // A2 low buzz
                 sounds.playerDeath = new p5.Oscillator('sawtooth'); sounds.playerDeath.freq(82); // E2 very low
                 sounds.monsterAttackRanged = new p5.Oscillator('square'); sounds.monsterAttackRanged.freq(294); // D4
                 sounds.npcInteract = new p5.Oscillator('triangle'); sounds.npcInteract.freq(587); // D5

                 Object.values(sounds).forEach(osc => {
                     if (osc instanceof p5.Oscillator) {
                          osc.amp(0); osc.start();
                     }
                 });
                  console.log("Sound oscillators created.");
             } catch (e) {
                  console.error("Failed to create p5.Oscillators:", e);
             }
        }

         function playSound(soundName, duration = 0.1, volume = 0.8) {
              if (sounds[soundName] && audioInitialized && sounds[soundName] instanceof p5.Oscillator) {
                  sounds[soundName].amp(volume * masterVolume, 0.01);
                  sounds[soundName].amp(0, 0.1, duration);
              }
         }

        function initializeAudio() {
            if (!audioInitialized && typeof p5 !== 'undefined' && typeof getAudioContext === 'function') {
                const context = getAudioContext();
                if (context.state !== 'running') {
                    context.resume().then(() => {
                        console.log("AudioContext resumed.");
                        audioInitialized = true;
                         if(uiManager) uiManager.addMessage("Sound Enabled.", "#afc", 1500);
                    }).catch(e => console.error("AudioContext resume error:", e));
                } else {
                    audioInitialized = true; // Already running
                }
            }
        }

        function spawnInitialNpcs(){
             npcs.length = 0; // Clear array
             intersectableUnits.splice(0, intersectableUnits.length, ...intersectableUnits.filter(m => !(m.userData.gameObject instanceof Npc))); // Remove old NPC meshes
             if (typeof NpcData === 'undefined' || !villageMap || typeof Npc === 'undefined') return;
             const npcIds = Object.keys(NpcData);
             if (npcIds.length === 0) return;

             let npcIndex = 0;
             if (villageMap.spawnPoints && Array.isArray(villageMap.spawnPoints)) {
                  villageMap.spawnPoints.forEach((spawnPos) => {
                      if (spawnPos instanceof THREE.Vector3) {
                           let npcId = npcIds[npcIndex % npcIds.length];
                           let newNpc = new Npc(npcId, spawnPos.x, spawnPos.z);
                           if (newNpc && !newNpc.invalid) {
                               npcs.push(newNpc); npcIndex++;
                           }
                      }
                  });
             }
             console.log(`Spawned ${npcs.length} NPCs.`);
        }

        const clock = new THREE.Clock(); // For delta time

        function animate() {
            // Request the next frame
            requestAnimationFrame(animate);

             const deltaTime = clock.getDelta();
             gameTime += deltaTime; // Update global game time

             // Update game logic only if not game over
             if (gameState !== 'gameOver' && gameState !== 'paused') { // Add paused state later
                  // Update player
                  let playerMoved = false;
                  if (player && player.stats.hp > 0) {
                       const allUnits = [player, ...monsters, ...npcs];
                       playerMoved = player.update(deltaTime, allUnits, currentMap);
                       if (playerMoved) {
                            checkMapTransition();
                            checkItemPickup();
                       }
                  }

                   // Update Monsters
                   const currentUnits = [player, ...monsters, ...npcs]; // Pass all for collision checks?
                   for (let i = monsters.length - 1; i >= 0; i--) {
                       const monster = monsters[i];
                       if (monster && !monster.invalid) {
                            if(monster.state !== 'dead') monster.update(deltaTime, player, npcs, currentMap);
                       } else {
                            monsters.splice(i, 1); // Remove invalid monsters
                       }
                   }

                   // Update NPCs (only in village)
                   if (currentMap.isVillage) {
                       npcs.forEach(npc => {
                           if (npc && npc.state !== 'dead') {
                               npc.update(deltaTime, monsters, player, currentMap);
                           }
                       });
                   }

                   // Update Projectiles
                   const allUnitsForProj = [player, ...monsters, ...npcs];
                   for (let i = projectiles.length - 1; i >= 0; i--) {
                       const proj = projectiles[i];
                       if (!proj || !proj.update(deltaTime, allUnitsForProj, currentMap)) {
                           // update returns false if projectile needs removal (already disposed)
                           projectiles.splice(i, 1);
                       }
                   }

                   // Update World Items (bobbing, expiration)
                   for (let i = worldItems.length - 1; i >= 0; i--) {
                       const item = worldItems[i];
                       if (item && !item.invalid) {
                           item.update(); // Handles expiration and disposal
                            if (item.isExpired()) { // Check again after update
                                 worldItems.splice(i, 1);
                            }
                       } else {
                            worldItems.splice(i, 1); // Remove invalid items
                       }
                   }

                  // Spawn new monsters
                  if (gameState === 'wilderness') {
                      spawnMonsters(); // Uses gameTime internally now
                  }
             } // End game update block

             // Update camera smoothly towards player
             updateCamera(deltaTime);

             // Update UI elements (health bars, floating text positions)
             uiManager?.update();

            // Render the scene
            renderer.render(scene, camera);
        }

        function updateCamera(deltaTime) {
             if (!player || !player.pos) return;
             // Target slightly behind the player from the camera's angle
             const cameraOffset = new THREE.Vector3(0, TILE_SIZE * 10, TILE_SIZE * 8); // Consistent offset from origin (like initial pos)
             const targetCamPos = player.pos.clone().add(cameraOffset);

              // Smooth interpolation
             const lerpFactor = 1.0 - Math.pow(0.02, deltaTime); // Smoother lerp based on delta time
             camera.position.lerp(targetCamPos, lerpFactor);

              // Always look at the player's position (or slightly in front?)
              const lookAtPos = player.pos.clone();
              // Optional: look slightly ahead based on movement? Simpler to just look at player.
             camera.lookAt(lookAtPos);

             // Map boundary clamping could be added here if needed, but perspective makes it tricky.
        }
        function centerCameraOnPlayer(immediate = false) {
             if (!player || !player.pos) return;
              const cameraOffset = new THREE.Vector3(0, TILE_SIZE * 10, TILE_SIZE * 8);
              const targetCamPos = player.pos.clone().add(cameraOffset);
              if (immediate) {
                   camera.position.copy(targetCamPos);
              } else {
                   // Just set target for lerp (handled by updateCamera)
                    // Maybe force a larger lerp step?
                     camera.position.lerp(targetCamPos, 0.5); // Faster lerp
              }
               camera.lookAt(player.pos);
        }

        function checkMapTransition() {
             if (!player || !player.pos || !currentMap) return;

             if (currentMap.isVillage && currentMap.isOnExit(player.pos.x, player.pos.z)) {
                  if (wildernessMap?.entryPoint) {
                      switchMap(wildernessMap, wildernessMap.entryPoint);
                      if (uiManager) uiManager.addMessage(UIText.leaveVillage, '#ffb464', 3000);
                  } else { console.error("Wilderness invalid!"); }
             } else if (!currentMap.isVillage && currentMap.isOnVillageEntrance(player.pos.x, player.pos.z)) {
                  if (villageMap?.entryPoint) {
                       switchMap(villageMap, villageMap.entryPoint);
                       if (uiManager) uiManager.addMessage(UIText.enterVillage, '#96c8ff', 3000);
                  } else { console.error("Village invalid!"); }
             }
        }

        function switchMap(newMap, playerSpawnPoint) {
             if (!newMap || !playerSpawnPoint) { console.error("SwitchMap failed."); return; }
             console.log(`Switching map to ${newMap.isVillage ? 'Village' : 'Wilderness'}`);

              // 1. Dispose old map mesh if different
              if (currentMap && currentMap !== newMap) {
                   currentMap.dispose(); // Clean up Three.js resources
              }

              // 2. Clear dynamic objects
              projectiles.forEach(p => p.dispose()); projectiles.length = 0;
              worldItems.forEach(i => i.dispose()); worldItems.length = 0;
              monsters.forEach(m => m.dispose()); monsters.length = 0; // Clear monsters on any transition for now
               visualEffects.length = 0; // Clear visual effects
               worldHealthBars.forEach(wb => { if(wb.element.parentNode) wb.element.parentNode.removeChild(wb.element); }); worldHealthBars.length = 0; // Clear world health bars

             // 3. Set new map and state
             currentMap = newMap; // This map should already have its mesh created in its constructor
             gameState = currentMap.isVillage ? 'village' : 'wilderness';

             // 4. Handle NPCs
             if (currentMap.isVillage) {
                  // Ensure NPCs are present and reset state
                  if (npcs.length === 0) spawnInitialNpcs(); // Respawn if needed
                  npcs.forEach(npc => {
                       if (npc && npc.state !== 'dead') {
                           npc.targetEnemy = null; npc.state = 'idle';
                           // Add health bar back if missing
                            if (!worldHealthBars.some(wb => wb.unit === npc) && npc.canFight) {
                                 npc.healthBarElement = uiManager?.addWorldHealthBar(npc, true);
                            }
                       }
                  });
             } else {
                   // Optionally dispose NPC meshes when leaving village? Or just hide them? Let's hide.
                   npcs.forEach(npc => { if (npc.mesh) npc.mesh.visible = false; uiManager?.removeWorldHealthBar(npc); });
             }
              // Ensure NPC meshes are visible when entering village
             if (currentMap.isVillage) {
                  npcs.forEach(npc => { if (npc.mesh) npc.mesh.visible = true; });
             }


             // 5. Reposition player
             if (player?.pos) {
                  player.pos.copy(playerSpawnPoint);
                  player.pos.y = player.size * 0.5; // Ensure correct height
                   if(player.mesh) player.mesh.position.copy(player.pos);
                  player.targetMovePos = null;
                  player.targetEnemy = null;
                  player.isMoving = false;
                   // Ensure player health bar exists
                   if (!worldHealthBars.some(wb => wb.unit === player)) {
                        player.healthBarElement = uiManager?.addWorldHealthBar(player);
                   }
             }

             // 6. Center camera
             centerCameraOnPlayer(true);

             // 7. Recalculate UI layout? (Optional)
             // uiManager?.calculateLayout();

             console.log("Map switch complete.");
        }


         function spawnMonsters() {
             if (!currentMap || currentMap.isVillage || gameState !== 'wilderness' || !player?.pos) return;
             if (typeof MonsterData === 'undefined' || typeof Monster === 'undefined') return;

             const now = gameTime; // Use global game time
             if (now - lastMonsterSpawnTime > MapSettings.monsterSpawnInterval / 1000.0) { // Interval in seconds now
                  lastMonsterSpawnTime = now;
                  let aliveMonsters = monsters.filter(m => m && m.state !== 'dead').length;

                  if (aliveMonsters < MapSettings.maxMonsters) {
                       const spawnPoint = currentMap.getRandomSpawnPoint(player.pos, MapSettings.monsterSpawnCheckRadius ** 2);
                       if (spawnPoint) {
                           // Optional: Check proximity to other monsters
                           let tooClose = monsters.some(m => m?.mesh && m.state !== 'dead' && distSqXZ(spawnPoint, m.pos) < (TILE_SIZE * 1.5)**2);

                           if (!tooClose) {
                                const monsterIds = Object.keys(MonsterData);
                                if (monsterIds.length > 0) {
                                     const randomMonsterId = randomFromArray(monsterIds);
                                     if (randomMonsterId) {
                                         let newMonster = new Monster(randomMonsterId, spawnPoint.x, spawnPoint.z);
                                         if (newMonster && !newMonster.invalid) {
                                             monsters.push(newMonster);
                                              // Add health bar
                                             newMonster.healthBarElement = uiManager?.addWorldHealthBar(newMonster);
                                         }
                                     }
                                }
                           }
                       }
                  }
             }
         }


         function checkItemPickup() {
             if (!player?.pos || !worldItems || worldItems.length === 0) return;
             const pickupRadiusSq = player.pickupRadiusSq;

             for (let i = worldItems.length - 1; i >= 0; i--) {
                  const droppedItem = worldItems[i];
                  if (!droppedItem || !droppedItem.mesh || droppedItem.invalid) continue;

                  if (distSqXZ(player.pos, droppedItem.pos) < pickupRadiusSq) {
                       if (player.pickupItem(droppedItem)) { // pickupItem handles UI messages etc.
                            droppedItem.dispose(); // Remove mesh, mark invalid
                            worldItems.splice(i, 1); // Remove from array
                       } else {
                            // Pickup failed (inventory full)
                       }
                  }
             }
         }

        // --- Input Handlers ---
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
             uiManager?.calculateLayout(); // Adjust HTML UI layout
        }

        function onKeyDown(event) {
             keysPressed[event.key.toLowerCase()] = true;

             if (gameState === 'gameOver') {
                  if (event.key.toLowerCase() === 'r') {
                       restartGame();
                  }
                  return;
             }

             // UI Toggles
             if (event.key.toLowerCase() === 'i') {
                 uiManager?.toggleInventory();
             }
              if (event.key === 'Escape' && uiManager?.showInventory) {
                  uiManager.toggleInventory();
             }

              // Debug Keys (copied from p5 version)
              if (event.key.toLowerCase() === 'l') { if (player?.stats) player.gainXP(player.currentStats.xpToNextLevel - player.stats.xp + 1); }
              if (event.key.toLowerCase() === 'h') { if (player?.stats) { player.stats.hp = player.currentStats.maxHP; player.stats.mp = player.currentStats.maxMP; uiManager?.addFloatingText("++MAX++", player.pos, 'lime', 1.0, 18); uiManager?.updateHUD();} }
              if (event.key.toLowerCase() === 'k') {
                  let nearest = monsters.filter(m=>m?.mesh && m.state!=='dead').sort((a,b)=>distSqXZ(player.pos,a.pos)-distSqXZ(player.pos,b.pos))[0];
                  if(nearest) nearest.takeDamage(99999, player);
              }
              if (event.key.toLowerCase() === 't') {
                   if(villageMap?.entryPoint) {
                        if(currentMap !== villageMap) switchMap(villageMap, villageMap.entryPoint);
                        else { player.pos.copy(villageMap.entryPoint); player.pos.y=player.size*0.5; if(player.mesh)player.mesh.position.copy(player.pos); player.targetMovePos = null; player.targetEnemy = null; player.isMoving = false; centerCameraOnPlayer(true); }
                   }
              }
              if (event.key.toLowerCase() === 'g') {
                   const ids = Object.keys(ItemData); if(ids.length > 0){ const item = new Item(randomFromArray(ids)); if(!item.invalid) player.pickupItem({item: item}); }
              }
        }
        function onKeyUp(event) {
            keysPressed[event.key.toLowerCase()] = false;
        }

        function onMouseMove(event) {
             // Update mouse NDC coordinates for raycasting
             mouseNDC.x = (event.clientX / window.innerWidth) * 2 - 1;
             mouseNDC.y = -(event.clientY / window.innerHeight) * 2 + 1;

              // Update tooltip position if it's visible
              uiManager?.updateTooltipPosition(event.clientX, event.clientY);

              // TODO: Add hover effects? (Highlight monster/item under cursor)
        }

        function onMouseDown(event) {
             if (!audioInitialized) initializeAudio(); // Enable audio on first click
             if (gameState === 'gameOver') return;

             // Check if click is on an HTML UI element (handled by element's listeners)
             // We only process clicks that reach the canvas.

             // Update Raycaster
             raycaster.setFromCamera(mouseNDC, camera);

              // Objects to check for intersection (Order matters!)
              // 1. Units (Monsters, NPCs, Items)
              // 2. Ground Plane
              const intersectsUnits = raycaster.intersectObjects(intersectableUnits);
              let clickedObject = null;

              if (intersectsUnits.length > 0) {
                   // Find the closest intersectable unit
                   const closestUnitIntersect = intersectsUnits[0];
                   clickedObject = closestUnitIntersect.object.userData.gameObject; // Get our game object back

                   if (clickedObject) {
                        console.log("Clicked on:", clickedObject.name || clickedObject.item?.name);
                        if (clickedObject instanceof Monster) {
                             player?.setAttackTarget(clickedObject);
                             return; // Handled
                        } else if (clickedObject instanceof Npc && currentMap.isVillage) {
                             const distSq = distSqXZ(player.pos, clickedObject.pos);
                             const interactDistSq = (TILE_SIZE * 2.0)**2; // Interaction range
                              if (distSq < interactDistSq) {
                                   clickedObject.interact(player);
                              } else {
                                   player?.moveTo(clickedObject.pos); // Move closer to interact
                              }
                              return; // Handled
                        } else if (clickedObject instanceof DroppedItem) {
                             const distSq = distSqXZ(player.pos, clickedObject.pos);
                             if (distSq < player.pickupRadiusSq) {
                                   if (player.pickupItem(clickedObject)) { // Try direct pickup
                                        clickedObject.dispose(); // Remove mesh etc.
                                        const index = worldItems.indexOf(clickedObject);
                                        if(index > -1) worldItems.splice(index, 1);
                                   }
                             } else {
                                  player?.moveTo(clickedObject.pos); // Move closer to pickup
                             }
                             return; // Handled
                        }
                   }
              }

             // If no unit was clicked, check for ground click to move
              const intersectsGround = raycaster.intersectObject(groundPlane);
              if (intersectsGround.length > 0) {
                   const intersectionPoint = intersectsGround[0].point;
                   // Check if the target point is walkable on the map grid
                   if (currentMap && !currentMap.isObstacle(intersectionPoint.x, intersectionPoint.z) && !currentMap.isOutsideBounds(intersectionPoint.x, intersectionPoint.z)) {
                        player?.moveTo(intersectionPoint);
                   } else {
                         playSound('invalidAction'); // Clicked unwalkable ground
                   }
                   return; // Handled
              }

             // Clicked on empty space or unhandled object
             console.log("Clicked empty space.");

        }

        // --- Game Restart ---
        function restartGame() {
             console.log("Restarting game...");
             uiManager?.hideGameOverScreen();

             // 1. Clear existing game objects & resources
             projectiles.forEach(p => p.dispose()); projectiles.length = 0;
             worldItems.forEach(i => i.dispose()); worldItems.length = 0;
             monsters.forEach(m => m.dispose()); monsters.length = 0;
              npcs.forEach(n => n.dispose()); npcs.length = 0;
               visualEffects.length = 0;
              worldHealthBars.forEach(wb => { if(wb.element.parentNode) wb.element.parentNode.removeChild(wb.element); }); worldHealthBars.length = 0;
              if (player) { player.mesh && scene.remove(player.mesh); player = null; } // Remove player mesh

             // 2. Dispose current map resources
              if (currentMap) { currentMap.dispose(); }
              villageMap = null; wildernessMap = null; currentMap = null;

             // 3. Reset timers and state
             lastMonsterSpawnTime = 0;
             gameTime = 0;
             audioInitialized = false; // Require new click for audio

             // 4. Re-initialize (like setup)
             intersectableUnits.length = 0; // Clear intersectable array

             console.log("Re-generating maps...");
             villageMap = new GameMap(MapSettings.villageWidth, MapSettings.villageHeight, true);
             wildernessMap = new GameMap(MapSettings.wildernessWidth, MapSettings.wildernessHeight, false);

             console.log("Re-creating player...");
             let startPos = villageMap?.entryPoint ?? new THREE.Vector3(0, 0, TILE_SIZE * 2);
             player = new Player(startPos.x, startPos.z);
              player.healthBarElement = uiManager.addWorldHealthBar(player);

             console.log("Re-spawning NPCs...");
             spawnInitialNpcs();

             // 5. Reset map and state
             currentMap = villageMap;
             gameState = 'village';
             switchMap(villageMap, player.pos); // Re-setup the map display and player pos

             // 6. Reset UI elements
             uiManager?.addMessage(UIText.welcome, getRarityHexColor('rare'), 5000);
             uiManager?.addMessage("Click screen to enable sound", '#cccc88', 10000);
             uiManager?.updateHUD();
             uiManager?.updateInventory(); // Reflect starting items
             uiManager?.updateEquipment();

              // Give starting items again
              if (player) {
                   const hpPot = new Item('hp_potion_small', 5); if(!hpPot.invalid) player.pickupItem({ item: hpPot });
                   const sword = new Item('rusty_sword'); if(!sword.invalid) player.pickupItem({ item: sword });
                   const armor = new Item('leather_armor'); if(!armor.invalid) player.pickupItem({ item: armor });
                   uiManager?.updateInventory();
              }

             console.log("Game restart complete.");
        }


        // --- Start the game ---
        init();

    </script>
</body>
</html>
